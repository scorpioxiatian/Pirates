<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[系统运维记录]]></title>
      <url>http://www.pisces.ml/2018/07/27/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h1 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h1><p>1.查看硬盘信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/opt/storcli/storcli64 /c0/e8/s6 show all</div><div class="line"># or</div><div class="line">smartctl --all /dev/sdx</div></pre></td></tr></table></figure>
<h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><p>1.ssh连接慢问题：</p>
<p>重启systemd-logind.service服务</p>
<p>本文用于记录日常系统运维，持续更新中………………</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux常用shell脚本记录（附带脚本解析）]]></title>
      <url>http://www.pisces.ml/2018/05/10/linux%E5%B8%B8%E7%94%A8shell%E8%84%9A%E6%9C%AC%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>由于工作中经常会用到一些shell来统计或者做一些批量操作，一些shell用的少，突然用的时候可能会忘记。本文用于记录工作中用到shell命令，以便日后备用。好记性不如烂笔头嘛！！！</p>
<h3 id="统计服务器socket连接数"><a href="#统计服务器socket连接数" class="headerlink" title="统计服务器socket连接数"></a>统计服务器socket连接数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;</div></pre></td></tr></table></figure>
<p>shell脚本解析：通过netstat列出当前socket连接信息，并通过管道将结果传递给awk命令，作为awk命令处理的参数，awk命令首先执行正则匹配，过滤出TCP socket，然后用$NF取行的最后一个值作为统计值进行sum统计，最后将得到的数组S打印出来。</p>
<p>awk内建函数参考示例： <a href="https://www.linuxnix.com/awk-scripting-learn-awk-built-in-variables-with-examples/" target="_blank" rel="external">https://www.linuxnix.com/awk-scripting-learn-awk-built-in-variables-with-examples/</a></p>
<p>题外话：<a href="https://jaminzhang.github.io/network/the-difference-between-unix-domain-socket-and-tcp-ip-socket/" target="_blank" rel="external">Unix domain socket 和 TCP/IP socket 的区别</a></p>
]]></content>
      
        <categories>
            
            <category> Shell </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python基础知识——装饰器篇]]></title>
      <url>http://www.pisces.ml/2018/05/08/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E5%99%A8%E7%AF%87/</url>
      <content type="html"><![CDATA[<p>​    本篇文章主要来总结下python中的几种常用的装饰器用法。我们知道在python编程中经常会用到装饰器，因为使用装饰器，我们可以简化代码，避免重复造轮子，使得代码看着更加整洁，增强代码可读性。</p>
<p>​    说到装饰器的用法，不得不提下装饰器在openstack中的应用。本人入行已有三年之久，现在专注于云计算开发运维，编程习惯以及编码风格受了openstack社区极大影响，社区大牛多之前就看了keystone的源码，你会发现刚开始看的时候一脸懵逼，静下心好好看看你会发现真的是匠心之作。基本上将装饰器应用到了极致，社区为了简化代码用了很多嵌套的装饰器（真的是层层嵌套），毕竟在设计上许多功能是需要重复使用的，所以其中也大量的用到了装饰器，并且是使用了模块化的层层嵌套，将许多功能封装成许多装饰器，又通过装饰器的组合嵌套来使用，这样一方面避免了代码冗余，另外还实现了代码的组合使用类似于模块化组件，使得代码更加简洁。</p>
<p>​    谈装饰器前还需要注意下，Python 中的函数和 Java、C++不太一样，Python 中的函数可以像普通变量一样当做参数传递给另外一个函数</p>
<h3 id="简单装饰器"><a href="#简单装饰器" class="headerlink" title="简单装饰器"></a>简单装饰器</h3><p>python中通过符号”@“引入装饰器，如下所示是一种简单装饰器写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></div><div class="line">        logging.warn(<span class="string">"%s is running"</span> % func.__name__)</div><div class="line">        <span class="keyword">return</span> func()</div><div class="line">    <span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"><span class="meta">@use_logging</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"i am foo"</span>)</div><div class="line"></div><div class="line">foo()</div></pre></td></tr></table></figure>
<p>​    如上图所示，foo方法作为参数传递给user_logging方法，在user_logging方法中执行完日志功能之后返回foo方法，这样只需要将需要打印日志的地方在函数预定义的地方添加这个装饰器就能实现日志功能。这样做避免了重复在函数中写日志搜集功能相关代码，也使得代码更加简洁明了。</p>
<h3 id="args、-kwargs"><a href="#args、-kwargs" class="headerlink" title="args、*kwargs"></a><em>args、*</em>kwargs</h3><p>​    如上述简单装饰器中，你可能会问如果foo函数需要参数需要怎么办？例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def foo(name)：</div><div class="line">    print("i am %s" % name)</div></pre></td></tr></table></figure>
<p>​    增对参数传递，我们只需将参数传递给wrapper函数，再由wrapper函数传递给foo函数即可。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(name)</span>:</span> <span class="comment"># 此处参数如果未知或者多个可用*args/**kwargs替代，一般情况下我们使用*args/**kwargs</span></div><div class="line">    logging.warn(<span class="string">"%s is running"</span> % func.__name__)</div><div class="line">    <span class="keyword">return</span> func(name)</div></pre></td></tr></table></figure>
<p>​    结合起来完整代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args)</span>:</span> <span class="comment"># 由于函数参数无法确定我们需要使用*args替代</span></div><div class="line">        logging.warn(<span class="string">"%s is running"</span> % func.__name__)</div><div class="line">        <span class="keyword">return</span> func(*args)</div><div class="line">    <span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"><span class="meta">@use_logging</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name)</span>:</span></div><div class="line">    print(<span class="string">"i am %s"</span> % name)</div><div class="line"></div><div class="line">foo(name)</div></pre></td></tr></table></figure>
<h3 id="带参数装饰器"><a href="#带参数装饰器" class="headerlink" title="带参数装饰器"></a>带参数装饰器</h3><p>装饰器在使用中还支持接收参数，如上示例中每个执行函数所需的日志级别肯定不尽相同，我们需要实现功能根据实际需求提供日志级别，这样我们就需要改写user_logging方法，使其支持参数传递，这样就能根据不容参数传入，来选择相应的日志级别。更改如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(level)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">            <span class="keyword">if</span> level == <span class="string">"warn"</span>:</div><div class="line">                logging.warn(<span class="string">"%s is running"</span> % func.__name__)</div><div class="line">            <span class="keyword">elif</span> level == <span class="string">"info"</span>:</div><div class="line">                logging.info(<span class="string">"%s is running"</span> % func.__name__)</div><div class="line">            <span class="keyword">return</span> func(*args)</div><div class="line">        <span class="keyword">return</span> wrapper</div><div class="line">    <span class="keyword">return</span> decorate</div></pre></td></tr></table></figure>
<p>那么我们该如何调用呢？其实也很简单，形同函数传参一样调用时加上相应参数即可。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@use_logging(level="warn")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name)</span>:</span></div><div class="line">    print(<span class="string">"i am %s"</span> %name)</div><div class="line">				</div><div class="line">foo(<span class="string">"hero"</span>)</div></pre></td></tr></table></figure>
<h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>python装饰器实现中不仅仅可以使函数方法，也可以是以类的方式实现。相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器主要依靠类函数的<a href="http://pycoders-weekly-chinese.readthedocs.org/en/latest/issue6/a-guide-to-pythons-magic-methods.html" target="_blank" rel="external">魔术方法</a>“_ <em>call </em> _” ,当调用时只需用语法糖@引入即可，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></div><div class="line">        self._func = func</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></div><div class="line">        logging.warn(<span class="string">"%s is running"</span> % self._func.__name)</div><div class="line"> 		self._func()</div><div class="line"> </div><div class="line"><span class="meta">@Log</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"I am foo"</span>)</div><div class="line"></div><div class="line">foo()</div></pre></td></tr></table></figure>
<h3 id="装饰器顺序"><a href="#装饰器顺序" class="headerlink" title="装饰器顺序"></a>装饰器顺序</h3><p>我们知道一个函数是可以引入多个装饰器的，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@func1</span></div><div class="line"><span class="meta">@func2</span></div><div class="line"><span class="meta">@func3</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"do something"</span>)</div></pre></td></tr></table></figure>
<p>执行顺序是从里到外的，即先执行func3再到func1。以下示例能更好的解释执行顺序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f = func1(func2(func3(foo)))</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 装饰器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux 常用软件包命令集锦]]></title>
      <url>http://www.pisces.ml/2018/03/24/linux-%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%91%BD%E4%BB%A4%E9%9B%86%E9%94%A6/</url>
      <content type="html"><![CDATA[<p>本篇用于记录常用linux操作系统软件包安装命令集锦</p>
<h2 id="查询rpm包的依赖关系"><a href="#查询rpm包的依赖关系" class="headerlink" title="查询rpm包的依赖关系"></a>查询rpm包的依赖关系</h2><p><strong><em>查询未安装软件包的依赖关系</em></strong></p>
<p>rpm -qRp xxxxx.rpm</p>
<p><strong>查询已安装软件包依赖</strong></p>
<p>rpm -qR xxxxx</p>
<h2 id="离线下载软件包"><a href="#离线下载软件包" class="headerlink" title="离线下载软件包"></a>离线下载软件包</h2><p>yum install -y –downloadonly –downloaddir=/xxx/xxx xxxxx</p>
<h2 id="搜索仓库所有版本软件包"><a href="#搜索仓库所有版本软件包" class="headerlink" title="搜索仓库所有版本软件包"></a>搜索仓库所有版本软件包</h2><p>yum search –showduplicates xxxxxxx</p>
<h2 id="本地安装rpm软件包"><a href="#本地安装rpm软件包" class="headerlink" title="本地安装rpm软件包"></a>本地安装rpm软件包</h2><p>rpm -ivh xxxxx.rpm or rpm -ivh –force xxxxx.rpm</p>
<h2 id="经验记录"><a href="#经验记录" class="headerlink" title="经验记录"></a>经验记录</h2><p>大部分公司都是私有环境，虽然有自己的私有仓库，但是问题是并不会实时去同步官方的仓库，经常遇到软件包不存在，需要自己离线去下载并上传安装。常用的做法就是本地先起一个相同内核版本的linux操作系统，然后离线下载软件包（包括依赖），最后上传到服务器上用rpm命令进行本地安装。本地安装可能会出现以下类似报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">rpm -ivh openssl-*                                                                                                     准备中...                          ################################# [100%]</div><div class="line">        file /usr/lib64/.libcrypto.so.10.hmac from install of openssl-libs-1:1.0.2k-8.el7.x86_64 conflicts with file from package openssl-libs-1:1.0.1e-60.el7.x86_64</div><div class="line">        file /usr/lib64/.libssl.so.10.hmac from install of openssl-libs-1:1.0.2k-8.el7.x86_64 conflicts with file from package openssl-libs-1:1.0.1e-60.el7.x86_64</div><div class="line">        file /usr/lib64/libcrypto.so.10 from install of openssl-libs-1:1.0.2k-8.el7.x86_64 conflicts with file from package openssl-libs-1:1.0.1e-60.el7.x86_64</div><div class="line">        file /usr/lib64/libssl.so.10 from install of openssl-libs-1:1.0.2k-8.el7.x86_64 conflicts with file from package openssl-libs-1:1.0.1e-60.el7.x86_64</div></pre></td></tr></table></figure>
<p>此时可以尝试强制安装命令（<strong>强制安装前需要检查软件包的依赖，查看系统有的软件包是否满足安装依赖需求</strong>）：</p>
<p>rpm -ivh –force xxxxxx.rpm</p>
<p>由于强制安装并不会将之前的版本卸载了，如下所示我们能看到两个版本的软件包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># rpm -qa | grep openssl</div><div class="line">openssl-libs-1.0.2k-8.el7.x86_64</div><div class="line">openssl-libs-1.0.1e-60.el7.x86_64</div><div class="line">openssl-1.0.2k-8.el7.x86_64</div><div class="line">openssl-1.0.1e-60.el7.x86_64</div></pre></td></tr></table></figure>
<p>执行yum check命令会有如下错误提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># yum check</div><div class="line">已加载插件：fastestmirror</div><div class="line">audit-2.7.6-3.el7.x86_64 是 audit-2.6.5-3.el7.x86_64 的副本</div><div class="line">audit-libs-2.7.6-3.el7.x86_64 是 audit-libs-2.6.5-3.el7.x86_64 的副本</div><div class="line">libsemanage-2.5-8.el7.x86_64 是 libsemanage-2.5-4.el7.x86_64 的副本</div><div class="line">1:openssl-1.0.2k-8.el7.x86_64 是 1:openssl-1.0.1e-60.el7.x86_64 的副本</div><div class="line">1:openssl-libs-1.0.2k-8.el7.x86_64 是 1:openssl-libs-1.0.1e-60.el7.x86_64 的副本</div><div class="line">policycoreutils-2.5-17.1.el7.x86_64 是 policycoreutils-2.5-8.el7.x86_64 的副本</div></pre></td></tr></table></figure>
<p>所以我们需要执行以下命令清除重复的软件包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">package-cleanup --cleandupes</div></pre></td></tr></table></figure>
<p>清除完后软件包就可以正常运行了。</p>
<p>本篇工作记录，持续更新……</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rpm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[openstack——云硬盘的备份与恢复]]></title>
      <url>http://www.pisces.ml/2017/09/22/openstack%E2%80%94%E2%80%94%E4%BA%91%E7%A1%AC%E7%9B%98%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
      <content type="html"><![CDATA[<p>本文会讲述如何进行跨平台云硬盘的备份与恢复，cinder提供的backup功能目前支持多种后端driver备份，比如：nfs、swift、ceph、tsm等等，可见目前常见的存储后端都是支持的。cinder在很早就已经支持备份，主要有以下优势：</p>
<ol>
<li>重要数据及时备份</li>
<li>异地容灾备份（基于cinder备份功能独立的后端driver实现）</li>
<li>openstack集群升级与迁移（冷迁移）</li>
</ol>
<p>下文增对openstack集群迁移来讲解，使用cinder backup来实现数据跨集群备份与恢复。</p>
<h1 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h1><p>以下主要概括备份与恢复大概思路。</p>
<p>在openstack集群A中做如下操作：</p>
<ol>
<li>配置cinder的backup使用ceph作为后端driver</li>
<li>创建云盘备份</li>
<li>导出云盘备份的metadata</li>
</ol>
<p>在openstack集群B中做如下操作：</p>
<ol>
<li>配置cinder的backup使用ceph作为后端driver</li>
<li>导入云盘的metadata信息</li>
<li>创建新的云硬盘，大小与原云盘一致</li>
<li>将备份从ceph存储中恢复到新建的云硬盘中</li>
</ol>
<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><p>前期准备：</p>
<ul>
<li>[x] openstack集群两套（也可一套仅仅做云盘备份用）</li>
<li>[x] 一套ceph集群专门用作云盘备份</li>
</ul>
<h2 id="创建云盘备份"><a href="#创建云盘备份" class="headerlink" title="创建云盘备份"></a>创建云盘备份</h2><p>首先将ceph集群中的配置文件以及认证文件拷贝到cinder所在节点的/etc/ceph目录下并重命名（防止与原来的ceph配置重叠）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scp /etc/ceph/ceph.conf root@cinder_host_addr:/etc/ceph/ceph-backup.conf</div><div class="line">scp /etc/ceph/ceph.client.admin.keyring root@cinder_host_addr:/etc/ceph/ceph.client.cinder-backup.keyring</div></pre></td></tr></table></figure>
<p>在两套集群中cinder所在节点修改ceph-backup.conf文件，在【global】分组中添加如下配置（<strong>important</strong>）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keyring = /etc/ceph/ceph.client.cinder-backup.keyring</div></pre></td></tr></table></figure>
<p>在两套集群中配置cinder的backup后端driver，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">backup_driver=cinder.backup.drivers.ceph</div><div class="line">backup_ceph_conf=/etc/ceph/ceph-backup.conf</div><div class="line">backup_ceph_user=admin</div><div class="line">backup_ceph_chunk_size=<span class="number">134217728</span></div><div class="line">backup_ceph_pool=sata<span class="number">-00</span> <span class="comment"># 存储pool根据实际ceph中规划的pool填写</span></div></pre></td></tr></table></figure>
<p>重启cinder-backup服务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart openstack-cinder-backup</div></pre></td></tr></table></figure>
<p>在集群A中创建volume备份：</p>
<blockquote>
<p>注意备份云盘前需将云盘从云主机中解绑才行</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cinder backup-create <span class="number">0</span>c7006e8<span class="number">-4</span>c01<span class="number">-4</span>bdb-b4b2<span class="number">-6</span>be5336263d0 <span class="comment"># volume ID</span></div></pre></td></tr></table></figure>
<p>等待几秒查看备份是否成功，状态为available即表示创建成功：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[root@controller ~]<span class="comment"># cinder backup-show 46fc9fc6-d783-4dd3-8096-839e21c49c68</span></div><div class="line">+-----------------------+--------------------------------------+</div><div class="line">|        Property       |                Value                 |</div><div class="line">+-----------------------+--------------------------------------+</div><div class="line">|   availability_zone   |                 nova                 |</div><div class="line">|       container       |               sata<span class="number">-00</span>                |</div><div class="line">|       created_at      |      <span class="number">2017</span><span class="number">-09</span><span class="number">-23</span>T06:<span class="number">22</span>:<span class="number">21.000000</span>      |</div><div class="line">|      description      |                 <span class="keyword">None</span>                 |</div><div class="line">|      fail_reason      |                 <span class="keyword">None</span>                 |</div><div class="line">| has_dependent_backups |                <span class="keyword">False</span>                 |</div><div class="line">|           id          | <span class="number">46</span>fc9fc6-d783<span class="number">-4</span>dd3<span class="number">-8096</span><span class="number">-839e21</span>c49c68 |</div><div class="line">|     is_incremental    |                <span class="keyword">False</span>                 |</div><div class="line">|          name         |                 <span class="keyword">None</span>                 |</div><div class="line">|      object_count     |                  <span class="number">0</span>                   |</div><div class="line">|          size         |                  <span class="number">10</span>                  |</div><div class="line">|         status        |              available               |</div><div class="line">|       volume_id       | <span class="number">0</span>c7006e8<span class="number">-4</span>c01<span class="number">-4</span>bdb-b4b2<span class="number">-6</span>be5336263d0 |</div><div class="line">+-----------------------+--------------------------------------+</div></pre></td></tr></table></figure>
<p>查看ceph集群中是否已经有该云盘备份：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@server<span class="number">-17</span> ~]<span class="comment"># rbd -p sata-00 ls | grep 0c7006e8-4c01-4bdb-b4b2-6be5336263d0</span></div><div class="line">volume<span class="number">-0</span>c7006e8<span class="number">-4</span>c01<span class="number">-4</span>bdb-b4b2<span class="number">-6</span>be5336263d0.backup.base</div></pre></td></tr></table></figure>
<p>至此云盘备份已经完成。</p>
<h2 id="导出云盘backup的metadata"><a href="#导出云盘backup的metadata" class="headerlink" title="导出云盘backup的metadata"></a>导出云盘backup的metadata</h2><blockquote>
<p>目前openstackclient命令暂不支持backup-export命令，社区已经有提出并提交了代码来支持:<a href="https://review.openstack.org/#/c/497167/" target="_blank" rel="external">https://review.openstack.org/#/c/497167/</a></p>
</blockquote>
<p>下面我们需要将集群A中的云盘本分的metadata信息导出，执行如下命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">[root@controller ~]<span class="comment"># cinder backup-export 46fc9fc6-d783-4dd3-8096-839e21c49c68</span></div><div class="line">+----------------+------------------------------------------------------------------------------+</div><div class="line">|    Property    |                                    Value                                     |</div><div class="line">+----------------+------------------------------------------------------------------------------+</div><div class="line">| backup_service |                          cinder.backup.drivers.ceph                          |</div><div class="line">|   backup_url   | eyJzdGF0dXMiOiAiYXZhaWxhYmxlIiwgImRpc3BsYXlfbmFtZSI6IG51bGwsICJhdmFpbGFiaWxp |</div><div class="line">|                | dHlfem9uZSI6ICJub3ZhIiwgImRlbGV0ZWQiOiBmYWxzZSwgInVwZGF0ZWRfYXQiOiAiMjAxNy0w |</div><div class="line">|                | OS0yM1QwNjoyMjozOFoiLCAiaG9zdCI6ICJjaW5kZXIiLCAidm9sdW1lX2lkIjogIjBjNzAwNmU4 |</div><div class="line">|                | LTRjMDEtNGJkYi1iNGIyLTZiZTUzMzYyNjNkMCIsICJjb250YWluZXIiOiAic2F0YS0wMCIsICJz |</div><div class="line">|                | ZXJ2aWNlX21ldGFkYXRhIjogbnVsbCwgImlkIjogIjQ2ZmM5ZmM2LWQ3ODMtNGRkMy04MDk2LTgz |</div><div class="line">|                | OWUyMWM0OWM2OCIsICJzaXplIjogMTAsICJvYmplY3RfY291bnQiOiAwLCAicHJvamVjdF9pZCI6 |</div><div class="line">|                | ICI2NWZlNzg2NTY3YTM0MTgyOWFhMDU3NTFiMmI3MzYwZiIsICJkZWxldGVkX2F0IjogbnVsbCwg |</div><div class="line">|                | InVzZXJfaWQiOiAib3BlbnN0YWNrX2FkbWluIiwgInNlcnZpY2UiOiAiY2luZGVyLmJhY2t1cC5k |</div><div class="line">|                | cml2ZXJzLmNlcGgiLCAiZHJpdmVyX2luZm8iOiB7fSwgImNyZWF0ZWRfYXQiOiAiMjAxNy0wOS0y |</div><div class="line">|                | M1QwNjoyMjoyMVoiLCAiZGlzcGxheV9kZXNjcmlwdGlvbiI6IG51bGwsICJwYXJlbnRfaWQiOiBu |</div><div class="line">|                | dWxsLCAibnVtX2RlcGVuZGVudF9iYWNrdXBzIjogMCwgImZhaWxfcmVhc29uIjogbnVsbCwgInRl |</div><div class="line">|                |       bXBfc25hcHNob3RfaWQiOiBudWxsLCAidGVtcF92b2x1bWVfaWQiOiBudWxsfQ==       |</div><div class="line">|                |                                                                              |</div><div class="line">+----------------+------------------------------------------------------------------------------+</div></pre></td></tr></table></figure>
<p>其中backup_url就是我们所需要的metadata信息，这一串东西就是metadata经过base64过后的字符，我们用base64进行解码后就能得到如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;status&quot;: &quot;available&quot;, &quot;display_name&quot;: null, &quot;availability_zone&quot;: &quot;nova&quot;, &quot;deleted&quot;: false, &quot;updated_at&quot;: &quot;2017-09-23T06:22:38Z&quot;, &quot;host&quot;: &quot;cinder&quot;, &quot;volume_id&quot;: &quot;0c7006e8-4c01-4bdb-b4b2-6be5336263d0&quot;, &quot;container&quot;: &quot;sata-00&quot;, &quot;service_metadata&quot;: null, &quot;id&quot;: &quot;46fc9fc6-d783-4dd3-8096-839e21c49c68&quot;, &quot;size&quot;: 10, &quot;object_count&quot;: 0, &quot;project_id&quot;: &quot;65fe786567a341829aa05751b2b7360f&quot;, &quot;deleted_at&quot;: null, &quot;user_id&quot;: &quot;75fc9fc6-d783-4dd3-8096-839e21c49c68&quot;, &quot;service&quot;: &quot;cinder.backup.drivers.ceph&quot;, &quot;driver_info&quot;: &#123;&#125;, &quot;created_at&quot;: &quot;2017-09-23T06:22:21Z&quot;, &quot;display_description&quot;: null, &quot;parent_id&quot;: null, &quot;num_dependent_backups&quot;: 0, &quot;fail_reason&quot;: null, &quot;temp_snapshot_id&quot;: null, &quot;temp_volume_id&quot;: null&#125;</div></pre></td></tr></table></figure>
<p>可以用如下命令得到backup_url:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[root@controller ~]<span class="comment"># cinder backup-export 46fc9fc6-d783-4dd3-8096-839e21c49c68 |  sed -n '/backup_url/,$ s/|.*|  *\(.*\) |/\1/p'</span></div><div class="line">eyJzdGF0dXMiOiAiYXZhaWxhYmxlIiwgImRpc3BsYXlfbmFtZSI6IG51bGwsICJhdmFpbGFiaWxp</div><div class="line">dHlfem9uZSI6ICJub3ZhIiwgImRlbGV0ZWQiOiBmYWxzZSwgInVwZGF0ZWRfYXQiOiAiMjAxNy0w</div><div class="line">OS0yM1QwNjoyMjozOFoiLCAiaG9zdCI6ICJjaW5kZXIiLCAidm9sdW1lX2lkIjogIjBjNzAwNmU4</div><div class="line">LTRjMDEtNGJkYi1iNGIyLTZiZTUzMzYyNjNkMCIsICJjb250YWluZXIiOiAic2F0YS0wMCIsICJz</div><div class="line">ZXJ2aWNlX21ldGFkYXRhIjogbnVsbCwgImlkIjogIjQ2ZmM5ZmM2LWQ3ODMtNGRkMy04MDk2LTgz</div><div class="line">OWUyMWM0OWM2OCIsICJzaXplIjogMTAsICJvYmplY3RfY291bnQiOiAwLCAicHJvamVjdF9pZCI6</div><div class="line">ICI2NWZlNzg2NTY3YTM0MTgyOWFhMDU3NTFiMmI3MzYwZiIsICJkZWxldGVkX2F0IjogbnVsbCwg</div><div class="line">InVzZXJfaWQiOiAib3BlbnN0YWNrX2FkbWluIiwgInNlcnZpY2UiOiAiY2luZGVyLmJhY2t1cC5k</div><div class="line">cml2ZXJzLmNlcGgiLCAiZHJpdmVyX2luZm8iOiB7fSwgImNyZWF0ZWRfYXQiOiAiMjAxNy0wOS0y</div><div class="line">M1QwNjoyMjoyMVoiLCAiZGlzcGxheV9kZXNjcmlwdGlvbiI6IG51bGwsICJwYXJlbnRfaWQiOiBu</div><div class="line">dWxsLCAibnVtX2RlcGVuZGVudF9iYWNrdXBzIjogMCwgImZhaWxfcmVhc29uIjogbnVsbCwgInRl</div><div class="line">bXBfc25hcHNob3RfaWQiOiBudWxsLCAidGVtcF92b2x1bWVfaWQiOiBudWxsfQ==</div></pre></td></tr></table></figure>
<h2 id="导入云盘backup的metadata"><a href="#导入云盘backup的metadata" class="headerlink" title="导入云盘backup的metadata"></a>导入云盘backup的metadata</h2><p>根据上面步骤得到的backup_url，我将将其写到metadata.txt文件中，然后再集群B中导入该metadata信息，操作步骤如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cinder backup-import cinder.backup.drivers.ceph $(tr -d &apos;\n&apos; &lt; metadata.txt)</div><div class="line">+----------+--------------------------------------+</div><div class="line">| Property |                Value                 |</div><div class="line">+----------+--------------------------------------+</div><div class="line">|    id    | b238d4b5-e757-4d8f-5623-3d982e5616dc |</div><div class="line">|   name   |                 None                 |</div><div class="line">+----------+--------------------------------------+</div></pre></td></tr></table></figure>
<p>导入成功后我们能用cinder backup-list看到新导入的metadata信息。</p>
<h2 id="创建新的云硬盘"><a href="#创建新的云硬盘" class="headerlink" title="创建新的云硬盘"></a>创建新的云硬盘</h2><p>在集群B中创建一个新的云硬盘，磁盘大小跟原来的一样，执行如下命令创建：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">[root@controller ~]<span class="comment"># cinder create --display_name backup_recover 10</span></div><div class="line">+---------------------------------------+--------------------------------------+</div><div class="line">|                Property               |                Value                 |</div><div class="line">+---------------------------------------+--------------------------------------+</div><div class="line">|              attachments              |                  []                  |</div><div class="line">|           availability_zone           |                 nova                 |</div><div class="line">|                bootable               |                false                 |</div><div class="line">|          consistencygroup_id          |                 <span class="keyword">None</span>                 |</div><div class="line">|               created_at              |      <span class="number">2017</span><span class="number">-09</span><span class="number">-23</span>T06:<span class="number">53</span>:<span class="number">13.000000</span>      |</div><div class="line">|              description              |                 <span class="keyword">None</span>                 |</div><div class="line">|               encrypted               |                <span class="keyword">False</span>                 |</div><div class="line">|                   id                  | d0431cee<span class="number">-3</span>de2<span class="number">-458</span>f-a70d<span class="number">-95935</span>d7ffd9f |</div><div class="line">|                metadata               |                  &#123;&#125;                  |</div><div class="line">|            migration_status           |                 <span class="keyword">None</span>                 |</div><div class="line">|              multiattach              |                <span class="keyword">False</span>                 |</div><div class="line">|                  name                 |            backup_recover            |</div><div class="line">|         os-vol-host-attr:host         |         cinder@ssd-ceph<span class="comment">#ssd          |</span></div><div class="line">|     os-vol-mig-status-attr:migstat    |                 <span class="keyword">None</span>                 |</div><div class="line">|     os-vol-mig-status-attr:name_id    |                 <span class="keyword">None</span>                 |</div><div class="line">|      os-vol-tenant-attr:tenant_id     |   <span class="number">65</span>fe786567a341829aa05751b2b7360f   |</div></pre></td></tr></table></figure>
<h2 id="云盘恢复"><a href="#云盘恢复" class="headerlink" title="云盘恢复"></a>云盘恢复</h2><p>现在需要将原来的云盘的备份恢复到新建的云硬盘中，我们需要在集群B的cinder节点执行如下恢复操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@controller ~]# cinder backup-restore --volume d0431cee-3de2-458f-a70d-95935d7ffd9f b238d4b5-e757-4d8f-5623-3d982e5616dc</div><div class="line">+-------------+--------------------------------------+</div><div class="line">|   Property  |                Value                 |</div><div class="line">+-------------+--------------------------------------+</div><div class="line">|  backup_id  | b238d4b5-e757-4d8f-5623-3d982e5616dc |</div><div class="line">|  volume_id  | d0431cee-3de2-458f-a70d-95935d7ffd9f |</div><div class="line">| volume_name |            backup_recover            |</div><div class="line">+-------------+--------------------------------------+</div></pre></td></tr></table></figure>
<p>恢复成功后backup的状态会从restoring变为available，到此表示恢复完成，我们需要做的就是将恢复完成的云盘挂载到云主机中，来查看数据是否已经恢复。THE END。。。。。</p>
]]></content>
      
        <categories>
            
            <category> Openstack </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cinder </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac OS X 下文件名乱码问题解决]]></title>
      <url>http://www.pisces.ml/2017/09/15/Mac-OS-X-%E4%B8%8B%E6%96%87%E4%BB%B6%E5%90%8D%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      <content type="html"><![CDATA[<p>​    在 GB2312 等编码环境下的 zip 格式压缩包在 Mac OS X 环境下解压，或者从各种奇怪编码格式的 ftp 下载文件，以及从各种生产环境竟然不是utf-8的古代论坛下载到附件之类的事情之后，文件名很可能会变成乱码。这些乱码是由于 GB2312 编码（或者其它编码）下的文字的binary形式被错误地使用 utf-8 方式解码产生的。</p>
<p>​    mac系统默认用归档实用工具打开zip格式压缩包mac，系统自带的归档实用工具只能用utf-8的方式解码，且不能配置解码格式，所以当我们用归档实用工具打开的zip压缩文件会显示错误编码格式（此处只想吐槽）</p>
<p>​    既然mac系统自带的解压工具仅支持utf-8编码格式，我们就不得不使用其他工具代替，去商店搜索解压软件，只有一款解压软件是免费的——Rar解压王，下载使用之后果然应验了那句话天下没有免费的午餐，没有用，没有用，没有用！！！重要的事情说三遍，，，没用还带广告真是无力吐槽……</p>
<p>​    难道真的没有免费的面包吃么？深深被开源思想灌溉的我不信（咋不说口袋空空呢⊙﹏⊙），这怎么可能（毕竟这么实用的功能），Google了一番，终于找到一个免费开源的解压软件（最重要还没有广告哦）：<a href="https://theunarchiver.com/" target="_blank" rel="external">unarchiver</a> 该解压软件支持多种压缩格式，类似于window中的rar解压软件一样，并且能够自动识别文件编码，并用正确编码格式进行解码。perfect！perfect！perfect！完美解决。喝杯咖啡压压惊</p>
<p>  end</p>
]]></content>
      
        <categories>
            
            <category> Mac </category>
            
        </categories>
        
        
        <tags>
            
            <tag> code </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac命令行终端下使用shadowsocks翻墙（转）]]></title>
      <url>http://www.pisces.ml/2017/08/22/Mac%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%88%E7%AB%AF%E4%B8%8B%E4%BD%BF%E7%94%A8shadowsocks%E7%BF%BB%E5%A2%99/</url>
      <content type="html"><![CDATA[<p>原文转自：<a href="http://www.cashqian.net/blog/001486989831982332565298e4942a2bb8f56b08f9d2475000" target="_blank" rel="external">http://www.cashqian.net/blog/001486989831982332565298e4942a2bb8f56b08f9d2475000</a> 仅供学习使用</p>
<p>配置好shadowsocks服务器端后，安装对应系统的客户端，浏览器安装相应插件就可以翻墙上网了，这都很简单。</p>
<p>问题是对于经常在命令行终端下工作的码农们，SS无法正常工作。因为在终端下不支持socks5代理，只支持http代理，这就很尴尬了。wget、curl、git、brew等命令行工具都会变得很慢。</p>
<p>Linux系统就简单一些，安装proxychains-NG等软件就可以解决了，但是在Mac下有点麻烦。OS X 10.11之前的系统海好说，都还比较顺利，但是OS X 10.11之后较新的系统默认设置下不会安装成功。</p>
<p>因为苹果在新系统中加入了SIP安全机制，他会阻止第三方程序向系统目录内（/System，/bin，/sbin，/usr(除了/usr/local)）进行写操作，sudo也不行。办法是先把SIP关了，等装好软件配置好后再打开SIP。或者改用其他软件。</p>
<p>我懒得去把SIP关了开开了关了，找了另外一个软件privoxy，它刚好就是安装在/usr/local内，不需要关闭SIP也可以正常使用。</p>
<h3 id="privoxy安装"><a href="#privoxy安装" class="headerlink" title="privoxy安装"></a>privoxy安装</h3><p>安装很简单用brew安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install privoxy</div></pre></td></tr></table></figure>
<h3 id="privoxy配置"><a href="#privoxy配置" class="headerlink" title="privoxy配置"></a>privoxy配置</h3><p>打开配置文件 <code>/usr/local/etc/privoxy/config</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /usr/local/etc/privoxy/config</div></pre></td></tr></table></figure>
<p>加入下面这两项配置项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">listen-address 0.0.0.0:8118</div><div class="line">forward-socks5 / localhost:1080 .</div></pre></td></tr></table></figure>
<p>第一行设置privoxy监听任意IP地址的8118端口。第二行设置本地socks5代理客户端端口，注意不要忘了最后有一个空格和点号。</p>
<h3 id="启动privoxy"><a href="#启动privoxy" class="headerlink" title="启动privoxy"></a>启动privoxy</h3><p>因为没有安装在系统目录内，所以启动的时候需要打全路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /usr/local/sbin/privoxy /usr/local/etc/privoxy/config</div></pre></td></tr></table></figure>
<h3 id="查看是否启动成功"><a href="#查看是否启动成功" class="headerlink" title="查看是否启动成功"></a>查看是否启动成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -na | grep 8118</div></pre></td></tr></table></figure>
<p>看到有类似如下信息就表示启动成功了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcp4       0      0  *.8118                 *.*                    LISTEN</div></pre></td></tr></table></figure>
<p>如果没有，可以查看日志信息，判断哪里出了问题。打开配置文件找到 <code>logdir</code> 配置项，查看log文件。</p>
<h3 id="privoxy使用"><a href="#privoxy使用" class="headerlink" title="privoxy使用"></a>privoxy使用</h3><p>在命令行终端中输入如下命令后，该终端即可翻墙了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export http_proxy=&apos;http://localhost:8118&apos;</div><div class="line">export https_proxy=&apos;http://localhost:8118&apos;</div></pre></td></tr></table></figure>
<p>他的原理是讲socks5代理转化成http代理给命令行终端使用。</p>
<p>如果不想用了取消即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unset http_proxy</div><div class="line">unset https_proxy</div></pre></td></tr></table></figure>
<p>如果关闭终端窗口，功能就会失效，如果需要代理一直生效，则可以把上述两行代码添加到 ~/.bash_profile 文件最后。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vim ~/.bash_profile</div><div class="line">-----------------------------------------------------</div><div class="line">export http_proxy=&apos;http://localhost:8118&apos;</div><div class="line">export https_proxy=&apos;http://localhost:8118&apos;</div><div class="line">-----------------------------------------------------</div></pre></td></tr></table></figure>
<p>使配置立即生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source  ~/.bash_profile</div></pre></td></tr></table></figure>
<p>还可以在 <code>~/.bash_profile</code> 里加入开关函数，使用起来更方便</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function proxy_off()&#123;</div><div class="line">    unset http_proxy</div><div class="line">    unset https_proxy</div><div class="line">    echo -e &quot;已关闭代理&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function proxy_on() &#123;</div><div class="line">    export no_proxy=&quot;localhost,127.0.0.1,localaddress,.localdomain.com&quot;</div><div class="line">    export http_proxy=&quot;http://127.0.0.1:8118&quot;</div><div class="line">    export https_proxy=$http_proxy</div><div class="line">    echo -e &quot;已开启代理&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="更多设置"><a href="#更多设置" class="headerlink" title="更多设置"></a>更多设置</h3><p>privoxy更多设置项可以参考这篇文章：</p>
<blockquote>
<p><a href="http://blog.devtang.com/2012/12/08/use-privoxy/" target="_blank" rel="external">使用Privoxy做智能代理切换</a></p>
</blockquote>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><blockquote>
<p>1、<a href="http://ian.wang/270.htm" target="_blank" rel="external">http://ian.wang/270.htm</a></p>
<p>2、<a href="http://www.yinqisen.cn/blog-707.html" target="_blank" rel="external">http://www.yinqisen.cn/blog-707.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Mac </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shadowsocks </tag>
            
            <tag> privoxy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux系统奇怪的磁盘占用解决记录(转载)]]></title>
      <url>http://www.pisces.ml/2017/08/02/Linux%E7%B3%BB%E7%BB%9F%E5%A5%87%E6%80%AA%E7%9A%84%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95-%E8%BD%AC%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p>原文转自：<a href="http://davidaq.com/technique/2015/07/18/linux-weird-disk-usage.html" target="_blank" rel="external">http://davidaq.com/technique/2015/07/18/linux-weird-disk-usage.html</a></p>
<p>近日我所维护的一台服务器运行出现了异常，翻开程序运行日志，初步发现问题是某个过程无法创建新临时文件。 再仔细阅读日志，看到了Java报出的<code>Java.io.IOException; there is not enough space on the disk</code>。</p>
<p>那么问题就很明显了，磁盘占满了。但是这事本身就让我很费解，因为这个服务器上所跑的程序不会长期存储文件， 只是一个数据加工服务器，把传入的文件进行一定的处理然后再回传，期间会产生一些临时文件，但都会在处理 过程结束后自动删除掉。我第一想到的就是，会不会是这个自动删除的功能没做好，导致临时文件堆积如山， 但是经过检查，包括系统其他程序在内所产生的临时文件不到1G，根本不足以占满系统。</p>
<p>我运行<code>df</code>命令查看磁盘的占用情况，看到了4个磁盘挂载点，发现是挂载在<code>/</code>上的磁盘总共50GB被占满了。 于是我在根目录运行<code>du -h -x --max-depth=1</code>想看看是哪个目录占用的这么多空间，我好判断到底出什么问题了， 这个命令中的<code>-x</code>参数会让<code>du</code>命令不统计不在同一个磁盘分区上目录，或换句话说，忽略其他的磁盘挂载点。 结果令人崩溃，根本不用看哪个目录有问题，整个根目录总共统计，磁盘只占用了5.5GB。 那么50GB的磁盘被占满了，但是实际统计磁盘上的文件，总共却只有5.5GB大小，那么剩余的44.5GB被什么鬼用掉了？</p>
<p>我只好进行我的Google功课，然后认识到了几点非常重要的Linux特性。这个特性我以前也知道，却没有重视。 就是在Linux的文件系统中删除一个文件，系统并不会真的立刻把这个文件丢弃掉，而只是把它从文件的目录系统中移除， 只有确保所有使用这个文件的程序全部都退出后，才会真的把文件彻底删除掉。所以这些幽灵文件还会占用磁盘空间， 不过这些幽灵文件并不会出现在<code>df</code>命令的统计中去，因为它们已经不存在于任何目录当中了。</p>
<p>文件系统作为Linux最核心的部件，工具也是最齐全的。<code>lsof</code>此时就可以针对此问题进行检查了，这个命令是用来 列出整个系统中所有被打开的文件（顺便还可以查看所有已经启动的硬件设备以及打开的网络连接等）。 已经从目录系统中移除，但任然被程序占用的的文件可以用<code>lsof | grep &#39;(deleted)&#39;</code>来查看。 经此我立刻就发现了我的问题在哪里了：有一个已经被“删除”掉的日志文件，因为并没有关闭或重启程序， 该文件还在一直被使用着，还在忠实地记录着程序的运行状态。该程序已经持续运行半年了，而且日志文件一直都是 以同一个文件打开描述进行操作（日志文件只在程序开始时打开过一次，后面一直用这个打开的文件）， 这个日志文件已经涨到40多GB了。</p>
<p>找到问题后，解决就简单了，我重启了那个程序，立刻40多G的占用空间就归还给了系统，所有程序都运行正常了。 当然这只是权宜之计，解决眼前问题采取的快速措施。要根除此问题就要用更科学的方式记录日志，使用已经成熟的 日志系统是个比较正确的选择。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> disk </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何避免ssh未知节点主机认证？]]></title>
      <url>http://www.pisces.ml/2017/07/27/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8Dssh%E6%9C%AA%E7%9F%A5%E8%8A%82%E7%82%B9%E4%B8%BB%E6%9C%BA%E8%AE%A4%E8%AF%81%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>通常情况下，ssh连接到新的节点会显示如下确认信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The authenticity of host &apos;111.222.333.444 (111.222.333.444)&apos; can&apos;t be established.</div><div class="line">RSA key fingerprint is f3:cf:58:ae:71:0b:c8:04:6f:34:a3:b2:e4:1e:0c:8b.</div><div class="line">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure>
<p>对于单一节点确认下即可，但是如果同时处理多个节点的话就比较蛋疼了。所以我们进行ssh连接时需要跳过验证，ssh命令也考虑到了这个问题，只需带上相应的可选参数即可，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -o &quot;StrictHostKeyChecking no&quot; user@host</div></pre></td></tr></table></figure>
<p>对于scp多主机拷贝文件也只需加这个参数即可，示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp -o &quot;StrictHostKeyChecking no&quot; user@host:/home/text.txt .</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈redis]]></title>
      <url>http://www.pisces.ml/2017/07/25/%E6%B5%85%E8%B0%88redis/</url>
      <content type="html"><![CDATA[<p>​    最近工作用到了redis做数据缓存，于是乎花了点时间研究了下redis。各种语言对redis都有相应的支持，我们可以在官网上看到：<a href="https://redis.io/clients，足以见的redis的广泛适用性。" target="_blank" rel="external">https://redis.io/clients，足以见的redis的广泛适用性。</a></p>
<p>​    针对python的client，看了下redis-py用的人比较多，果断用redis-py做应用开发（这可不是从众心理哦）。简单的看了下，client已经将redis接口封装了一次，仅仅提供了简单易用的接口，对于使用者无需关心底层调用，只需关心接口使用即可。</p>
<h1 id="redis-py基本使用"><a href="#redis-py基本使用" class="headerlink" title="redis-py基本使用"></a>redis-py基本使用</h1><p>接下来我们先介绍下redis-py简单的应用，主要参考<a href="https://github.com/andymccurdy/redis-py" target="_blank" rel="external">官方文档</a>资料。有兴趣可以看看源码，更有助于理解。</p>
<p>redis-py使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> redis</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = redis.StrictRedis(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.set(<span class="string">'foo'</span>, <span class="string">'bar'</span>)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.get(<span class="string">'foo'</span>)</div><div class="line"><span class="string">'bar'</span></div></pre></td></tr></table></figure>
<h2 id="redis连接池"><a href="#redis连接池" class="headerlink" title="redis连接池"></a>redis连接池</h2><p>通常情况下, 当我们需要做redis操作时, 会创建一个连接, 并基于这个连接进行redis操作，操作完成后, 释放连接，一般情况下, 这是没问题的, 但当并发量比较高的时候, 频繁的连接创建和释放对性能会有较高的影响。于是, 连接池就发挥作用了。连接池的原理是, 通过预先创建多个连接, 当进行redis操作时, 直接获取已经创建的连接进行操作, 而且操作完成后, 不会释放, 用于后续的其他redis操作这样就达到了避免频繁的redis连接创建和释放的目的, 从而提高性能。</p>
<p>redis-py建立连接池：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>pool = redis.ConnectionPool(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = redis.Redis(connection_pool=pool)</div></pre></td></tr></table></figure>
<h2 id="redis事务处理"><a href="#redis事务处理" class="headerlink" title="redis事务处理"></a>redis事务处理</h2><p>redis-py通过Pipelines实现类似数据库的事务处理功能，如下所示表示简单的redis事务操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = redis.Redis(...)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.set(<span class="string">'bing'</span>, <span class="string">'baz'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Use the pipeline() method to create a pipeline instance</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pipe = r.pipeline()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># The following SET commands are buffered</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pipe.set(<span class="string">'foo'</span>, <span class="string">'bar'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pipe.get(<span class="string">'bing'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># the EXECUTE call sends all buffered commands to the server, returning</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># a list of responses, one for each command.</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pipe.execute()</div><div class="line">[<span class="keyword">True</span>, <span class="string">'baz'</span>]</div></pre></td></tr></table></figure>
<p>事务处理特点：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>
</ul>
<p>对于redis使用，并不会很复杂，详细看看官方文档即可。</p>
<h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>目前市面上的应用程序为了提高性能一般都是多线程运行，那么redis中对于并发请求是否可能出现异常？</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://www.u3v3.com/ar/1346" target="_blank" rel="external">https://www.u3v3.com/ar/1346</a></p>
<p><a href="http://www.redis.cn/topics/transactions.html" target="_blank" rel="external">http://www.redis.cn/topics/transactions.html</a></p>
]]></content>
      
        <categories>
            
            <category> Cache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何制作rpm安装包]]></title>
      <url>http://www.pisces.ml/2017/06/17/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9Crpm%E5%AE%89%E8%A3%85%E5%8C%85/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>安装部署软件包，大部分我们都是通过rpm来完成。通常情况我们根据源码包，来制作rpm安装包，再将安装包放到yum仓库里。这样安装一个软件我们就可以直接通过yum命令来安装了。</p>
<h1 id="RPM基础知识"><a href="#RPM基础知识" class="headerlink" title="RPM基础知识"></a>RPM基础知识</h1><p>若要构建一个标准的 RPM 包，您需要创建 <strong>.spec</strong> 文件，其中包含软件打包的全部信息。然后，对此文件执行 <strong>rpmbuild</strong> 命令，经过这一步，系统会按照步骤生成最终的 RPM 包。</p>
<p>一般情况，您应该把源代码包，比如由开发者发布的以 <strong>.tar.gz</strong> 结尾的文件，放入 <strong>~/rpmbuild/SOURCES</strong> 目录。将<strong>.spec</strong> 文件放入 <strong>~/rpmbuild/SPECS</strong> 目录，并命名为 “<em>软件包名</em>.spec” 。当然， <em>软件包名</em> 就是最终 RPM 包的名字。为了创建二进制（Binary RPM）和源码软件包（SRPM），您需要将目录切换至 <strong>~/rpmbuild/SPECS</strong> 并执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rpmbuild -ba NAME.spec</div></pre></td></tr></table></figure>
<p>当执行此命令时，<strong>rpmbuild</strong> 会自动读取 <strong>.spec</strong> 文件并按照下表列出的步骤完成构建。下表中，以 <strong>%</strong> 开头的语句为预定义宏，每个宏的作用如下：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>读取的目录</th>
<th>写入的目录</th>
<th>具体动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>%prep</td>
<td>%_sourcedir</td>
<td>%_builddir</td>
<td>读取位于 %_sourcedir 目录的源代码和 patch 。之后，解压源代码至 %_builddir的子目录并应用所有 patch。</td>
</tr>
<tr>
<td>%build</td>
<td>%_builddir</td>
<td>%_builddir</td>
<td>编译位于 %_builddir构建目录下的文件。通过执行类似 “./configure &amp;&amp; make” 的命令实现。</td>
</tr>
<tr>
<td>%install</td>
<td>%_builddir</td>
<td>%_buildrootdir</td>
<td>读取位于 %_builddir构建目录下的文件并将其安装至 %_buildrootdir` 目录。这些文件就是用户安装 RPM 后，最终得到的文件。注意一个奇怪的地方: <em>最终安装目录</em> <strong>不是</strong> <em>构建目录</em>。通过执行类似 “make install” 的命令实现。</td>
</tr>
<tr>
<td>%check</td>
<td>%_builddir</td>
<td>%_builddir</td>
<td>检查软件是否正常运行。通过执行类似 “<code>make test</code>“ 的命令实现。很多软件包都不需要此步。</td>
</tr>
<tr>
<td>bin</td>
<td>%_buildrootdir</td>
<td>%_rpmdir</td>
<td>读取位于 %_buildrootdir 最终安装目录下的文件，以便最终在 %_rpmdir目录下创建 RPM 包。在该目录下，不同架构的 RPM 包会分别保存至不同子目录， “noarch`” 目录保存适用于所有架构的 RPM 包。这些 RPM 文件就是用户最终安装的 RPM 包。</td>
</tr>
<tr>
<td>src</td>
<td>%_sourcedir</td>
<td>%_srcrpmdir</td>
<td>创建源码 RPM 包（简称 SRPM，以.src.rpm 作为后缀名），并保存至 %_srcrpmdir 目录。SRPM 包通常用于审核和升级软件包。</td>
</tr>
</tbody>
</table>
<p>在 <strong>rpmbuild</strong> 中，对上表中的每个宏代码都有对应的目录：</p>
<table>
<thead>
<tr>
<th>宏代码</th>
<th>名称</th>
<th>默认位置</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>%_specdir</td>
<td>Spec 文件目录</td>
<td>~/rpmbuild/SPECS</td>
<td>保存 RPM 包配置（.spec）文件</td>
</tr>
<tr>
<td>%_sourcedir</td>
<td>源代码目录</td>
<td>~/rpmbuild/SOURCES</td>
<td>保存源码包（如 .tar 包）和所有 patch 补丁</td>
</tr>
<tr>
<td>%_builddir</td>
<td>构建目录</td>
<td>~/rpmbuild/BUILD</td>
<td>源码包被解压至此，并在该目录的子目录完成编译</td>
</tr>
<tr>
<td>%_buildrootdir</td>
<td>最终安装目录</td>
<td>~/rpmbuild/BUILDROOT</td>
<td>保存 %install 阶段安装的文件</td>
</tr>
<tr>
<td>%_rpmdir</td>
<td>标准 RPM 包目录</td>
<td>~/rpmbuild/RPMS</td>
<td>生成/保存二进制 RPM 包</td>
</tr>
<tr>
<td>%_srcrpmdir</td>
<td>源代码 RPM 包目录</td>
<td>~/rpmbuild/SRPMS</td>
<td>生成/保存源码 RPM 包(SRPM)</td>
</tr>
</tbody>
</table>
<p>如果某一阶段失败，请查看输出信息以了解失败<em>原因</em>，并根据需要修改 .<strong>spec</strong> 文件。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>制作环境：Centos 7.1</p>
<p>制作工具:  rpmdevtools</p>
<p>首先安装依赖包:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install rpmdevtools</div></pre></td></tr></table></figure>
<h2 id="创建目录结构"><a href="#创建目录结构" class="headerlink" title="创建目录结构"></a>创建目录结构</h2><p>执行 <code>rpmdev-setuptree</code> 将在当前用户主目录下创建一个RPM构建根目录结构，结构如下所示：</p>
<p>（注：如需改变默认位置，可以修改配置文件:<strong>~/.rpmmacros</strong>中变量<strong>_topdir</strong>对应的值。)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">rpmbuild/</div><div class="line">├── BUILD (源码包被解压至此，并在该目录的子目录完成编译)</div><div class="line">├── RPMS (生成/保存二进制 RPM 包)</div><div class="line">├── SOURCES (保存源码包（如 .tar 包）和所有 patch 补丁)</div><div class="line">├── SPECS (保存 RPM 包配置（.spec）文件)</div><div class="line">└── SRPMS (生成/保存源码 RPM 包(SRPM))</div></pre></td></tr></table></figure>
<h2 id="撰写spec文档"><a href="#撰写spec文档" class="headerlink" title="撰写spec文档"></a>撰写spec文档</h2><p>现在，需要在 <strong>~/rpmbuild/SPECS</strong> 目录下，新建一个 SPEC 文件。文件应命名为 “<strong>软件包名.spec</strong>“。名称根据软件包名或通用名填写即可。但是，必须要遵守 <a href="https://fedoraproject.org/wiki/Packaging/NamingGuidelines" target="_blank" rel="external">软件包命名规定</a>。示例，我们在SPECS目录下新建文件<strong>xxxxx.spec</strong>，我们能看到会自动生成如下内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">#软件包的名字</div><div class="line">Name:</div><div class="line">#软件包的主版本号 </div><div class="line">Version:</div><div class="line">#软件包的次版本号，一般我们对该软件包做了一些小的补丁的时候就应该把释出号加1。</div><div class="line">Release:	1%&#123;?dist&#125;</div><div class="line">#软件包简要介绍</div><div class="line">Summary:</div><div class="line"></div><div class="line">#软件分类</div><div class="line">Group:</div><div class="line">#授权协议</div><div class="line">License:</div><div class="line">#源码软件源地址</div><div class="line">URL:</div><div class="line">#源代码包，默认将在上面提到的SOURCES目录中寻找</div><div class="line">Source0:</div><div class="line"></div><div class="line">#构建项目需要的依赖包</div><div class="line">BuildRequires:</div><div class="line">#软件运行依赖包</div><div class="line">Requires:</div><div class="line"></div><div class="line">#软件包的内容介绍 </div><div class="line">%description</div><div class="line"></div><div class="line"></div><div class="line">#这个段是预处理段，通常用来执行一些解开源程序包的命令，为下一步的编译安装作准备。%prep和下面的%build，%install段一样，除了可以执行RPM所定义的宏命令（以%开头）以外，还可以执行SHELL命令，命令可以有很多行，如我们常写的tar解包命令。</div><div class="line">%prep</div><div class="line">#构建BUILD环境，将解压源码压缩包到BUILD目录</div><div class="line">%setup -q</div><div class="line"></div><div class="line"></div><div class="line">#BUILD字段，将通过直接调用源码目录中自动构建工具完成源码编译操作</div><div class="line">%build</div><div class="line">#调用源码目录中的configure命令  </div><div class="line">%configure</div><div class="line">make %&#123;?_smp_mflags&#125;</div><div class="line"></div><div class="line"></div><div class="line">#本段是安装段，其中的命令在安装软件包时将执行，如make install命令。</div><div class="line">%install</div><div class="line">#调用源码中安装执行脚本 </div><div class="line">make install DESTDIR=%&#123;buildroot&#125;</div><div class="line"></div><div class="line"></div><div class="line">#文件说明字段，声明多余或者缺少都将可能出错</div><div class="line">%files</div><div class="line">%doc</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">%changelog</div></pre></td></tr></table></figure>
<h3 id="如何查看spec文件中宏路径（很重要哦）"><a href="#如何查看spec文件中宏路径（很重要哦）" class="headerlink" title="如何查看spec文件中宏路径（很重要哦）"></a>如何查看spec文件中宏路径（很重要哦）</h3><p>我们可以通过命令<code>rpm --showrc</code>查看实现代码。另外直接通过<code>rpm --eval &quot;%{macro}&quot;</code>来查看具体对应路径。比如我们要查看%{_bindir}的路径，就可以使用命令<code>rpm --eval &quot;%{ _bindir}&quot;</code>来查看。另外，所有的宏都可以在/usr/lib/rpm/macros里找到。示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rpm --eval <span class="string">"%&#123;_bindir&#125;"</span></div><div class="line">/usr/bin</div></pre></td></tr></table></figure>
<h2 id="源码打包"><a href="#源码打包" class="headerlink" title="源码打包"></a>源码打包</h2><p>如果是python项目，我们可以通过命令<code>python setup.py sdist</code>进行打包，执行命令完成后会在源码包的dist目录下生成一个<strong>tar.gz</strong>的源码包，我们需要将源码包拷贝到<strong>~/rpmbuild/SOURCES</strong>。不是python项目的话根据相应的打包规则进行打包即可。（注，确保此归档文件解压后的目录为<strong>xxxx-0.0.1</strong>，否则会有问题）</p>
<h2 id="构建RPM包"><a href="#构建RPM包" class="headerlink" title="构建RPM包"></a>构建RPM包</h2><p>构建RPM包很容易，只需要在工作目录（rpmbuild）下执行如下命令构建即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpmbuild -ba SPECS/xxx.spec</div></pre></td></tr></table></figure>
<p>其中<strong>-ba</strong>表示<strong>build all</strong>，即生成包括二进制包和源代码包的所有RPM包，下来如果正常的话，rpmbuild将正常退出，同时在RPMS目录和SRPMS目录中将生成对应的RPM包。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>打包过程其实不麻烦，构建好环境后执行打包命令即可。最重要的是spec文件的编写，spec文件定义了包的安装配置也就是所说的宏的定义。我们需要对打包机制很熟悉才能根据实际需求写出符合要求的spec文件。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://fedoraproject.org/wiki/How_to_create_an_RPM_package/zh-cn#.E5.87.86.E5.A4.87.E7.B3.BB.E7.BB.9F" target="_blank" rel="external">https://fedoraproject.org/wiki/How_to_create_an_RPM_package/zh-cn#.E5.87.86.E5.A4.87.E7.B3.BB.E7.BB.9F</a></p>
<p><a href="https://segmentfault.com/a/1190000002539129" target="_blank" rel="external">https://segmentfault.com/a/1190000002539129</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rpmbuild </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python 时间戳处理]]></title>
      <url>http://www.pisces.ml/2017/06/13/python-%E6%97%B6%E9%97%B4%E6%88%B3%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="python-时间戳处理"><a href="#python-时间戳处理" class="headerlink" title="python 时间戳处理"></a>python 时间戳处理</h1><p><a href="http://funhacks.net/2015/04/29/Unix-timestamp/" target="_blank" rel="external">Unix 时间戳</a>根据精度的不同，有 10 位（秒级），13 位（毫秒级），16 位（微妙级）和 19 位（纳秒级）。在 python 中，我们可以将一个整数的时间戳转换为字符串格式，如 <code>&#39;2016-02-25 20:21:04&#39;</code>，也可以将其转换为 python 中的 <a href="https://docs.python.org/2/library/datetime.html" target="_blank" rel="external">datetime</a> 格式。反之，也可以将整数的时间戳转换为字符串格式和 datetime 格式。用图展示如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">             +------------+</div><div class="line">             | timestamp  |</div><div class="line">       +----&gt;|            |&lt;-----+</div><div class="line">       |     +------------+      |</div><div class="line">       |                         |</div><div class="line">       |                         |</div><div class="line">       |                         |</div><div class="line">       v                         v</div><div class="line">+------------+            +------------+</div><div class="line">|  datetime  |            |   string   |</div><div class="line">|            |&lt;----------&gt;|            |</div><div class="line">+------------+            +------------+</div></pre></td></tr></table></figure>
<p>要注意的是，由于每个时区都有自己的本地时间（北京在东八区），因此也产生了世界标准时间（UTC, Universal Time Coordinated）。所以，在将一个时间戳转换为普通时间（比如 2016-01-01 12:00:00）时，要注意是要本地时区的时间还是世界时间等。</p>
<h1 id="local-time-北京时间"><a href="#local-time-北京时间" class="headerlink" title="local time (北京时间)"></a>local time (北京时间)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">timestamp_to_strtime</span><span class="params">(timestamp)</span>:</span></div><div class="line">    <span class="string">"""将 13 位整数的毫秒时间戳转化成本地普通时间 (字符串格式)</span></div><div class="line">    :param timestamp: 13 位整数的毫秒时间戳 (1456402864242)</div><div class="line">    :return: 返回字符串格式 &#123;str&#125;'2016-02-25 20:21:04.242000'</div><div class="line">    """</div><div class="line">    local_str_time = datetime.fromtimestamp(timestamp / <span class="number">1000.0</span>).strftime(<span class="string">'%Y-%m-%d %H:%M:%S.%f'</span>)</div><div class="line">    <span class="keyword">return</span> local_str_time</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">timestamp_to_datetime</span><span class="params">(timestamp)</span>:</span></div><div class="line">    <span class="string">"""将 13 位整数的毫秒时间戳转化成本地普通时间 (datetime 格式)</span></div><div class="line">    :param timestamp: 13 位整数的毫秒时间戳 (1456402864242)</div><div class="line">    :return: 返回 datetime 格式 &#123;datetime&#125;2016-02-25 20:21:04.242000</div><div class="line">    """</div><div class="line">    local_dt_time = datetime.fromtimestamp(timestamp / <span class="number">1000.0</span>)</div><div class="line">    <span class="keyword">return</span> local_dt_time</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">datetime_to_strtime</span><span class="params">(datetime_obj)</span>:</span></div><div class="line">    <span class="string">"""将 datetime 格式的时间 (含毫秒) 转为字符串格式</span></div><div class="line">    :param datetime_obj: &#123;datetime&#125;2016-02-25 20:21:04.242000</div><div class="line">    :return: &#123;str&#125;'2016-02-25 20:21:04.242'</div><div class="line">    """</div><div class="line">    local_str_time = datetime_obj.strftime(<span class="string">"%Y-%m-%d %H:%M:%S.%f"</span>)</div><div class="line">    <span class="keyword">return</span> local_str_time</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">datetime_to_timestamp</span><span class="params">(datetime_obj)</span>:</span></div><div class="line">    <span class="string">"""将本地(local) datetime 格式的时间 (含毫秒) 转为毫秒时间戳</span></div><div class="line">    :param datetime_obj: &#123;datetime&#125;2016-02-25 20:21:04.242000</div><div class="line">    :return: 13 位的毫秒时间戳  1456402864242</div><div class="line">    """</div><div class="line">    local_timestamp = long(time.mktime(datetime_obj.timetuple()) * <span class="number">1000.0</span> + datetime_obj.microsecond / <span class="number">1000.0</span>)</div><div class="line">    <span class="keyword">return</span> local_timestamp</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">strtime_to_datetime</span><span class="params">(timestr)</span>:</span></div><div class="line">    <span class="string">"""将字符串格式的时间 (含毫秒) 转为 datetiem 格式</span></div><div class="line">    :param timestr: &#123;str&#125;'2016-02-25 20:21:04.242'</div><div class="line">    :return: &#123;datetime&#125;2016-02-25 20:21:04.242000</div><div class="line">    """</div><div class="line">    local_datetime = datetime.strptime(timestr, <span class="string">"%Y-%m-%d %H:%M:%S.%f"</span>)</div><div class="line">    <span class="keyword">return</span> local_datetime</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">strtime_to_timestamp</span><span class="params">(local_timestr)</span>:</span></div><div class="line">    <span class="string">"""将本地时间 (字符串格式，含毫秒) 转为 13 位整数的毫秒时间戳</span></div><div class="line">    :param local_timestr: &#123;str&#125;'2016-02-25 20:21:04.242'</div><div class="line">    :return: 1456402864242</div><div class="line">    """</div><div class="line">    local_datetime = strtime_to_datetime(local_timestr)</div><div class="line">    timestamp = datetime_to_timestamp(local_datetime)</div><div class="line">    <span class="keyword">return</span> timestamp</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">current_datetime</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">"""返回本地当前时间, 包含datetime 格式, 字符串格式, 时间戳格式</span></div><div class="line">    :return: (datetime 格式, 字符串格式, 时间戳格式)</div><div class="line">    """</div><div class="line">    <span class="comment"># 当前时间：datetime 格式</span></div><div class="line">    local_datetime_now = datetime.now()</div><div class="line">    <span class="comment"># 当前时间：字符串格式</span></div><div class="line">    local_strtime_now = datetime_to_strtime(local_datetime_now)</div><div class="line">    <span class="comment"># 当前时间：时间戳格式 13位整数</span></div><div class="line">    local_timestamp_now = datetime_to_timestamp(local_datetime_now)</div><div class="line">    <span class="keyword">return</span> local_datetime_now, local_strtime_now, local_timestamp_now</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    time_str = <span class="string">'2016-02-25 20:21:04.242'</span></div><div class="line">    timestamp1 = strtime_to_timestamp(time_str)</div><div class="line">    datetime1 = strtime_to_datetime(time_str)</div><div class="line">    time_str2 = datetime_to_strtime(datetime1)</div><div class="line">    timestamp2 = datetime_to_timestamp(datetime1)</div><div class="line">    datetime3 = timestamp_to_datetime(timestamp2)</div><div class="line">    time_str3 = timestamp_to_strtime(timestamp2)</div><div class="line">    current_time = current_datetime()</div><div class="line">    <span class="keyword">print</span> <span class="string">'timestamp1: '</span>, timestamp1</div><div class="line">    <span class="keyword">print</span> <span class="string">'datetime1: '</span>, datetime1</div><div class="line">    <span class="keyword">print</span> <span class="string">'time_str2: '</span>, time_str2</div><div class="line">    <span class="keyword">print</span> <span class="string">'timestamp2: '</span>, timestamp2</div><div class="line">    <span class="keyword">print</span> <span class="string">'datetime3: '</span>, datetime3</div><div class="line">    <span class="keyword">print</span> <span class="string">'time_str3: '</span>, time_str3</div><div class="line">    <span class="keyword">print</span> <span class="string">'current_time: '</span>, current_time</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 输出</span></div><div class="line">timestamp1:  <span class="number">1456402864242</span></div><div class="line">datetime1:  <span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">04.242000</span></div><div class="line">time_str2:  <span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">04.242000</span></div><div class="line">timestamp2:  <span class="number">1456402864242</span></div><div class="line">datetime3:  <span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">04.242000</span></div><div class="line">time_str3:  <span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">04.242000</span></div><div class="line">current_time:  (datetime.datetime(<span class="number">2016</span>, <span class="number">3</span>, <span class="number">19</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">901903</span>), <span class="string">'2016-03-19 14:11:04.901903'</span>, <span class="number">1458367864901L</span>)</div></pre></td></tr></table></figure>
<h1 id="utc-time"><a href="#utc-time" class="headerlink" title="utc time"></a>utc time</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> calendar</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">timestamp_to_utc_strtime</span><span class="params">(timestamp)</span>:</span></div><div class="line">    <span class="string">"""将 13 位整数的毫秒时间戳转化成 utc 时间 (字符串格式，含毫秒)</span></div><div class="line">    :param timestamp: 13 位整数的毫秒时间戳 (1456402864242)</div><div class="line">    :return: 返回字符串格式 &#123;str&#125;'2016-02-25 12:21:04.242000'</div><div class="line">    """</div><div class="line">    utc_str_time = datetime.utcfromtimestamp(timestamp / <span class="number">1000.0</span>).strftime(<span class="string">'%Y-%m-%d %H:%M:%S.%f'</span>)</div><div class="line">    <span class="keyword">return</span> utc_str_time</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">timestamp_to_utc_datetime</span><span class="params">(timestamp)</span>:</span></div><div class="line">    <span class="string">"""将 13 位整数的毫秒时间戳转化成 utc 时间 (datetime 格式)</span></div><div class="line">    :param timestamp: 13 位整数的时间戳 (1456402864242)</div><div class="line">    :return: 返回 datetime 格式 &#123;datetime&#125;2016-02-25 12:21:04.242000</div><div class="line">    """</div><div class="line">    utc_dt_time = datetime.utcfromtimestamp(timestamp / <span class="number">1000.0</span>)</div><div class="line">    <span class="keyword">return</span> utc_dt_time</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">utc_datetime_to_timestamp</span><span class="params">(utc_datetime)</span>:</span></div><div class="line">    <span class="string">"""将 utc 时间 (datetime 格式) 转为 utc 时间戳</span></div><div class="line">    :param utc_datetime: &#123;datetime&#125;2016-02-25 20:21:04.242000</div><div class="line">    :return: 13位 的毫秒时间戳 1456431664242</div><div class="line">    """</div><div class="line">    utc_timestamp = long(calendar.timegm(utc_datetime.timetuple()) * <span class="number">1000.0</span> + utc_datetime.microsecond / <span class="number">1000.0</span>)</div><div class="line">    <span class="keyword">return</span> utc_timestamp</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">datetime_to_strtime</span><span class="params">(datetime_obj)</span>:</span></div><div class="line">    <span class="string">"""将 datetime 格式的时间 (含毫秒) 转为字符串格式</span></div><div class="line">    :param datetime_obj: &#123;datetime&#125;2016-02-25 20:21:04.242000</div><div class="line">    :return: &#123;str&#125;'2016-02-25 20:21:04.242'</div><div class="line">    """</div><div class="line">    local_str_time = datetime_obj.strftime(<span class="string">"%Y-%m-%d %H:%M:%S.%f"</span>)</div><div class="line">    <span class="keyword">return</span> local_str_time</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">strtime_to_datetime</span><span class="params">(timestr)</span>:</span></div><div class="line">    <span class="string">"""将字符串格式的时间 (含毫秒) 转为 datetiem 格式</span></div><div class="line">    :param timestr: &#123;str&#125;'2016-02-25 20:21:04.242'</div><div class="line">    :return: &#123;datetime&#125;2016-02-25 20:21:04.242000</div><div class="line">    """</div><div class="line">    local_datetime = datetime.strptime(timestr, <span class="string">"%Y-%m-%d %H:%M:%S.%f"</span>)</div><div class="line">    <span class="keyword">return</span> local_datetime</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">utc_strtime_to_timestamp</span><span class="params">(utc_timestr)</span>:</span></div><div class="line">    <span class="string">"""将 utc 时间 (字符串格式) 转为 13 位的时间戳</span></div><div class="line">    :param utc_timestr: &#123;str&#125;'2016-02-25 20:21:04.242'</div><div class="line">    :return: 1456431664242</div><div class="line">    """</div><div class="line">    <span class="comment"># 先将字符串的格式转为 datetime 格式</span></div><div class="line">    utc_datetime = strtime_to_datetime(utc_timestr)</div><div class="line">    <span class="comment"># 再将 datetime 格式的时间转为时间戳</span></div><div class="line">    timestamp = utc_datetime_to_timestamp(utc_datetime)</div><div class="line">    <span class="keyword">return</span> timestamp</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">utc_current_datetime</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">"""返回 utc 当前时间, datetime 格式, 字符串格式, 时间戳格式</span></div><div class="line">    :return: (datetime 格式, 字符串格式, 时间戳格式)</div><div class="line">    """</div><div class="line">    <span class="comment"># utc 当前时间: datetime 格式</span></div><div class="line">    utc_datetime_now = datetime.utcnow()</div><div class="line">    <span class="comment"># utc 当前时间: 字符串格式</span></div><div class="line">    utc_strtime_now = datetime_to_strtime(utc_datetime_now)</div><div class="line">    <span class="comment"># utc 当前时间: 时间戳格式 13位整数</span></div><div class="line">    utc_timestamp_now = utc_datetime_to_timestamp(utc_datetime_now)</div><div class="line">    <span class="keyword">return</span> utc_datetime_now, utc_strtime_now, utc_timestamp_now</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    time_str = <span class="string">'2016-02-25 20:21:04.242'</span></div><div class="line">    <span class="comment"># 1456431664242</span></div><div class="line">    timestamp1 = utc_strtime_to_timestamp(time_str)</div><div class="line">    datetime1 = strtime_to_datetime(time_str)</div><div class="line">    time_str2 = datetime_to_strtime(datetime1)</div><div class="line">    timestamp2 = utc_datetime_to_timestamp(datetime1)</div><div class="line">    datetime3 = timestamp_to_utc_datetime(timestamp2)</div><div class="line">    time_str3 = timestamp_to_utc_strtime(timestamp2)</div><div class="line">    utc_current_time = utc_current_datetime()</div><div class="line">    <span class="keyword">print</span> <span class="string">'timestamp1: '</span>, timestamp1</div><div class="line">    <span class="keyword">print</span> <span class="string">'datetime1: '</span>, datetime1</div><div class="line">    <span class="keyword">print</span> <span class="string">'time_str2: '</span>, time_str2</div><div class="line">    <span class="keyword">print</span> <span class="string">'timestamp2: '</span>, timestamp2</div><div class="line">    <span class="keyword">print</span> <span class="string">'datetime3: '</span>, datetime3</div><div class="line">    <span class="keyword">print</span> <span class="string">'time_str3: '</span>, time_str3</div><div class="line">    <span class="keyword">print</span> <span class="string">'utc_current_time: '</span>, utc_current_time</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 输出</span></div><div class="line">timestamp1:  <span class="number">1456431664242</span></div><div class="line">datetime1:  <span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">04.242000</span></div><div class="line">time_str2:  <span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">04.242000</span></div><div class="line">timestamp2:  <span class="number">1456431664242</span></div><div class="line">datetime3:  <span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">04.242000</span></div><div class="line">time_str3:  <span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">04.242000</span></div><div class="line">utc_current_time:  (datetime.datetime(<span class="number">2016</span>, <span class="number">3</span>, <span class="number">19</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">217055</span>), <span class="string">'2016-03-19 07:07:02.217055'</span>, <span class="number">1458371222217L</span>)</div></pre></td></tr></table></figure>
<p>本文来自<a href="http://funhacks.net/2016/03/19/python%20%E6%97%B6%E9%97%B4%E6%88%B3%E5%A4%84%E7%90%86/" target="_blank" rel="external">网络</a>，仅供学习使用。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> timestamp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VMware Fusion 设置端口转发]]></title>
      <url>http://www.pisces.ml/2017/04/13/VMware-Fusion-%E8%AE%BE%E7%BD%AE%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>VMware Fusion没有提供图形化的虚拟网络编辑器，当我们选用nat网络类型，我们需要端口转发的功能，那么我们需要如何设置呢？下面我们就介绍下如何在mac系统中设置虚拟机端口转发。</p>
<h1 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h1><p>虽然VMware Fusion没有提供图形化界面来支持端口转发的功能，但是我们可以通过修改网络配置文件来达到该目的。原理很简单我们只需要修改相应的网络配置文件，然后重启网络服务即可。下面我们将介绍具体的操作步骤：</p>
<ol>
<li><p><strong>修改配置文件</strong></p>
<p>VMware Fusion 的 NAT 配置文件位于 <em>/Library/Preferences/VMware Fusion/vmnet8/nat.conf</em> ，打开配置文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vi /Library/Preferences/VMware\ Fusion/vmnet8/nat.conf</div></pre></td></tr></table></figure>
<p>修改<em>[incomingtcp]</em> 部分，添加相应的端口转发即可。如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[incomingtcp]</div><div class="line"></div><div class="line"># Use these with care - anyone can enter into your VM through these...</div><div class="line"># The format and example are as follows:</div><div class="line">#&lt;external port number&gt; = &lt;VM's IP address&gt;:&lt;VM's port number&gt;</div><div class="line">#8080 = 172.16.3.128:80</div><div class="line">8080 = 192.168.125.130:22 (根据需求添加即可)</div><div class="line">8081 = 192.168.125.129:22</div></pre></td></tr></table></figure>
</li>
<li><p><strong>重启虚拟网络服务</strong></p>
<p>两种方式重启虚拟网络：</p>
<ul>
<li><p>重启VMware Fusion</p>
</li>
<li><p>执行以下命令直接重启网络模块</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo /Applications/VMware\ Fusion.app/Contents/Library/vmnet-cli --stop</div><div class="line">sudo /Applications/VMware\ Fusion.app/Contents/Library/vmnet-cli --start</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Mac </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VMware Fusion </tag>
            
            <tag> NAT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Centos7网卡命名规则及修改]]></title>
      <url>http://www.pisces.ml/2017/03/26/Centos-7%E9%87%8D%E5%91%BD%E5%90%8D%E7%BD%91%E5%8D%A1/</url>
      <content type="html"><![CDATA[<h1 id="网卡命名规则"><a href="#网卡命名规则" class="headerlink" title="网卡命名规则"></a>网卡命名规则</h1><p>传统的网络设备命名是eth[0123…]<br>Centos7提供了不同的命名规则，默认是基于固件、拓扑、位置信息来分配。这样做的优点是命名是全自动的、可预知的，缺点是比eth0、wlan0更难读。比如enoxxxxxx </p>
<h2 id="命名规则策略"><a href="#命名规则策略" class="headerlink" title="命名规则策略"></a>命名规则策略</h2><p>默认的，systemd将根据下面的策略来命名接口，应用到支持的命名规则。</p>
<p>规则1：对于板载设备命名合并固件或BIOS提供的索引号，如果来自固件或BIOS的信息可读就命名，比如 eno1，这种命名是比较常见的，否则使用规则2。<br>规则2：命名合并固件或BIOS提供的PCI-E热插拔口索引号，比如ens1，如果信息可读就使用，否则使用规则3。<br>规则3：命名合并硬件接口的物理位置，比如 enp2s0，可用就命名，失败直接到方案5。<br>规则4：命名合并接口的MAC地址，比如 enx78e7d1ea46da， 默认不使用，除非用户选择使用此方案。<br>规则5：使用传统的方案，如果所有的方案都失败，eth0。</p>
<h1 id="修改网卡名称"><a href="#修改网卡名称" class="headerlink" title="修改网卡名称"></a>修改网卡名称</h1><p>centos7中默认使用了网卡的命名规则，对于我们的使用习惯，我们还是习惯将其改为ethx的命名方式。<br>我们可以看到系统网卡信息如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# ip a</div><div class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</div><div class="line"></div><div class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</div><div class="line">    inet 127.0.0.1/8 scope host lo</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">    inet6 ::1/128 scope host</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">2: eno16777736: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</div><div class="line">    link/ether 00:0c:29:73:e5:56 brd ff:ff:ff:ff:ff:ff</div><div class="line">    inet 192.168.43.209/24 brd 192.168.43.255 scope global dynamic eno16777736</div><div class="line">       valid_lft 3388sec preferred_lft 3388sec</div><div class="line">    inet6 fe80::20c:29ff:fe73:e556/64 scope link</div><div class="line">       valid_lft forever preferred_lft forever</div></pre></td></tr></table></figure>
<p>现在我们需要将名为eno16777736的网卡改成eth0，具体步骤如下所示：</p>
<ol>
<li><p>修改网卡配置文件/etc/sysconfig/network-scripts/ifcfg-eno16777736，将网卡配置文件NAME改为eth0,并将该文件重命名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">BOOTPROTO=&quot;dhcp&quot;</div><div class="line">DEFROUTE=&quot;yes&quot;</div><div class="line">PEERDNS=&quot;yes&quot;</div><div class="line">PEERROUTES=&quot;yes&quot;</div><div class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</div><div class="line">IPV6INIT=&quot;yes&quot;</div><div class="line">IPV6_AUTOCONF=&quot;yes&quot;</div><div class="line">IPV6_DEFROUTE=&quot;yes&quot;</div><div class="line">IPV6_PEERDNS=&quot;yes&quot;</div><div class="line">IPV6_PEERROUTES=&quot;yes&quot;</div><div class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</div><div class="line">NAME=&quot;eno16777736&quot; ----&gt; NAME=&quot;eth0&quot;</div><div class="line">UUID=&quot;5a87f740-b827-465b-abf8-7b864d7258c5&quot;</div><div class="line">DEVICE=&quot;eno16777736&quot; -----&gt; DEVICE=&quot;eth0&quot;</div><div class="line">ONBOOT=&quot;yes&quot;</div></pre></td></tr></table></figure>
<p>重命名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost network-scripts]# mv ifcfg-eno16777736 ifcfg-eth0</div></pre></td></tr></table></figure>
</li>
<li><p>禁用该可预测命名规则，过编辑/etc/default/grub并加入“net.ifnames=0 biosdevname=0 ”到GRUBCMDLINELINUX变量来实现，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GRUB_TIMEOUT=5</div><div class="line">GRUB_DISTRIBUTOR=&quot;$(sed &apos;s, release .*$,,g&apos; /etc/system-release)&quot;</div><div class="line">GRUB_DEFAULT=saved</div><div class="line">GRUB_DISABLE_SUBMENU=true</div><div class="line">GRUB_TERMINAL_OUTPUT=&quot;console&quot;</div><div class="line">GRUB_CMDLINE_LINUX=&quot;crashkernel=auto rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet net.ifnames=0 biosdevname=0&quot;</div><div class="line">GRUB_DISABLE_RECOVERY=&quot;true&quot;</div></pre></td></tr></table></figure>
<p>如果需要修改多块网卡则需添加多个例如：“net.ifnames=0 biosdevname=0 net.ifnames=1 biosdevname=1 net.ifnames=2 biosdevname=2”</p>
</li>
<li><p>运行命令grub2-mkconfig -o /boot/grub2/grub.cfg 来重新生成GRUB配置并更新内核参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@localhost network-scripts]# grub2-mkconfig -o /boot/grub2/grub.cfg</div><div class="line">Generating grub configuration file ...</div><div class="line">Found linux image: /boot/vmlinuz-3.10.0-514.10.2.el7.x86_64</div><div class="line">Found initrd image: /boot/initramfs-3.10.0-514.10.2.el7.x86_64.img</div><div class="line">Found linux image: /boot/vmlinuz-3.10.0-327.el7.x86_64</div><div class="line">Found initrd image: /boot/initramfs-3.10.0-327.el7.x86_64.img</div><div class="line">Found linux image: /boot/vmlinuz-0-rescue-cb085392bd6345d69ab5a0e0fe3aa74f</div><div class="line">Found initrd image: /boot/initramfs-0-rescue-cb085392bd6345d69ab5a0e0fe3aa74f.img</div><div class="line">done</div></pre></td></tr></table></figure>
</li>
<li><p>如果以上步骤重启后没有效果，再修改系统net命名规则/etc/udev/rules.d/90-eno-fix.rules，修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;00:0c:29:73:e5:56&quot;, NAME=&quot;eth0&quot; ——&gt;将name修改为eth0</div></pre></td></tr></table></figure>
</li>
</ol>
<p>最后别忘记重启系统，到此修改结束😄。</p>
]]></content>
      
        <categories>
            
            <category> Network </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关闭SELinux]]></title>
      <url>http://www.pisces.ml/2017/03/24/SELinux/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>  selinux（Security-Enhanced Linux）是一个在内核中实践的强制访问控制（MAC）安全性机制，目的在于明确的指明某个进程可以访问哪些类型的资源。开启selinux后，内核在执行系统调用前会询问 SELinux 是否获得了执行操作的授权</p>
<h2 id="永久方法-–-需要重启服务器"><a href="#永久方法-–-需要重启服务器" class="headerlink" title="永久方法 – 需要重启服务器"></a>永久方法 – 需要重启服务器</h2><p>修改/etc/selinux/config文件中设置SELINUX=disabled ，然后重启服务器。</p>
<h2 id="临时方法-–-设置系统参数"><a href="#临时方法-–-设置系统参数" class="headerlink" title="临时方法 – 设置系统参数"></a>临时方法 – 设置系统参数</h2><p>使用命令setenforce 0</p>
<p><strong>附：</strong><br>setenforce 1 设置SELinux 成为enforcing模式<br>setenforce 0 设置SELinux 成为permissive模式</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> selinux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux network namespace学习笔记]]></title>
      <url>http://www.pisces.ml/2017/03/15/linux-network-namespace%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在专业的网络世界中，经常使用到Virtual Routing and Forwarding（VRF），比如Cisco，Alcatel-Lucent, Juniper 等。对于L2 switch，自从上世纪90年代就开始使用VLAN，一个物理交换机上可以使用多个广播域，如今大多数交换机都支持4K vlan。</p>
<p>这个概念被引入到L3，如今很多网络设备支持VRF。这意味着，单个物理设备上可运行多个虚拟路由（L3 转发实例）。</p>
<p>在linux中，VRF被叫做“network namespace”，当然了linux中还包括其他namespace，不过本文不讨论。</p>
<p>每个network namespace拥有其对应的路由表（routing table）&amp; 其对应的iptables，并且运行程序运行其中。 为什么有人使用它？比如一个运行在linux上的 Firewall，将firewall的所有服务端口分配给一个network namespace，这样，默认的network namespace 和 Firewall network namespace就运行着不同的路由表。像SSH这样的application运行在默认的network namespace，但是不在Firewall network namespace。</p>
<p>下面展示了其基本用法。</p>
<h2 id="Basic-network-namespace-commands"><a href="#Basic-network-namespace-commands" class="headerlink" title="Basic network namespace commands"></a>Basic network namespace commands</h2><p>基本命令为“ip”，有些用户使用它来代替废弃的 ifconfig，route，netstat… 必须为root用户来使用它，这样才能更改network stack的配置。下面是ip命令和其他命令的映射：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ifconfig                                            --&gt; ip addr or just ip a</div><div class="line">ifconfig &lt;interface&gt; up/down                        --&gt; ip link set dev &lt;interface&gt; up/down</div><div class="line">ifconfig &lt;interface&gt; &lt;ip&gt; netmask &lt;netmask&gt;         --&gt; ip addr add &lt;ip&gt;/&lt;masklen&gt; dev &lt;interface&gt;</div><div class="line">netstat -rn                                         --&gt; ip route or just ip r</div><div class="line">route add -net &lt;net&gt; netmask &lt;netmask&gt; gw &lt;gateway&gt; --&gt; ip r add &lt;net&gt;/&lt;netmasklen&gt; via &lt;gateway&gt;</div></pre></td></tr></table></figure>
<h2 id="Check-your-Linux-for-namespace-support"><a href="#Check-your-Linux-for-namespace-support" class="headerlink" title="Check your Linux for namespace support"></a>Check your Linux for namespace support</h2><p>使用前，先检查系统是否支持。</p>
<h3 id="Creating-a-network-namespace"><a href="#Creating-a-network-namespace" class="headerlink" title="Creating a network namespace"></a>Creating a network namespace</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># add a new namespace</div><div class="line">ip netnas add &lt;network namespace name&gt;</div><div class="line">#Example:</div><div class="line">ip netns add nstest</div></pre></td></tr></table></figure>
<h3 id="Listing-all-existing-network-namespaces-in-the-system"><a href="#Listing-all-existing-network-namespaces-in-the-system" class="headerlink" title="Listing all existing network namespaces in the system"></a>Listing all existing network namespaces in the system</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># list all namespaces</div><div class="line">ip netns list</div><div class="line">#will show the namespace from above</div><div class="line"></div><div class="line">nstest</div></pre></td></tr></table></figure>
<h3 id="Deleting-a-network-namespace"><a href="#Deleting-a-network-namespace" class="headerlink" title="Deleting a network namespace"></a>Deleting a network namespace</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip netns delete &lt;network namespace name&gt;</div></pre></td></tr></table></figure>
<h3 id="Executing-a-command-in-a-network-namespace"><a href="#Executing-a-command-in-a-network-namespace" class="headerlink" title="Executing a command in a network namespace"></a>Executing a command in a network namespace</h3><p>下面展示了使程序运行在network namespace中的“黑魔法”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># execute a command in a namespace</div><div class="line">ip netns exec &lt;network namespace name&gt; &lt;command&gt;</div><div class="line">#Example using the namespace from above:</div><div class="line">ip netns exec nstest ip addr</div></pre></td></tr></table></figure>
<p>展示了在此network namespace中的所有的ip interface</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT</div><div class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</div></pre></td></tr></table></figure>
<p>一个脏技巧是在network namespace中运行shell：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip netns exec &lt;network namespace name&gt; bash</div></pre></td></tr></table></figure>
<p>现在，你已经“trapped”入namespace中了，exit退出。</p>
<h3 id="Exploring-the-network-namespace"><a href="#Exploring-the-network-namespace" class="headerlink" title="Exploring the network namespace"></a>Exploring the network namespace</h3><p>当我们已经创建了network namespace，第一个task是bring up其中的lo interface。应该注意到的是，在创建了network namespace后，lo interface的状态是down。如果忽略了这个，可能会发生一些奇怪的事。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># set the link of lo in the namespace to up</div><div class="line">ip netns exec nstest ip link set dev lo up</div><div class="line"># list all interfaces and the state in the namespace</div><div class="line">ip netns exec nstest ip link</div></pre></td></tr></table></figure>
<p>现在lo interface状态为up，现在，是时候将network namespace链接到外部空间。</p>
<h3 id="Adding-interfaces-to-a-network-namespace"><a href="#Adding-interfaces-to-a-network-namespace" class="headerlink" title="Adding interfaces to a network namespace"></a>Adding interfaces to a network namespace</h3><p>将一个物理interface分配给network namespace是不可能的，而是使用 virtual interface来实现。所以，我们先创建一个virtual interface，同样使用 ip command：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip link add veth-a type veth peer name veth-b</div></pre></td></tr></table></figure>
<p>上述命令创建了两个virtual interface，分别为veth-a &amp; veth-b,他们之间通过一个virtual cable链接。ip link命令显示了在默认namespace下这两个interface的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ip link</div><div class="line">veth-b: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</div><div class="line"> link/ether 72:01:ad:c5:67:84 brd ff:ff:ff:ff:ff:ff</div><div class="line">veth-a: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</div><div class="line"> link/ether 8e:8b:bd:b1:88:e5 brd ff:ff:ff:ff:ff:ff</div></pre></td></tr></table></figure>
<p>下面我们将其中的一个interface添加入之前我们创建的namespace nstest：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip link set veth-b netns nstest</div></pre></td></tr></table></figure>
<p>现在veth-b不在默认的namespace下了，而出现在了nstest 中，使用如下命令验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># list all interfaces in the namespace nstest</div><div class="line">ip netns exec nstest ip link</div><div class="line"></div><div class="line">lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT</div><div class="line"> link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</div><div class="line">veth-b: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</div><div class="line"> link/ether 72:01:ad:c5:67:84 brd ff:ff:ff:ff:ff:ff</div></pre></td></tr></table></figure>
<p>现在，在network namespace nstest中，就拥有了两个interface。</p>
<h3 id="Assign-ip-addresses-to-the-veth-interfaces"><a href="#Assign-ip-addresses-to-the-veth-interfaces" class="headerlink" title="Assign ip addresses to the veth interfaces"></a>Assign ip addresses to the veth interfaces</h3><p>现在是时候为这个veth interface分配ip并且使他的状态为up。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># default namespace</div><div class="line">ip addr add 10.0.0.1/24 dev veth-a</div><div class="line">ip link set dev veth-a up</div><div class="line">#</div><div class="line"># namespace nstest</div><div class="line">ip netns exec nstest ip addr add 10.0.0.2/24 dev veth-b</div><div class="line">ip netns exec nstest ip link set dev veth-b up</div></pre></td></tr></table></figure>
<p>可通过“ip link”查看interface状态是否为up，使用“ip addr”查看interface的ip 地址，使用“ip route”查看其路由。</p>
<p>现在可以在default namespace中，通过veth-a来ping通 位于 nstest中的veth-b。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ping 10.0.0.2</div><div class="line">PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.</div><div class="line">64 bytes from 10.0.0.2: icmp_req=1 ttl=64 time=0.054 ms</div><div class="line">64 bytes from 10.0.0.2: icmp_req=2 ttl=64 time=0.034 ms</div><div class="line">64 bytes from 10.0.0.2: icmp_req=3 ttl=64 time=0.039 ms</div><div class="line">64 bytes from 10.0.0.2: icmp_req=4 ttl=64 time=0.036 ms</div></pre></td></tr></table></figure>
<p>以及在nstest network namespace中，通过veth-b来ping通 veth-a：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ip netns exec nstest ping 10.0.0.1</div><div class="line">PING 10.0.0.1 (10.0.0.1) 56(84) bytes of data.</div><div class="line">64 bytes from 10.0.0.1: icmp_req=1 ttl=64 time=0.064 ms</div><div class="line">64 bytes from 10.0.0.1: icmp_req=2 ttl=64 time=0.036 ms</div><div class="line">64 bytes from 10.0.0.1: icmp_req=3 ttl=64 time=0.039 ms</div></pre></td></tr></table></figure>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>下面一起来实现一个demo，最终实现如下的case：<br><img src="https://sfault-image.b0.upaiyun.com/236/693/2366931023-565947f5ddd8d_articlex" alt="img"></p>
<p>首先，先建立对应的namespace：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ sudo ip netns add server</div><div class="line">$ sudo ip netns add gateway</div><div class="line">$ sudo ip netns add client</div><div class="line">$ ip netns list</div><div class="line">client</div><div class="line">gateway</div><div class="line">server</div></pre></td></tr></table></figure>
<p>然后，启用gateway namespace中的ip forward功能，注意，操作全是在root权限下执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ip netns exec gateway sysctl net.ipv4.ip_forward=1</div><div class="line">net.ipv4.ip_forward = 1</div></pre></td></tr></table></figure>
<p>下面我们来创建两对veth，用来连接不同的namespace：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ ip link add svr-veth type veth peer name svrgw-veth</div><div class="line">$ ip link add cli-veth type veth peer name cligw-veth</div><div class="line">$ ip link show | grep veth</div><div class="line">3: svrgw-veth:  mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</div><div class="line">4: svr-veth:  mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</div><div class="line">5: cligw-veth:  mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</div><div class="line">6: cli-veth:  mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</div></pre></td></tr></table></figure>
<p>将veth对的两端加入对应的namespace中，这样在默认的default namespace中就看不到他们了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ ip link set svr-veth netns server</div><div class="line">$ ip link set svrgw-veth netns gateway</div><div class="line">$ ip link set cligw-veth netns gateway</div><div class="line">$ ip link set cli-veth netns client</div><div class="line">$ ip link show | grep veth</div></pre></td></tr></table></figure>
<p>在指定的namespace上可以看到对应的interface：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ip netns exec server ip link show | grep veth</div><div class="line">4: svr-veth:  mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</div></pre></td></tr></table></figure>
<p>为各个veth分配ip：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ip netns exec server ifconfig svr-veth 192.168.100.1</div><div class="line">$ ip netns exec gateway ifconfig svrgw-veth 192.168.100.254</div><div class="line">$ ip netns exec gateway ifconfig cligw-veth 10.0.100.254</div><div class="line">$ ip netns exec client ifconfig cli-veth 10.0.100.1</div></pre></td></tr></table></figure>
<p>在各个veth对中，通过ping来检查连通性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$ ip netns exec gateway ping 192.168.100.1 -I 192.168.100.254</div><div class="line">PING 192.168.100.1 (192.168.100.1) from 192.168.100.254 : 56(84) bytes of data.</div><div class="line">64 bytes from 192.168.100.1: icmp_req=1 ttl=64 time=0.044 ms</div><div class="line">64 bytes from 192.168.100.1: icmp_req=2 ttl=64 time=0.036 ms</div><div class="line">64 bytes from 192.168.100.1: icmp_req=3 ttl=64 time=0.040 ms</div><div class="line">^C</div><div class="line">--- 192.168.100.1 ping statistics ---</div><div class="line">3 packets transmitted, 3 received, 0% packet loss, time 1999ms</div><div class="line">rtt min/avg/max/mdev = 0.036/0.040/0.044/0.003 ms</div><div class="line"></div><div class="line">$ ip netns exec gateway ping 10.0.100.1 -I 10.0.100.254</div><div class="line">PING 10.0.100.1 (10.0.100.1) from 10.0.100.254 : 56(84) bytes of data.</div><div class="line">64 bytes from 10.0.100.1: icmp_req=1 ttl=64 time=0.107 ms</div><div class="line">64 bytes from 10.0.100.1: icmp_req=2 ttl=64 time=0.037 ms</div><div class="line">64 bytes from 10.0.100.1: icmp_req=3 ttl=64 time=0.037 ms</div><div class="line">^C</div><div class="line">--- 10.0.100.1 ping statistics ---</div><div class="line">3 packets transmitted, 3 received, 0% packet loss, time 1998ms</div><div class="line">rtt min/avg/max/mdev = 0.037/0.060/0.107/0.033 ms</div></pre></td></tr></table></figure>
<p>接下来设定路由，将各namespace中的默认路由指向对应的veth ip：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ sudo ip netns exec client route add default gw 10.0.100.254</div><div class="line">$ sudo ip netns exec client netstat -rn</div><div class="line">Kernel IP routing table</div><div class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</div><div class="line">0.0.0.0         10.0.100.254    0.0.0.0         UG        0 0          0 cli-veth</div><div class="line">10.0.0.0        0.0.0.0         255.0.0.0       U         0 0          0 cli-veth</div><div class="line">$ ip netns exec server route add default gw 192.168.100.254</div><div class="line">$ ip netns exec server netstat -rn</div><div class="line">Kernel IP routing table</div><div class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</div><div class="line">0.0.0.0         192.168.100.254 0.0.0.0         UG        0 0          0 svr-veth</div><div class="line">192.168.100.0   0.0.0.0         255.255.255.0   U         0 0          0 svr-veth</div></pre></td></tr></table></figure>
<p>最后我们尝试从client namespace 到 server namespace的网络连通性，通过ping命令来测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ ip netns exec client ping 192.168.100.1 -I 10.0.100.1</div><div class="line">PING 192.168.100.1 (192.168.100.1) from 10.0.100.1 : 56(84) bytes of data.</div><div class="line">64 bytes from 192.168.100.1: icmp_req=1 ttl=63 time=0.106 ms</div><div class="line">64 bytes from 192.168.100.1: icmp_req=2 ttl=63 time=0.076 ms</div><div class="line">64 bytes from 192.168.100.1: icmp_req=3 ttl=63 time=0.050 ms</div><div class="line">^C</div><div class="line">--- 192.168.100.1 ping statistics ---</div><div class="line">3 packets transmitted, 3 received, 0% packet loss, time 1999ms</div><div class="line">rtt min/avg/max/mdev = 0.050/0.077/0.106/0.024 ms</div></pre></td></tr></table></figure>
<p>原文转发自：<a href="https://segmentfault.com/a/1190000004059167" target="_blank" rel="external">https://segmentfault.com/a/1190000004059167</a></p>
]]></content>
      
        <categories>
            
            <category> Network </category>
            
        </categories>
        
        
        <tags>
            
            <tag> namespace </tag>
            
            <tag> VRF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cleaning ‘Failed actions’ message in Pacemaker/Corosync cluster setup]]></title>
      <url>http://www.pisces.ml/2017/02/27/Cleaning-%E2%80%98Failed-actions%E2%80%99-message-in-Pacemaker-Corosync-cluster-setup/</url>
      <content type="html"><![CDATA[<p>Sometimes when using <a href="http://www.clusterlabs.org/" target="_blank" rel="external">Pacemaker</a>/<a href="http://www.corosync.org/doku.php?id=welcome" target="_blank" rel="external">Corosync</a>-based cluster you can see warning message in <strong>crm_mon</strong> output:</p>
<blockquote>
<p>Failed actions:<br>drbd_mysql:0_promote_0 (node=node2.cluster.org, call=11, rc=-2, status=Timed Out): unknown exec error</p>
</blockquote>
<p>﻿</p>
<p>To clean it up you can use command <strong>crm_resource</strong> which checks health of resources:</p>
<blockquote>
<p>[root@node1 ~]# crm_resource -P<br>Waiting for 1 replies from the CRMd. OK<br>[root@node1 ~]#</p>
</blockquote>
<p>To check cluster’s status run <strong>crm_mon </strong>again, warning message should be gone.</p>
]]></content>
      
        <categories>
            
            <category> Soft </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Pacemaker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux磁盘分区以及格式化]]></title>
      <url>http://www.pisces.ml/2017/02/24/linux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E4%BB%A5%E5%8F%8A%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>此文将介绍裸盘的分区以及格式化，我们知道一块裸盘需要挂载到云主机中是需要进行分区以及格式化之后，才能mount到虚拟机中。本来将介绍如何操作。</p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>（注意：以下操作都是在云平台中进行）</p>
<ol>
<li><p>首先准备一台虚拟机</p>
</li>
<li><p>申请一块10G云硬盘</p>
</li>
<li><p>将云硬盘挂载到虚拟机中</p>
</li>
</ol>
<p>以上步骤准备完成后我们需要进入虚拟机，我们可以看到虚拟机中已经挂载了这么一块盘进来,如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@test-fedora ~]# lsblk</div><div class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1  422K  0 rom</div><div class="line">vda    252:0    0   20G  0 disk</div><div class="line">└─vda1 252:1    0   20G  0 part /</div><div class="line">vdb    252:16   0   10G  0 disk</div></pre></td></tr></table></figure>
<p>由上图所示，我们可以看到有一块盘（vdb）已经挂在到虚拟机中。但是还没有进行分区和格式化，我们需要进行分区后再格式化才能正常使用。</p>
<h1 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h1><p>linux中我们使用fdisk命令来进行磁盘分区，下面我们就使用该命令进行磁盘分区。</p>
<p>首先我们可以使用帮助命令或者man来查看fdisk命令的帮助文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">[root@test-fedora ~]# fdisk -h</div><div class="line"></div><div class="line">用法：</div><div class="line"> fdisk [options] &lt;disk&gt;      change partition table</div><div class="line"> fdisk [options] -l [&lt;disk&gt;] list partition table(s)</div><div class="line"></div><div class="line">选项：</div><div class="line"> -b &lt;size&gt;         扇区大小(512, 1024, 2048 或 4096)</div><div class="line"> -c[=&lt;模式&gt;]       兼容模式：“dos”或“nondos”(默认)</div><div class="line"> -h                显示此帮助并退出</div><div class="line"> -c[=&lt;模式&gt;]       兼容模式：“dos”或“nondos”(默认)</div><div class="line"> -L[=&lt;何时&gt;]       彩色显示输出(auto自动，always总是或never从不)</div><div class="line"> -t &lt;类型&gt;         强制 disk 只重新识别特定的分区表类型</div><div class="line"> -u[=&lt;单位&gt;]       显示单位：“cylinders”柱面 或“sectors”扇区(默认)</div><div class="line"> -v                打印程序版本</div><div class="line"> -C &lt;数字&gt;         指定柱面数</div><div class="line"> -H &lt;数字&gt;         指定磁头数</div><div class="line"> -S &lt;数字&gt;         指定每条磁道的扇区数</div><div class="line"></div><div class="line">更多信息请参阅 fdisk(8)。</div></pre></td></tr></table></figure>
<p>下面我们对盘vdb进行分区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">[root@test-fedora ~]# fdisk /dev/vdb</div><div class="line"></div><div class="line">欢迎使用 fdisk (util-linux 2.24.2)。</div><div class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</div><div class="line">使用写入命令前请三思。</div><div class="line"></div><div class="line">设备不包含可识别的分区表。</div><div class="line"></div><div class="line">Created a new DOS disklabel with disk identifier 0xf8fe1a5e.</div><div class="line"></div><div class="line">命令(输入 m 获取帮助)：n        输入n,创建分区</div><div class="line"></div><div class="line">分区类型：</div><div class="line">   p   主分区(0 个主分区，0 个扩展分区，4 空闲)</div><div class="line">   e   扩展分区</div><div class="line">请选择(默认为 p)：: p          输入p或者e选择分区类型：主分区／扩展分区</div><div class="line">分区号 (1-4, default 1): 1    输入分区号</div><div class="line">第一个扇区 (2048-20971519, default 2048):     输入柱头启始号</div><div class="line">上个扇区，+sectors 或 +size&#123;K,M,G,T,P&#125; (2048-20971519, default 20971519):   输入柱头结束号</div><div class="line"></div><div class="line">创建了一个新分区 1，类型为“Linux”，大小为 10 GiB。</div><div class="line"></div><div class="line">命令(输入 m 获取帮助)：w      输入w保存配置</div><div class="line">分区表已调整。</div><div class="line">将调用 ioctl() 来重新读分区表。</div><div class="line">正在同步磁盘。</div></pre></td></tr></table></figure>
<p>通常分区可以根据个人需要将此盘分为多个分区，我们这里只分了一个示例分区，上面操作完成后，我们已经建立了分区表，我们可以通过lsblk命令查看分区，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@test-fedora ~]# lsblk</div><div class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1  422K  0 rom</div><div class="line">vda    252:0    0   20G  0 disk</div><div class="line">└─vda1 252:1    0   20G  0 part /</div><div class="line">vdb    252:16   0   10G  0 disk</div><div class="line">└─vdb1 252:17   0   10G  0 part    新建的分区</div></pre></td></tr></table></figure>
<p>我们可以看到vdb这块盘已经有了一个分区vdb1，但是我们还没有挂载到云主机中，下面我们就要用mkfs命令来对磁盘进行格式化</p>
<h1 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h1><p>同样我们首先查看帮助文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[root@test-fedora ~]# mkfs -h</div><div class="line">用法：</div><div class="line"> mkfs [选项] [-t &lt;类型&gt;] [文件系统选项] &lt;设备&gt; [&lt;大小&gt;]</div><div class="line"></div><div class="line">选项：</div><div class="line"> -t, --type=&lt;类型&gt;  文件系统类型；若不指定，将使用 ext2</div><div class="line">     fs-options     实际文件系统构建程序的参数</div><div class="line">     &lt;设备&gt;         要使用设备的路径</div><div class="line">     &lt;大小&gt;         要使用设备上的块数</div><div class="line"> -V, --verbose      解释正在进行的操作；</div><div class="line">                      多次指定 -V 将导致空运行(dry-run)</div><div class="line"> -V, --version      显示版本信息并退出</div><div class="line">                      将 -V 作为 --version 选项时必须是惟一选项</div><div class="line"> -h, --help         显示此帮助并退出</div><div class="line"></div><div class="line">更多信息请参阅 mkfs(8)。</div></pre></td></tr></table></figure>
<p>分区创建好之后，还必须要经过格式化才能使用，格式化分区的主要目的是在分区中创建文件系统。Linux专用的文件系统是ext，包含ext2、ext3、ext4等诸多版本，在RHEL6中默认使用的是ext4。另外Linux也支持Windows中的FAT32文件系统，在Linux中表示为vfat。示例，我们将这块磁盘格式化为ext2格式，操作如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[root@test-fedora ~]# mkfs -t ext2 /dev/vdb1</div><div class="line">mke2fs 1.42.12 (29-Aug-2014)</div><div class="line">Found a dos partition table in /dev/vdb1</div><div class="line">无论如何也要继续? (y,n) y</div><div class="line">Creating filesystem with 2621440 4k blocks and 655360 inodes</div><div class="line">Filesystem UUID: 893aedd2-f056-4b4f-9c86-9cef7f612ccf</div><div class="line">Superblock backups stored on blocks:</div><div class="line">	32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632</div><div class="line"></div><div class="line">Allocating group tables: 完成</div><div class="line">正在写入inode表: 完成</div><div class="line">Writing superblocks and filesystem accounting information: 完成</div></pre></td></tr></table></figure>
<h1 id="挂载磁盘"><a href="#挂载磁盘" class="headerlink" title="挂载磁盘"></a>挂载磁盘</h1><p>磁盘格式化完后我们需要将该磁盘挂载到一个目录中，这样我们就能往磁盘中写入数据了，首先我们建立一个文件夹，然后将该磁盘挂载到该目录下，具体操作如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@test-fedora ~]# mkdir /var/test</div><div class="line">[root@test-fedora ~]# mount /dev/vdb1 /var/test/</div><div class="line">mount: /dev/vdb1 写保护，将以只读方式挂载</div><div class="line">mount: 文件系统类型错误、选项错误、/dev/vdb1 上有坏超级块、</div><div class="line">       缺少代码页或助手程序，或其他错误</div><div class="line"></div><div class="line">       有些情况下在 syslog 中可以找到一些有用信息- 请尝试</div><div class="line">       dmesg | tail  这样的命令看看。</div></pre></td></tr></table></figure>
<p>挂载磁盘后通常我们需要手动设置开机自动挂载，否则下次系统启动是就需要手动进行挂载，这样很不方便。所以我们需要执行以下命令设置<strong>硬盘开机自动挂载</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@test-fedora ~]<span class="comment"># tail -1 /etc/mtab &gt;&gt; /etc/fstab</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> disk </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql分区表(转)]]></title>
      <url>http://www.pisces.ml/2017/01/13/mysql%E5%88%86%E5%8C%BA%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h1 id="什么是表分区？"><a href="#什么是表分区？" class="headerlink" title="什么是表分区？"></a>什么是表分区？</h1><p>表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</p>
<h1 id="表分区与分表的区别"><a href="#表分区与分表的区别" class="headerlink" title="表分区与分表的区别"></a>表分区与分表的区别</h1><p>分表：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。 分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</p>
<h1 id="表分区有什么好处？"><a href="#表分区有什么好处？" class="headerlink" title="表分区有什么好处？"></a>表分区有什么好处？</h1><ol>
<li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。</li>
<li>和单个磁盘或者文件系统相比，可以存储更多数据</li>
<li>优化查询。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</li>
<li>分区表更容易维护。例如：想批量删除大量数据可以清除整个分区。</li>
<li>可以使用分区表来避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问，ext3问价你系统的inode锁竞争等。</li>
</ol>
<h1 id="分区表的限制因素"><a href="#分区表的限制因素" class="headerlink" title="分区表的限制因素"></a>分区表的限制因素</h1><ol>
<li>一个表最多只能有1024个分区</li>
<li>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式。在MySQL5.5中提供了非整数表达式分区的支持。</li>
<li>如果分区字段中有主键或者唯一索引的列，那么多有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。</li>
<li>分区表中无法使用外键约束</li>
<li>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</li>
</ol>
<h1 id="如何判断当前MySQL是否支持分区？"><a href="#如何判断当前MySQL是否支持分区？" class="headerlink" title="如何判断当前MySQL是否支持分区？"></a>如何判断当前MySQL是否支持分区？</h1><p>命令：show variables like ‘%partition%’ 运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show variables like &apos;%partition%&apos;;</div><div class="line">+-------------------+-------+</div><div class="line">| Variable_name     | Value |</div><div class="line">+-------------------+-------+</div><div class="line">| have_partitioning | YES   |</div><div class="line">+-------------------+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>have_partintioning 的值为YES，表示支持分区。</p>
<h1 id="MySQL支持的分区类型有哪些？"><a href="#MySQL支持的分区类型有哪些？" class="headerlink" title="MySQL支持的分区类型有哪些？"></a>MySQL支持的分区类型有哪些？</h1><p>1）RANGE分区：按照数据的区间范围分区<br>2）LIST分区：按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。<br>3）HASH分区: 基于给定的分区个数，将数据分配到不同的分区,HASH分区只能针对整数进行HASH，对于非整形的字段只能通过表达式将其转换成整数。支持常规HASH(HASH)和线性HASH()<br>4）KEY分区：在MySQL5.1版本中，RANGE,LIST,HASH分区要求分区键必须是INT类型，或者通过表达式返回INT类型。但KEY分区的时候，可以使用其他类型的列（BLOB，TEXT类型除外）作为分区键。</p>
<h1 id="Range分区"><a href="#Range分区" class="headerlink" title="Range分区"></a>Range分区</h1><p>利用取值范围进行分区，区间要连续并且不能互相重叠。 语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">partition by range(exp)( //exp可以为列名或者表达式，比如to_date(created_date)</div><div class="line">    partition p0 values less than(num)</div><div class="line">    )</div></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; create table emp(</div><div class="line">    -&gt; id INT NOT null,</div><div class="line">    -&gt; store_id int not null</div><div class="line">    -&gt; )</div><div class="line">    -&gt; partition by range(store_id)(</div><div class="line">    -&gt;   partition p0 values less than(10),</div><div class="line">    -&gt;   partition p1 values less than(20)</div><div class="line">    -&gt; );</div></pre></td></tr></table></figure></p>
<p>上面的语句创建了emp表，并根据store_id字段进行分区，小于10的值存在分区p0中，大于等于10，小于20的值存在分区p1中。 注意 每个分区都是按顺序定义的，从最低到最高。上面的语句，如果将less than(10) 和less than (20)的顺序颠倒过来，那么将报错，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR 1493 (HY000): VALUES LESS THAN value must be strictly increasing for each partition</div></pre></td></tr></table></figure></p>
<h2 id="RANGE分区存在的问题"><a href="#RANGE分区存在的问题" class="headerlink" title="RANGE分区存在的问题"></a>RANGE分区存在的问题</h2><p>1.range范围覆盖问题：当插入的记录中对应的分区键的值不在分区定义的范围中的时候，插入语句会失败。 上面的例子，如果我插入一条store_id = 30的记录会怎么样呢？ 我们上面分区的时候，最大值是20，如果插入一条超过20的记录，会报错:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; insert into emp(id,store_id) values(2,30);</div><div class="line">ERROR 1526 (HY000): Table has no partition for value 30</div></pre></td></tr></table></figure>
<p>提示30这个值没有对应的分区。</p>
<blockquote>
<blockquote>
<p><strong>解决办法</strong>:<br>  A. 预估分区键的值，及时新增分区。<br>  B. 设置分区的时候，使用values less than maxvalue 子句,MAXVALUE表示最大的可能的整数值。<br>  C. 尽量选择能够全部覆盖的字段作为分区键，比如一年的十二个月等。</p>
</blockquote>
</blockquote>
<p>2.Range分区中，分区键的值如果是NULL，将被作为一个最小值来处理。</p>
<h1 id="LIST分区"><a href="#LIST分区" class="headerlink" title="LIST分区"></a>LIST分区</h1><p>List分区是建立离散的值列表告诉数据库特定的值属于哪个分区。 语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">partition by list(exp)( //exp为列名或者表达式</div><div class="line">     partition p0 values in (3,5)  //值为3和5的在p0分区</div><div class="line"> )</div></pre></td></tr></table></figure></p>
<p>与Range不同的是，list分区不必生命任何特定的顺序。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; create table emp1(</div><div class="line">    -&gt; id int not null,</div><div class="line">    -&gt; store_id int not null</div><div class="line">    -&gt; )</div><div class="line">    -&gt; partition by list(store_id)(</div><div class="line">    -&gt;   partition p0 values in (3,5),</div><div class="line">    -&gt;   partition p1 values in (2,6,7,9)</div><div class="line">    -&gt; );</div></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<p><strong>注意</strong> 如果插入的记录对应的分区键的值不在list分区指定的值中，将会插入失败。并且，list不能像range分区那样提供maxvalue。</p>
</blockquote>
</blockquote>
<h1 id="Columns分区"><a href="#Columns分区" class="headerlink" title="Columns分区"></a>Columns分区</h1><p>MySQL5.5中引入的分区类型，解决了5.5版本之前range分区和list分区只支持整数分区的问题。 Columns分区可以细分为 range columns分区和 list columns分区，他们都支持整数，日期时间，字符串三大数据类型。（不支持text和blob类型作为分区键） columns分区还支持多列分区（这里不详细展开）。</p>
<h1 id="Hash分区"><a href="#Hash分区" class="headerlink" title="Hash分区"></a>Hash分区</h1><p>Hash分区主要用来分散热点读，确保数据在预先确定个数的分区中尽可能平均分布。 MySQL支持两种Hash分区:常规Hash分区和线性Hash分区。<br>1.常规Hash分区:使用取模算法 语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">partition by hash(store_id) partitions 4;</div></pre></td></tr></table></figure></p>
<p>上面的语句，根据store_id对4取模，决定记录存储位置。 比如store_id = 234的记录，MOD(234,4)=2,所以会被存储在第二个分区。<br><strong>常规Hash分区的优点和不足</strong></p>
<p>  优点：能够使数据尽可能的均匀分布。<br>  缺点：不适合分区经常变动的需求。假如我要新增加两个分区，现在有6个分区，那么MOD(234,6)的结果与之前MOD(234,4)的结果就会出现不一致，这样大部分数据就需要重新计算分区。为解决此问题，MySQL提供了线性Hash分区。<br>2.线性Hash分区：分区函数是一个线性的2的幂的运算法则。 语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">partition by LINER hash(store_id) partitions 4;</div></pre></td></tr></table></figure></p>
<p>与常规Hash的不同在于，“Liner”关键字。 算法介绍: 假设要保存记录的分区编号为N,num为一个非负整数,表示分割成的分区的数量，那么N可以通过以下步骤得到：<br>Step 1. 找到一个大于等于num的2的幂，这个值为V，V可以通过下面公式得到：<br>    V = Power(2,Ceiling(Log(2,num)))<br>例如：刚才设置了4个分区，num=4，Log(2,4)=2,Ceiling(2)=2,power(2,2)=4,即V=4<br>Step 2. 设置N=F(column_list)&amp;(V-1)<br>例如：刚才V=4，store_id=234对应的N值，N = 234&amp;（4-1） =2<br>Step 3. 当N&gt;=num,设置V=Ceiling(V/2),N=N&amp;(V-1)<br>例如：store_id=234,N=2&lt;4,所以N就取值2，即可。<br>假设上面算出来的N=5，那么V=Ceiling(4/2)=2,N=5&amp;(2-1)=1,即在第一个分区。</p>
<p><strong>线性Hash的优点和不足</strong><br>优点：在分区维护（增加，删除，合并，拆分分区）时，MySQL能够处理得更加迅速。<br>缺点：与常规Hash分区相比，线性Hash各个分区之间的数据分布不太均衡。</p>
<h1 id="Key分区"><a href="#Key分区" class="headerlink" title="Key分区"></a>Key分区</h1><p>类似Hash分区，Hash分区允许使用用户自定义的表达式，但Key分区不允许使用用户自定义的表达式。Hash仅支持整数分区，而Key分区支持除了Blob和text的其他类型的列作为分区键。 语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">partition by key(exp) partitions 4;//exp是零个或多个字段名的列表</div></pre></td></tr></table></figure></p>
<p>key分区的时候，exp可以为空，如果为空，则默认使用主键作为分区键，没有主键的时候，会选择非空惟一键作为分区键。</p>
<h1 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h1><p>分区表中对每个分区再次分割，又成为复合分区。</p>
<h1 id="分区对于NULL值的处理"><a href="#分区对于NULL值的处理" class="headerlink" title="分区对于NULL值的处理"></a>分区对于NULL值的处理</h1><p>MySQ允许分区键值为NULL，分区键可能是一个字段或者一个用户定义的表达式。一般情况下，MySQL在分区的时候会把NULL值当作零值或者一个最小值进行处理。</p>
<p><strong>注意</strong><br>Range分区中：NULL值被当作最小值来处理<br>List分区中：NULL值必须出现在列表中，否则不被接受<br>Hash/Key分区中：NULL值会被当作零值来处理</p>
<h1 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h1><p>分区管理包括对于分区的增加，删除，以及查询。<br>1.增加分区：<br>对于Range分区和LIst分区来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table table_name add partition (partition p0 values ...(exp))</div></pre></td></tr></table></figure></p>
<p>values后面的内容根据分区的类型不同而不同。<br>对于Hash分区和Key分区来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table table_name add partition partitions 8;</div></pre></td></tr></table></figure></p>
<p>上面的语句，指的是新增8个分区 。<br>2.删除分区<br>对于Range分区和List分区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table table_name drop partition p0; //p0为要删除的分区名称</div></pre></td></tr></table></figure></p>
<p>删除了分区，同时也将删除该分区中的所有数据。同时，如果删除了分区导致分区不能覆盖所有值，那么插入数据的时候会报错。<br>对于Hash和Key分区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table table_name coalesce partition 2; //将分区缩减到2个</div></pre></td></tr></table></figure></p>
<p>3.分区查询<br>1) 查询某张表一共有多少个分区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select</div><div class="line"> -&gt;   partition_name,</div><div class="line"> -&gt;   partition_expression,</div><div class="line"> -&gt;   partition_description,</div><div class="line"> -&gt;   table_rows</div><div class="line"> -&gt; from</div><div class="line"> -&gt;   INFORMATION_SCHEMA.partitions</div><div class="line"> -&gt; where</div><div class="line"> -&gt;   table_schema=&apos;test&apos;</div><div class="line"> -&gt;   and table_name = &apos;emp&apos;;</div><div class="line">+----------------+----------------------+-----------------------+------------+</div><div class="line">| partition_name | partition_expression | partition_description | table_rows |</div><div class="line">+----------------+----------------------+-----------------------+------------+</div><div class="line">| p0             | store_id             | 10                    |          0 |</div><div class="line">| p1             | store_id             | 20                    |          1 |</div><div class="line">+----------------+----------------------+-----------------------+------------+</div></pre></td></tr></table></figure></p>
<p>即，可以从information_schema.partitions表中查询。<br>2) 查看执行计划，判断查询数据是否进行了分区过滤<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain partitions select * from emp where store_id=10 \G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">        id: 1</div><div class="line">select_type: SIMPLE</div><div class="line">     table: emp</div><div class="line">partitions: p1</div><div class="line">      type: system</div><div class="line">possible_keys: NULL</div><div class="line">       key: NULL</div><div class="line">   key_len: NULL</div><div class="line">       ref: NULL</div><div class="line">      rows: 1</div><div class="line">     Extra:</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<p>本文转自:<a href="https://my.oschina.net/jasonultimate/blog/548745" target="_blank" rel="external">https://my.oschina.net/jasonultimate/blog/548745</a><br>仅供学习实用</p>
</blockquote>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Database </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[聊聊linux字符设备]]></title>
      <url>http://www.pisces.ml/2016/12/28/linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/</url>
      <content type="html"><![CDATA[<p>这章将介绍Linux系统的设 备，这样我们才能清楚的知道应用程序和设备驱动程序是如何的工作的，或者说应用程序是如何控制驱动程序的，进而知道应用程序是如何通过驱动程序操作设备 的，另外会详细的介绍设备号及设备文件。</p>
<h1 id="Linux设备分类"><a href="#Linux设备分类" class="headerlink" title="Linux设备分类"></a>Linux设备分类</h1><p>Linux下的设备通常分为三类，字符设备，块设备和网络设 备。</p>
<h2 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h2><p>一个字符设 备是一种字节流设备，对设备的存取只能按顺序按字节的存取而不能随机访问，字符设备没有请求缓冲区，所有的访问请求都是按顺序执行的。Linux下的大多设备都是字符设备。应用程序是通过字符设备节点来访问 字符设备的。设备节点一般都由mknod命令都创 建在/dev目录下，下 面的例子显示了串口设备的设备节点。字符设备文件的第一个标志是前面的“c”标志。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root<span class="comment">#ls -l /dev/ttyS[0-3]</span></div><div class="line">crw-rw----  1 root  root 4, 64 Feb 18 23:34 /dev/ttyS0</div><div class="line">crw-r-----  1 root  root 4, 65 Nov 17 10:26 /dev/ttyS1</div><div class="line">crw-rw----  1 root  root 4, 66 Jul  5  2000 /dev/ttyS2</div><div class="line">crw-rw----  1 root  root 4, 67 Jul  5  2000 /dev/ttyS3</div></pre></td></tr></table></figure>
<p>字符设备是指那些只能按顺序一个字节一个字节读取的设备，但事实上现在一些高级 字符设备也可以从指定位置一次读取一块数据。字符设备是面向数据流的设备，每个字符设备都有一个设备号，设备号由主设备号和次设备号组成。同时Linux使用管理文件相同的方法来管理字符设备，所以每个字符设备在/dev/目录下都有一个对应的设备文件，即设备节点，它们包含了设备的 类型、主/次设备号以 及设备的访问权限控制等，系统通过设备文件来对字符设备进行操作，每个字符设备文件都有自己的与普通文件相同的文件操作函数组结构（struct file_operations）。字符设 备驱动通常至少需要实现文件操作函数组中的open、release、read和write四种操作方法。常见的字符设备有鼠标、键盘、串口、控制台等。</p>
<h2 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h2><p>存储设备一 般属于块设备，块设备有请求缓冲区，并且支持随机访问而不必按照顺序去存取数据，比如你可以 先存取后面的数据，然后在存取前面的数据，这对字符设备来说是不可能的。Linux下的磁盘 设备都是块设备，尽管在Linux下有块设 备节点，但应用程序一般是通过文件系统及其高速缓存来访问块设备的,而不是直 接通过设备节点来读写块设备上的数据。块设备文件的第一个标志是前面的“b”标志。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root<span class="comment"># ls -l /dev/hda[1-3]</span></div><div class="line">brw-rw----  1 root  root  3, 1 Jul  5  2000 /dev/hda1</div><div class="line">brw-rw----  1 root  root  3, 2 Jul  5  2000 /dev/hda2</div><div class="line">brw-rw----  1 root  root  3, 3 Jul  5  2000 /dev/hda3</div></pre></td></tr></table></figure>
<p>块设备是指那些可以从设备的任意位置读取任意长度数据的设备。每个块设备同样有 一个设备号，设备号由主设备号和次设备号组成。同时Linux也使用管 理文件相同的方法来管理块设备，每个块设备在/dev/目录下都 有一个对应的设备文件，即设备节点，它们包含了设备的类型、主/次设备号 以及设备的访问权限控制等，系统通过设备文件来对块设备进行操作，每个块设备文件都有自己的与普通文件相同的文件操作函数组结构（struct file_operations）。但块设 备需要实现的操作方法远比字符设备的操作方法多得多，也难得多。块设备既可以作为普通的裸设备用来存放任意数据，也可以将块设备按某种文件系统类型的格式 进行格式化，然后按照该文件系统类型的格式来读取块设备上的数据，但不管哪种方式，最后访问设备上的数据都必须通过调用设备本身的操作方法实现，区别在于 前者直接调用块设备的操作方法，而后者则间接调用块设备的操作方法。常见的块设备有各种硬盘、flash磁盘、RAM磁盘等。</p>
<h2 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h2><p>网络设备不 同于字符设备和块设备，它是面向报文的而不是面向流的，它不支持随机访问，也没有请求缓冲区。在Linux里一个网络设备也可以叫做一个网络接口，如eth0，应用程序是通过Socket而不是设备节点来访问网络设备，在系统里根本就不存在网络设备节点。</p>
<p>网络接口用来与其他设备交换数据，它可以是硬件设备，也可以是纯软件设备，如loopback接口就是一个纯软件设备。网络接口由内核中的网络 子系统驱动，负责发送和接收数据包，但它不需要了解每项事务如何映射到实际传送的数据包，许多网络连接（尤其是使用TCP协议的连接）是面向流的，但网络设备围绕数据包的传输和接收设 计。网络驱动程序不需要知道各个连接的相关信息，它只需处理数据包。网络接口没有像字符设备和块设备一样的设备号，只有一个唯一的名字，如eth0、eth1等，而这个名字也不需要与设备文件节点对应。内核使用一套与数据 包传输相关的函数来与网络设备驱动程序通信，它们不同于字符设备和块设备的read()和write()方法。</p>
<h1 id="设备节点、设备驱动及设备的关联"><a href="#设备节点、设备驱动及设备的关联" class="headerlink" title="设备节点、设备驱动及设备的关联"></a>设备节点、设备驱动及设备的关联</h1><p>当我们访问 一个设备节点是，系统是如果知道使用哪个设备驱动及访问哪个设备的呢？这个是通过设备号来实现的。当我们创建一个设备节点时需要指定主设备号和次设备号。 对于设备节点来说，名字不是重要的，设备号才是最重要的，它实际指定了对应的驱动程序和对应的设备。</p>
<p>Linux的设备管理是和文件系统紧密结合的，各种设备都以文件的形式存 放在/dev目录下，称 为设备文件。应用程序可以打开、关闭和读写这些设备文件，完成对设备的操作，就像操作普通的数据文件一样。为了管理这些设备，系统为设备编了号，每个设备 号又分为主设备号和次设备号。主设备号用来区分不同种类的设备，而次设备号用来区分同一类型的多个设备。对于常用设备，Linux有约定俗成的编号，如硬盘的主设备号是3。</p>
<p>Linux为所有的 设备文件都提供了统一的操作函数接口，方法是使用数据结构struct file_operations。这个数据结构中包括许多操作函数的指针，如open()、close()、read()和write()等，但由于外设的种类较多，操作方式各不相同。Struct file_operations结构体中的 成员为一系列的接口函数，如用于读/写的read/write函数和用于控制的ioctl等。打开一个文件就是调用这个文件file_operations中的open操作。不同类型的文件有不同的file_operations成员函数， 如普通的磁盘数据文件，接口函数完成磁盘数据块读写操作；而对于各种设备文件，则最终调用各自驱动程序中的I/O函数进行具体设备的操作。这样，应用程序根本不必考虑操作的是设 备还是普通文件，可一律当作文件处理，具有非常清晰统一的I/O接口。所 以file_operations是文件层 次的I/O接口。</p>
<h2 id="主设备号"><a href="#主设备号" class="headerlink" title="主设备号"></a>主设备号</h2><p>驱动程序在 初始化时，会注册它的驱动及对应主设备号到系统中，这样当应用程序访问设备节点时，系统就知道它所访问的驱动程序了。你可以通过/proc/devices文件来驱动 系统设备的主设备号。</p>
<h2 id="次设备号"><a href="#次设备号" class="headerlink" title="次设备号"></a>次设备号</h2><p>驱动程序遍历设备时，每发现一个它能驱动的设备，就创建一个设备对象，并为其分配一个次设备号以区分不同的设备。这样当应用程序访问设备节点时驱动程序就可以根据次 设备号知道它说访问的设备了。<br>系统中的每一个字符设备和块设备（网络接口没有设备号）都有一个设备号，传统的UNIX以及早期版本Linux中的设备号是16位的，主次设备号都是8位的，低8位为次设备号，高8位为主设备号，因此系统最多分别支持65536个字符设备和65536个块设备，这个限制已经不能满足当 前层出不穷的各种新设备的需要，所以Linux2.6中对设备号已经进行了扩展，一个设备 号为32位，主设备号为12位，次设备号为20位，但是这32位设备号的编码方式有新旧两种，旧的设备编号格式为：最高12位为主设备号，最低20位为次设备号；新的设备编号格式为：bit[19:8]是主设备号，bit[31:20]是次设备号的高12位，bit[7:0]是次设备号的低8位。如果知道了一个设备的主设备号major和次设备号minor，那么用MKDEV(major,minor)生成是该设备的旧格式的设备号，用new_encode_dev(MKDEV(major,minor))生成的则是新格式的设备号。Linux支持的各种设备的主设备号定义在include/linux/major.h文件中，而已经在官方注册的主设备号和次设备号在Documentation/devices.txt文件中可以找到。<br>老式16位设备号、32位旧格式设备号以及32位新格式设备号的转换操作函数如下：<br>new_encode_dev(dev_t dev)函数<br>将32位旧格式 设备号dev转换成32位新格式设备号。<br>new_decode_dev(u32 dev)函数<br>将32位新格式 设备号转换成32位旧格式设 备号。<br>old_encode_dev(dev_t dev)函数<br>将32位旧格式 设备号转换成老式16位设备号。<br>dev_t old_decode_dev(u16 val)函数<br>将老式16位设备号转换成32位旧格式设备号。<br>Linux中设备节点是通过“mknod”命令来创建 的。一个设备节点其实就是一个文件，Linux中称为设 备文件。有一点必要说明的是，在Linux中，所有 的设备访问都是通过文件的方式，一般的数据文件程序普通文件，设备节点称为设备文件。在Linux内核中网络设备也是通过文件操作的，称为网络设备文件，在用户空间是通过socket接口来访问的。socket号就是网络设备文件描述符。<br>如：mknod /dev/mydevice c 254 0<br>(c代表子都设备，254为主设备号，0为次设备号)<br>Open，close等操作/dev/下设备文件，内核根据文件的主设备号找到对应的设备驱动<br>主设备号可以分为动态和静态申请。</p>
<h2 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h2><p>Linux使用对文 件一样管理方式来管理设备，所以对于系统中的每个字符设备或者块设备都必须为其创建一个设备文件，这个设备文件就是放在/dev/目录下的设备节点，它包含了该设备的设备类型（块设备或字符设 备）、设备号（主设备号和次设备号）以及设备访问控制属性等。设备文件可以通过手工用mknod命令生成也可以由udev用户工具 软件在系统启动后根据/sys目录下每个 设备的实际信息创建，使用后一种方式可以为每个设备动态分配设备号，而不必分配固定的设备号，如果系统中的设备不多，而且设备类型又是常见的，可以使用手 工方式生成设备文件，为常用设备创建一个已经分配号的设备号对应的设备文件，这样比较方便。如果系统很大，系统中的设备太多，那么最好动态分配设备号，由udev在系统启动之后根据设备实际信息自动创建设备文件。<br>Linux下的大部分驱动程序都是字符设备驱动程序，通过下面的学习我们将 会了解到字符设备是如何注册到系统中的，应用程序是如何访问驱动程序的数据的，及字符驱动程序是如何工作的。</p>
<h2 id="设备号"><a href="#设备号" class="headerlink" title="设备号"></a>设备号</h2><p>通过前面的 学习我们知道应用程序是通过设备节点来访问驱动程序及设备的，其根本是通过设备节点的设备号（主设备号及从设备号）来关联驱动程序及设备的，字符设备也不 例外（其实字符设备只能这样访问）。这里我们详细讨论Linux内部如何管 理设备号的。</p>
<h2 id="设备号类型"><a href="#设备号类型" class="headerlink" title="设备号类型"></a>设备号类型</h2><p>Linux内核里用“dev_t”来表示设备号，它是一个32位的无符号数，其高12位用来表示主设备号，低20位用来表示从设备号。它被定义在<linux types.h="">头文件里。 内核里提供了操作“dev_t”的函数，驱动 程序中通过这些函数（其实是宏，定义在<linux kdev_t.h="">文件中）来操作设备号。</linux></linux></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#define MINORBITS    20</span></div><div class="line"><span class="comment">#define MINORMASK    ((1U &lt;&lt; MINORBITS) - 1)</span></div><div class="line"><span class="comment">#define MAJOR(dev)    ((unsigned int) ((dev) &gt;&gt; MINORBITS))</span></div><div class="line"><span class="comment">#define MINOR(dev)    ((unsigned int) ((dev) &amp; MINORMASK))</span></div><div class="line"><span class="comment">#define MKDEV(ma,mi)    (((ma) &lt;&lt; MINORBITS) | (mi))</span></div></pre></td></tr></table></figure>
<p>MAJOR（dev）用于获取主设备号，MINOR（dev）用于获取从设备号，而MKDEV（ma，mi）用于通过主设备号和从设备号构造”dev_t”数据。<br>另一点需要 说明的是，dev_t数据类型支持2^12个主设备号，每个主设备号（通常是一个设备驱动）可以支持2^20个设备，目前来说这已经足够大了，但谁又能说将来还能满足要求 呢？一个良好的编程习惯是不要依赖dev_t这个数据类 型，切记必须使用内核提供的操作设备号的函数。</p>
<h2 id="字符设备号注册"><a href="#字符设备号注册" class="headerlink" title="字符设备号注册"></a>字符设备号注册</h2><p>内核提供了字符设备号管理的函数接口，作为一个良好的编程习惯，字符设备驱动程 序应该通过这些函数向系统注册或注销字符设备号。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int register_chrdev_region(dev_t from, unsigned count, const char *name)</div><div class="line">int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,</div><div class="line">            const char *name)</div><div class="line">void unregister_chrdev_region(dev_t from, unsigned count)</div></pre></td></tr></table></figure></p>
<p>register_chrdev_region用于向内核注册已知可用的设备号（次设备号通常是0）范围。由于历史的原因一些设备的设备号是固定的，你可以在内核源代码树的Documentation/devices.txt文件中找到这些静态分配的设备号。<br>alloc_chrdev_region用于动态分 配的设备号并注册到内核中，分配的设备号通过dev参数返回。 作为一个良好的内核开发习惯，我们推荐你使用动态分配的方式来生成设备号。<br>unregister_chrdev_region用于注销一 个不用的设备号区域，通常这个函数在驱动程序卸载时被调用。</p>
<h2 id="字符设备-1"><a href="#字符设备-1" class="headerlink" title="字符设备"></a>字符设备</h2><p>Linux2.6内核使用“struct cdev”来记录字符设备的信息，内核也提供了相关的函数来操作“struct cdev”对象，他们定义在<linux cdev.h="">头文件中。 可见字符设备及其操作函数接口定义的很简单。</linux></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">struct cdev &#123;</div><div class="line">    struct kobject kobj;</div><div class="line">    struct module *owner;</div><div class="line">    const struct file_operations *ops;</div><div class="line">    struct list_head list;</div><div class="line">    dev_t dev;</div><div class="line">    unsigned int count;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void cdev_init(struct cdev *, const struct file_operations *);</div><div class="line">struct cdev *cdev_alloc(void);</div><div class="line">void cdev_put(struct cdev *p);</div><div class="line">int cdev_add(struct cdev *, dev_t, unsigned);</div><div class="line">void cdev_del(struct cdev *);</div></pre></td></tr></table></figure>
<p>对于Linux 2.6内核来说，struct cdev是内核字符设备的基础结构，用来表示一个字符设备，包含了字符设备需要的全部信息。</p>
<ul>
<li>kobj：struct kobject对象数据，用来描述设备的引用计数，是Linux设备模型的基础结构。我们在后面的“Linux设备模型”在做详细的介绍。</li>
<li>owner：struct module对象数据，描述了模块的属主，指向拥有这个结构的模块的指针，显然它只有对编译为模块方式的驱动才由意义。一般赋值位“THIS_MODULE”。</li>
<li>ops：struct file_operations对象数据，描述了字符设备的操作函数指针。对于设备驱动来说，这是一个很重要的数据成员，几乎所有的驱动都要用到这个对象，我们会在下面做详细介绍。</li>
<li>dev：dev_t对象数据，描述了字符设备的设备号。<br>内核提供了操作字符设备对象“struct cdev”的函数，我们只能通过这些函数来操作字符设备，例如：初始化、注册、添加、移除字符设备。</li>
<li><p>cdev_alloc：用于动态分配一个新的字符设备cdev对象，并对其进行初始化。采用cdev_alloc分配的cdev对象需要显示的初始化owner和ops对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 参考drivers/scsi/st.c:st_probe 函数</div><div class="line">struct cdev *cdev = NULL;</div><div class="line">cdev = cdev_alloc();</div><div class="line">// Error Processing</div><div class="line">cdev-&gt;owner = THIS_MODULE;</div><div class="line">cdev-&gt;ops = &amp;st_fops;</div></pre></td></tr></table></figure>
</li>
<li><p>cdev_init：用于初始化一个静态分配的cdev对象，一般这个对象会嵌入到其他的对象中。cdev_init会自动初始化ops数据，因此应用程序只需要显示的给owner对象赋值。cdev_init的功能与cdev_alloc基本相同，唯 一的区别是cdev_init初始化一个 已经存在的cdev对象，并且这个初始化会影响到字符设备删除函数（cdev_del）的行为， 请参考cdev_del函数。</p>
</li>
<li>cdev_add：向内核系统中添加一个新的字符设备cdev，并且使它立即可用。</li>
<li>cdev_del：从内核系统中移除cdev字符设备。如 果字符设备是由cdev_alloc动态分配的，则会释放分配的内存。</li>
<li>cdev_put：减少模块的引用计数，一般很少会有驱动程序直接调用这个函数。</li>
</ul>
<h1 id="文件操作对象"><a href="#文件操作对象" class="headerlink" title="文件操作对象"></a>文件操作对象</h1><p>Linux中的所有设备都是文件，内核中用“struct file”结构来表示一 个文件。尽管我们的驱动不会直接使用这个结构中的大部分对象，其中的一些数据成员还是很重要的，我们有必要在这里做一些介绍，具体的内容请参考内核源代码 树<linux fs.h="">头文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// struct file 中的一些重要数据成员</div><div class="line">const struct file_operations    *f_op;</div><div class="line">unsigned int         f_flags;</div><div class="line">mode_t            f_mode;</div><div class="line">loff_t            f_pos;</div><div class="line">struct address_space    *f_mapping;</div></pre></td></tr></table></figure></linux></p>
<p>这里我们不对struct file做过多的介绍，另一篇struct file将做详细介绍。这个结构中的f_ops成员是我们的驱动所关心的，它是一个struct file_operations结构。Linux里的struct file_operations结构描述了一 个文件操作需要的所有函数，它定义在<linux fs.h="">头文件中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">struct file_operations &#123;</div><div class="line">    struct module *owner;</div><div class="line">    loff_t (*llseek) (struct file *, loff_t, int);</div><div class="line">    ssize_t (*<span class="built_in">read</span>) (struct file *, char __user *, size_t, loff_t *);</div><div class="line">    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);</div><div class="line">    ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);</div><div class="line">    ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);</div><div class="line">    int (*readdir) (struct file *, void *, filldir_t);</div><div class="line">    unsigned int (*poll) (struct file *, struct poll_table_struct *);</div><div class="line">    int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);</div><div class="line">    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);</div><div class="line">    long (*compat_ioctl) (struct file *, unsigned int, unsigned long);</div><div class="line">    int (*mmap) (struct file *, struct vm_area_struct *);</div><div class="line">    int (*open) (struct inode *, struct file *);</div><div class="line">    int (*flush) (struct file *, fl_owner_t id);</div><div class="line">    int (*release) (struct inode *, struct file *);</div><div class="line">    int (*fsync) (struct file *, struct dentry *, int datasync);</div><div class="line">    int (*aio_fsync) (struct kiocb *, int datasync);</div><div class="line">    int (*fasync) (int, struct file *, int);</div><div class="line">    int (*lock) (struct file *, int, struct file_lock *);</div><div class="line">    ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);</div><div class="line">    unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);</div><div class="line">    int (*check_flags)(int);</div><div class="line">    int (*dir_notify)(struct file *filp, unsigned long arg);</div><div class="line">    int (*flock) (struct file *, int, struct file_lock *);</div><div class="line">    ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);</div><div class="line">    ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);</div><div class="line">    int (*setlease)(struct file *, long, struct file_lock **);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></linux></p>
<p>这是一个很大的结构，包含了所有的设备操作函数指针。当然，对于一个驱动，不是所有的接口都需要来实现的。对于一个字符设备来说，一般实现open、release、read、write、mmap、ioctl这几个函数就足够了。<br>这里需要指出的是，open和release函数的第一个参数是一个struct inode对象。这是一个内核文件系统索引节点对象，它包含了内核在操作文件或目录是需要的全部信息。对于字符设备驱动来说，我们关心的是从struct inode对象中获取设备号（inode的i_rdev成员）内核提供了两个函数来做这件事。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static inline unsigned iminor(const struct inode *inode)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">return</span> MINOR(inode-&gt;i_rdev);</div><div class="line">&#125;</div><div class="line">static inline unsigned imajor(const struct inode *inode)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">return</span> MAJOR(inode-&gt;i_rdev);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>尽管我们可以直接从inode-&gt;i_rdev获取设备号，但是尽量不要这样做。我们推荐你调用内核提供的函数来获取设备号，这样即使将来inode-&gt;i_rdev有所变化，我们的程序也会工作的很好。<br>字符设备驱动可以参考Linux 设备驱动程序第三版和linux设备驱动开发详解，其中linux设备驱动程序第三版中讲的：<br>主次编号<br>一些重要数据结构<br>字符设备注册<br>Open和release<br>读和写<br>一些头文件和结构体；<br>都非常经典， 都理解字符驱动设备很重要，很值得参考！</p>
<blockquote>
<blockquote>
<font color="red">本文转自网络，仅做学习交流使用</font>
</blockquote>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux device </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ARP地址解析协议]]></title>
      <url>http://www.pisces.ml/2016/12/16/Address-Resolution-Protocol/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol" target="_blank" rel="external"><font size="3">ARP协议</font></a>是处于<a href="https://en.wikipedia.org/wiki/OSI_model" target="_blank" rel="external">7层网络模型</a>中的网络层的协议，协议内容根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。</p>
<h1 id="ARP工作流程"><a href="#ARP工作流程" class="headerlink" title="ARP工作流程"></a>ARP工作流程</h1><p>举个例子，我们假设：<br>主机A的IP地址为192.168.0.1，mac地址为xx-xx-xx-xx-xx-01;<br>主机B的IP地址为192.168.0.2，mac地址为xx-xx-xx-xx-xx-02;<br>当主机A需要与主机B通信时，地址解析协议需要将主机B的IP地址解析成主机B的物理地址（即mac地址，我们知道所有设备都有一个<br>唯一的mac地址），这样根据实际的物理地址两个主机才能够相互通信。以下是工作流程：</p>
<ol>
<li>首先主机A会确定用于访问主机B的转发IP地址是192.168.0.2（根据本地解析，或者域名解析等）。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。</li>
<li>如果主机A在ARP缓存中没有找到映射，它将询问192.168.0.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</li>
<li>主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</li>
<li>主机B将包含其MAC地址的ARP回复消息直接发送回主机A。</li>
<li>当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</li>
</ol>
<h1 id="ARP命令实用"><a href="#ARP命令实用" class="headerlink" title="ARP命令实用"></a>ARP命令实用</h1><p>查看arp命令帮助：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">man arp</div></pre></td></tr></table></figure></p>
<p><font size="4"><strong><em>ARP常用命令选项</em></strong>：</font></p>
<p><font size="3">arp -a / arp -g</font><br>查看地址缓存中的所有项目</p>
<p><font size="3">arp -a IP</font><br>如果我们有多个网卡，那么使用arp -a加上接口的IP地址，就可以只显示与该接口相关的ARP缓存项目。</p>
<p><font size="3">arp -s/-S IP ether_addr(物理地址)</font><br>配置本地ARP缓存，如果目标物理地址配置错误，将导致主机间无法通信。(可以尝试下如果配置一个错误地址是ping不通的), 参数-S含义是如果添加的地址已经存在，会将其先删除再添加</p>
<p><font size="3">arp -d IP</font><br>删除一个ARP缓存条目</p>
<blockquote>
<p>更多使用方法可以通过帮助命令查看，非常全面。前提是英语得过关😅</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Network </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ARP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Memcache 篇]]></title>
      <url>http://www.pisces.ml/2016/12/14/Memcache-principle-and-usage/</url>
      <content type="html"><![CDATA[<p><img src="https://memcached.org/images/memcached_banner75.jpg"></p>
<h2 id="Memcached简介"><a href="#Memcached简介" class="headerlink" title="Memcached简介"></a>Memcached简介</h2><p>Memcached是LiveJournal旗下等Danga Interactive公司等Brad Fitzpatric为首开发等一款开源的、高性能、分布式<br>软件。通过系统内存管理的缓存机制，将数据缓存到内存中，这么做的目的是目的是为了通过缓存数据库的查询命<br>中减少数据库压力、提高应用响应速度、提高可扩展性。<br>memcached存储数据方式：key-value<br>Memcached有哪些优点：</p>
<ul>
<li>完全开源的项目</li>
<li>memcache服务类似于一张大的哈希表</li>
<li>通过内存缓存大大减少数据库压力</li>
<li>支持分布式缓存</li>
<li>是client-server类型的应用通过TCP或者UDP协议传输</li>
</ul>
<h2 id="Memcached原理分析"><a href="#Memcached原理分析" class="headerlink" title="Memcached原理分析"></a>Memcached原理分析</h2><p>Memcached提供了一个缓存机制，首先我们需要明白他的缓存原理，这有助于我们跟好的理解Memcached。</p>
<h3 id="内存管理方式"><a href="#内存管理方式" class="headerlink" title="内存管理方式"></a>内存管理方式</h3><p>Memcached采用名为<a href="https://en.wikipedia.org/wiki/Slab_allocation" target="_blank" rel="external">Slab Allocation</a>的机制分配管理内存.<br>Slab Allocation的原理是将分配的内存分割成各种尺寸的块（chunk）(具体是根据什么机制来分割的？是根据数据<br>存储大小分割？)，并把尺寸相同的块分成组（chunk的集合），每个chunk集合被称为slab。一些概念理解：</p>
<ul>
<li>Page :分配给Slab 的内存空间，默认是1MB。分配给Slab 之后根据slab 的大小切分成chunk.</li>
<li>Chunk : 用于缓存记录的内存空间.</li>
<li>Slab Class:特定大小的chunk 的组.</li>
</ul>
<h3 id="memcached分布式原理"><a href="#memcached分布式原理" class="headerlink" title="memcached分布式原理"></a>memcached分布式原理</h3><p>首先需要注意memcached是不相互通信的分布式，即一个节点down了那么该节点上的缓存就丢了，不会在其它<br>节点上找到该缓存信息。memcached的分布式实现主要依赖客户端实现:<br><img src="/images/memcached-distribution.jpg" alt=""><br>如上图所示，当数据到达客户端，客户端实现的算法就会根据“键”来决定保存的memcached服务器，服务器选定<br>后，命令他保存数据。取的时候也一样，客户端根据“键”选择服务器，使用保存时候的相同算法就能保证选中和<br>存的时候相同的服务器。<br>分布式存储支持多种算法：</p>
<ul>
<li>余数计算分散法</li>
<li>Consistent Hashing算法</li>
</ul>
<p>如果对算法感兴趣可以深入研究下😄.</p>
<h2 id="memcached连接查询"><a href="#memcached连接查询" class="headerlink" title="memcached连接查询"></a>memcached连接查询</h2><p>我们可以通过telnet命令连接到Memcached服务，并执行增删改查到操作。<br>语法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">telnet HOST PORT</div></pre></td></tr></table></figure></p>
<p>命令中的 HOST 和 PORT 为运行 Memcached 服务的 IP 和 端口。</p>
<h3 id="memcached存储命令"><a href="#memcached存储命令" class="headerlink" title="memcached存储命令"></a>memcached存储命令</h3><p>以下所有命令参数说明如下：</p>
<ul>
<li>key：键值 key-value 结构中的 key，用于查找缓存值。</li>
<li>flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 。</li>
<li>exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）</li>
<li>bytes：在缓存中存储的字节数</li>
<li>noreply（可选）： 该参数告知服务器不需要返回数据</li>
<li>value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value）</li>
</ul>
<h4 id="Memcached-set-命令"><a href="#Memcached-set-命令" class="headerlink" title="Memcached set 命令"></a><strong><em>Memcached set 命令</em></strong></h4><p>Memcached set 命令用于将<strong><em>value(数据值) </em></strong>存储在指定的 <strong><em>key(键)</em></strong> 中。<br>如果set的key已经存在，该命令可以更新该key所对应的原来的数据，也就是实现更新的作用。</p>
<p><font size="4">语法：</font><br>set 命令的基本语法格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> key flags exptime bytes [noreply]</div><div class="line">value</div></pre></td></tr></table></figure></p>
<h4 id="Memcached-add-命令"><a href="#Memcached-add-命令" class="headerlink" title="Memcached add 命令"></a><strong><em>Memcached add 命令</em></strong></h4><p>Memcached add 命令用于将 <strong><em>value(数据值)</em></strong> 存储在指定的 <strong><em>key(键)</em></strong> 中。<br>如果 add 的 key 已经存在，则不会更新数据，之前的值将仍然保持相同，并且您将获得响应 NOT_STORED。</p>
<p><font size="4">语法：</font><br>add 命令的基本语法格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">add key flags exptime bytes [noreply]</div><div class="line">value</div></pre></td></tr></table></figure></p>
<h4 id="Memcached-replace-命令"><a href="#Memcached-replace-命令" class="headerlink" title="Memcached replace 命令"></a><strong><em>Memcached replace 命令</em></strong></h4><p>Memcached replace 命令用于替换已存在的 <strong><em>key(键)</em></strong> 的 <strong><em>value(数据值)</em></strong>。<br>如果 key 不存在，则替换失败，并且您将获得响应 NOT_STORED。</p>
<p><font size="4">语法：</font><br>replace 命令的基本语法格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">replace key flags exptime bytes [noreply]</div><div class="line">value</div></pre></td></tr></table></figure></p>
<h4 id="Memcached-append-命令"><a href="#Memcached-append-命令" class="headerlink" title="Memcached append 命令"></a><strong><em>Memcached append 命令</em></strong></h4><p>Memcached append 命令用于向已存在<strong><em>key(键)</em></strong> 的<strong><em>value(数据值)</em></strong> 后面追加数据 。</p>
<p><font size="4">语法：</font><br>append 命令的基本语法格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">append key flags exptime bytes [noreply]</div><div class="line">value</div></pre></td></tr></table></figure></p>
<h4 id="Memcached-prepend-命令"><a href="#Memcached-prepend-命令" class="headerlink" title="Memcached prepend 命令"></a><strong><em>Memcached prepend 命令</em></strong></h4><p>Memcached prepend 命令用于向已存在 <strong><em>key(键)</em></strong> 的<strong><em>value(数据值)</em></strong> 前面追加数据 。</p>
<p><font size="4">语法：</font><br>prepend 命令的基本语法格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">prepend key flags exptime bytes [noreply]</div><div class="line">value</div></pre></td></tr></table></figure></p>
<h4 id="Memcached-CAS-命令"><a href="#Memcached-CAS-命令" class="headerlink" title="Memcached CAS 命令"></a><strong><em>Memcached CAS 命令</em></strong></h4><p>Memcached CAS（Check-And-Set 或 Compare-And-Swap） 命令用于执行一个”检查并设置”的操作<br>它仅在当前客户端最后一次取值后，该key 对应的值没有被其他客户端修改的情况下， 才能够将值写入。<br>检查是通过cas_token参数进行的， 这个参数是Memcach指定给已经存在的元素的一个唯一的64位值。</p>
<p><font size="4">语法：</font><br>CAS 命令的基本语法格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cas key flags exptime bytes unique_cas_token [noreply]</div><div class="line">value</div></pre></td></tr></table></figure></p>
<h3 id="Memcached查找命令"><a href="#Memcached查找命令" class="headerlink" title="Memcached查找命令"></a>Memcached查找命令</h3><p>1.#### <strong><em>Memcached get 命令</em></strong><br>Memcached get 命令获取存储在<strong><em>key(键)</em></strong>中的<strong><em>value(数据值)</em></strong> ，如果 key 不存在，则返回空。</p>
<p><font size="4">语法：</font><br>get 命令的基本语法格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">get key</div></pre></td></tr></table></figure></p>
<p>多个 key 使用空格隔开，如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">get key1 key2 key3</div></pre></td></tr></table></figure></p>
<h4 id="Memcached-gets-命令"><a href="#Memcached-gets-命令" class="headerlink" title="Memcached gets 命令"></a><strong><em>Memcached gets 命令</em></strong></h4><p>Memcached gets 命令获取带有 CAS 令牌存 的<strong><em>value(数据值)</em></strong> ，如果 key 不存在，则返回空。</p>
<p><font size="4">语法：</font><br>gets 命令的基本语法格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gets key</div></pre></td></tr></table></figure></p>
<p>多个 key 使用空格隔开，如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gets key1 key2 key3</div></pre></td></tr></table></figure></p>
<h4 id="Memcached-delete-命令"><a href="#Memcached-delete-命令" class="headerlink" title="Memcached delete 命令"></a><strong><em>Memcached delete 命令</em></strong></h4><p>Memcached delete 命令用于删除已存在的<strong><em>key(键)</em></strong>。</p>
<p><font size="4">语法：</font><br>delete 命令的基本语法格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete key [noreply]</div></pre></td></tr></table></figure></p>
<h4 id="Memcached-incr-decr-命令"><a href="#Memcached-incr-decr-命令" class="headerlink" title="Memcached incr/decr 命令"></a><strong><em>Memcached incr/decr 命令</em></strong></h4><p>Memcached incr 与 decr 命令用于对已存在的<strong><em>key(键)</em></strong> 的数字值进行自增或自减操作。<br>incr 与 decr 命令操作的数据必须是十进制的32位无符号整数。<br>如果 key 不存在返回 NOT_FOUND，如果键的值不为数字，则返回 CLIENT_ERROR，其他错误返回 ERROR。</p>
<p><font size="5">incr 命令</font></p>
<p><font size="4">语法：</font><br>incr 命令的基本语法格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">incr key increment_value</div></pre></td></tr></table></figure></p>
<p>参数说明如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">key：键值 key-value 结构中的 key，用于查找缓存值。</div><div class="line">increment_value： 增加的数值。</div></pre></td></tr></table></figure></p>
<p><font size="5">decr 命令</font><br>decr 命令的基本语法格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">decr key decrement_value</div></pre></td></tr></table></figure></p>
<p>参数说明如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">key：键值 key-value 结构中的 key，用于查找缓存值。</div><div class="line">decrement_value： 减少的数值。</div></pre></td></tr></table></figure></p>
<h3 id="Memcached-统计命令"><a href="#Memcached-统计命令" class="headerlink" title="Memcached 统计命令"></a>Memcached 统计命令</h3><h4 id="Memcached-stats-命令"><a href="#Memcached-stats-命令" class="headerlink" title="Memcached stats 命令"></a><strong><em>Memcached stats 命令</em></strong></h4><p>Memcached stats 命令用于返回统计信息例如 PID(进程号)、版本号、连接数等。</p>
<p><font size="4">语法：</font><br>stats 命令的基本语法格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stats</div></pre></td></tr></table></figure></p>
<h4 id="Memcached-stats-items-命令"><a href="#Memcached-stats-items-命令" class="headerlink" title="Memcached stats items 命令"></a><strong><em>Memcached stats items 命令</em></strong></h4><p>Memcached stats items 命令用于显示各个 slab 中 item 的数目和存储时长(最后一次访问距离现在的秒数)。</p>
<p><font size="4">语法：</font><br>stats items 命令的基本语法格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stats items</div></pre></td></tr></table></figure></p>
<h4 id="Memcached-stats-slabs-命令"><a href="#Memcached-stats-slabs-命令" class="headerlink" title="Memcached stats slabs 命令"></a><strong><em>Memcached stats slabs 命令</em></strong></h4><p>Memcached stats slabs 命令用于显示各个slab的信息，包括chunk的大小、数目、使用情况等。</p>
<p><font size="4">语法：</font><br>stats slabs 命令的基本语法格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stats slabs</div></pre></td></tr></table></figure></p>
<h4 id="Memcached-stats-sizes-命令"><a href="#Memcached-stats-sizes-命令" class="headerlink" title="Memcached stats sizes 命令"></a><strong><em>Memcached stats sizes 命令</em></strong></h4><p>Memcached stats sizes 命令用于显示所有item的大小和个数。<br>该信息返回两列，第一列是 item 的大小，第二列是 item 的个数。</p>
<p><font size="4">语法：</font><br>stats sizes 命令的基本语法格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stats sizes</div></pre></td></tr></table></figure></p>
<h4 id="Memcached-stats-flush-all-命令"><a href="#Memcached-stats-flush-all-命令" class="headerlink" title="Memcached stats flush_all 命令"></a><strong><em>Memcached stats flush_all 命令</em></strong></h4><p>Memcached flush_all 命令用于用于清理缓存中的所有key=&gt;value(键=&gt;值) 对。<br>该命令提供了一个可选参数 time，用于在制定的时间后执行清理缓存操作。</p>
<p><font size="4">语法：</font><br>flush_all 命令的基本语法格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flush_all [time] [noreply]</div></pre></td></tr></table></figure></p>
<h3 id="如何查询memcached中某个slab-id-中的Items的key"><a href="#如何查询memcached中某个slab-id-中的Items的key" class="headerlink" title="如何查询memcached中某个slab id 中的Items的key?"></a><strong><em>如何查询memcached中某个slab id 中的Items的key?</em></strong></h3><p>首先用命令stats items查看items信息如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">stats items</div><div class="line">STAT items:1:number 1</div><div class="line">STAT items:1:age 10</div><div class="line">STAT items:1:evicted 0</div><div class="line">STAT items:1:evicted_nonzero 0</div><div class="line">STAT items:1:evicted_time 0</div><div class="line">STAT items:1:outofmemory 0</div><div class="line">STAT items:1:tailrepairs 0</div><div class="line">STAT items:1:reclaimed 0</div><div class="line">STAT items:1:expired_unfetched 0</div><div class="line">STAT items:1:evicted_unfetched 0</div><div class="line">STAT items:1:crawler_reclaimed 0</div><div class="line">STAT items:1:crawler_items_checked 0</div><div class="line">STAT items:1:lrutail_reflocked 0</div><div class="line">END</div></pre></td></tr></table></figure></p>
<p>从上面输出信息，在’items’后即是slab id ，我们知道了slab id就能查看这个slab中的items，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">stats cachedump 1 100</div><div class="line">ITEM scorpio [5 b; 1481607870 s]</div><div class="line">END</div></pre></td></tr></table></figure></p>
<p>从上面命令我们得到了所cache的key值，我们就可以通过该key值用stats get命令查询该key的值.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://memcached.org/" target="_blank" rel="external">https://memcached.org/</a><br><a href="https://www.tutorialspoint.com/memcached/memcached_replace_data.htm" target="_blank" rel="external">https://www.tutorialspoint.com/memcached/memcached_replace_data.htm</a><br><a href="http://blog.jobbole.com/101226/" target="_blank" rel="external">http://blog.jobbole.com/101226/</a><br><a href="http://www.cnblogs.com/sunniest/p/4437806.html" target="_blank" rel="external">http://www.cnblogs.com/sunniest/p/4437806.html</a><br><a href="http://stackoverflow.com/questions/19560150/get-all-keys-set-in-memcached" target="_blank" rel="external">http://stackoverflow.com/questions/19560150/get-all-keys-set-in-memcached</a></p>
]]></content>
      
        <categories>
            
            <category> Cache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Memcache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Iterm2 快捷键大全]]></title>
      <url>http://www.pisces.ml/2016/12/13/Iterm2-keyboard-shortcut/</url>
      <content type="html"><![CDATA[<p><img src="https://www.iterm2.com/img/logo.jpg" align="middle"><br>mac 中比较推荐使用iterms终端,提供了好多人性话操作。比如分屏,选中即复制等等(最重要的是开源免费的哦😄 )。安装方法很简单只需要去iterm2<a href="https://www.iterm2.com/" target="_blank" rel="external"><strong>官网</strong></a>下载软件包安装即可。</p>
<h2 id="Iterm2实用功能介绍"><a href="#Iterm2实用功能介绍" class="headerlink" title="Iterm2实用功能介绍"></a>Iterm2实用功能介绍</h2><p>主要实用功能(比较常见)：</p>
<ol>
<li>⌘ + 数字 在各个tab 标签直接来回切换</li>
<li>选择即复制 + 鼠标中键粘贴，这个很实用</li>
<li>⌘ + d 横着分屏 / ⌘ + shift + d 竖着分屏</li>
<li>ctrl + u 清空当前行，无论光标在什么位置</li>
<li>⌘ + shift + h 会列出剪切板历史</li>
</ol>
<p>具体更多的功能介绍可参考<a href="https://www.iterm2.com/features.html" target="_blank" rel="external"><strong>官方文档</strong></a>。里面详细介绍了Iterm2详细的功能大全。</p>
<h2 id="Iterm2常用快捷键"><a href="#Iterm2常用快捷键" class="headerlink" title="Iterm2常用快捷键"></a>Iterm2常用快捷键</h2><h3 id="标签快捷键"><a href="#标签快捷键" class="headerlink" title="标签快捷键"></a>标签快捷键</h3><p>新建标签：command + t<br>关闭标签：command + w<br>切换标签：command + 数字/ command + 左右方向键<br>切换全屏：command + enter<br>查找：command + f</p>
<h3 id="分屏快捷键"><a href="#分屏快捷键" class="headerlink" title="分屏快捷键"></a>分屏快捷键</h3><p>垂直分屏：command + d<br>水平分屏：command + shift + d<br>切换屏幕：command + option + 方向键/ command + [ 或 command + ]<br>查看历史命令：command + ;<br>查看剪贴板历史：command + shift + h</p>
<h3 id="终端通用快捷键"><a href="#终端通用快捷键" class="headerlink" title="终端通用快捷键"></a>终端通用快捷键</h3><p>清除当前行：ctrl + u<br>到行首：ctrl + a<br>到行尾：ctrl + e<br>前进后退：ctrl + f/b (相当于左右方向键)<br>上一条命令：ctrl + p<br>搜索命令历史：ctrl + r<br>删除当前光标的字符：ctrl + d<br>删除光标之前的字符：ctrl + h<br>删除光标之前的单词：ctrl + w<br>删除到文本末尾：ctrl + k<br>交换光标处文本：ctrl + t<br>清屏1：command + r<br>清屏2：ctrl + l</p>
]]></content>
      
        <categories>
            
            <category> Mac </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Iterm2 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql数据库备份与恢复]]></title>
      <url>http://www.pisces.ml/2016/11/15/mysql-backup/</url>
      <content type="html"><![CDATA[<p>工作当中有时需要对数据库进行备份与恢复，其实数据库对备份与恢复很简单，几条命令就搞定。<br>但是因为对该命令用的比较少，容易忘记。所以做个记录并且学习学习数据库命令操作。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>mysqldump为MySQL逻辑备份工具，产生一系列SQL语句，之后重新执行以产生备份的库、表及数据。<br>也可产生CSV、XML等格式的数据。适用于各类引擎的表。</p>
<h2 id="mysqldump备份逻辑思想"><a href="#mysqldump备份逻辑思想" class="headerlink" title="mysqldump备份逻辑思想"></a>mysqldump备份逻辑思想</h2><p>我们查看通过mysqldump命令默认备份导出的文件大概内容如下：<br>创建数据库判断语句-删除表-创建表-锁表-禁用索引-插入数据-启用索引-解锁表<br>备份文件内容如下所示：</p>
<blockquote>
<p>MySQL dump 10.13  Distrib 5.7.13, for osx10.11 (x86_64)</p>
<p>Host: localhost    Database: keystone<br>Server versio  5.7.13<br>/<em>!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT </em>/;<br>/<em>!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS </em>/;<br>/<em>!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION </em>/;<br>/<em>!40101 SET NAMES utf8 </em>/;<br>/<em>!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE </em>/;<br>/<em>!40103 SET TIME_ZONE=’+00:00’ </em>/;<br>/<em>!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 </em>/;<br>/<em>!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 </em>/;<br>/<em>!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=’NO_AUTO_VALUE_ON_ZERO’ </em>/;<br>/<em>!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 </em>/;</p>
<p>Table structure for table <code>domain</code></p>
<p>DROP TABLE IF EXISTS <code>domain</code>;<br>/<em>!40101 SET @saved_cs_client     = @@character_set_client </em>/;<br>/<em>!40101 SET character_set_client = utf8 </em>/;<br>CREATE TABLE <code>domain</code> (<br>  <code>id</code> varchar(64) NOT NULL,<br>  <code>name</code> varchar(64) NOT NULL,<br>  <code>enabled</code> tinyint(1) NOT NULL,<br>  <code>extra</code> text,<br>  PRIMARY KEY (<code>id</code>),<br>  UNIQUE KEY <code>ixu_domain_name</code> (<code>name</code>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br>/<em>!40101 SET character_set_client = @saved_cs_client </em>/;<br>/<em>!40103 SET TIME_ZONE=@OLD_TIME_ZONE </em>/;<br>/<em>!40101 SET SQL_MODE=@OLD_SQL_MODE </em>/;<br>/<em>!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS </em>/;<br>/<em>!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS </em>/;<br>/<em>!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT </em>/;<br>/<em>!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS </em>/;<br>/<em>!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION </em>/;<br>/<em>!40111 SET SQL_NOTES=@OLD_SQL_NOTES </em>/;<br>Dump completed on 2016-11-15 22:36:38</p>
</blockquote>
<p>备份的逻辑就是将表结构以及数据变成sql语句保存下来，恢复的时候只需要在mysql中执行这些命令就行了。</p>
<h2 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h2><p><strong>备份一个或者多个表</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mysqldump -u 用户名 -p (密码) [option] db_name [table_1 table_2] &gt; xxx.sql</div></pre></td></tr></table></figure></p>
<p><strong>备份多个数据库</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mysqldump -u 用户名 -p (密码) [option] --databases db_name_1 db_name_2 ... &gt; xxx.sql</div></pre></td></tr></table></figure></p>
<p><strong>备份所有数据库</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mysqldump -u 用户名 -p (密码) [option] --all-databases &gt; xxx.sql</div></pre></td></tr></table></figure></p>
<p><strong>只备份表结构</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mysqldump --no-data/<span class="_">-d</span> --databases mdb_name_1 db_name_2 ...&gt; xxx.sql</div></pre></td></tr></table></figure></p>
<p><strong>条件导出数据</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mysqldump -u 用户名 -p db_name a1 --where=<span class="string">'id="xxxxxxxxxxx"'</span> &gt; xxx.sql</div></pre></td></tr></table></figure></p>
<p><strong>跨服务器导出导入数据</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mysqldump --host=host_id_1 -u 用户名 -p (密码) -C db_name_1 | mysql --host=host_id_2 -u 用户名 -p (密码) db_name_2</div><div class="line">$ 该命令的意思是将主机1的数据库1倒入到主机2的数据库2中, 其中-C参数是启用压缩传递</div></pre></td></tr></table></figure></p>
<p>以上命令是我们备份数据库中经常用到对，还有好多命令我们不一一列出，想了解跟多关于该命令的使用我们可以<br>使用帮助命令查看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ man mysqldump or mysqldump --help</div></pre></td></tr></table></figure></p>
<h2 id="如何恢复？"><a href="#如何恢复？" class="headerlink" title="如何恢复？"></a>如何恢复？</h2><p>当我们通过mysqldump命令备份了数据库后我们需要如何恢复？根据如上命令的语法，理所当然的我以为恢复就是逆向，将符号’&gt;’ 换成’&lt;’就ok了。<br>然而结果就是我想多了😢😢，所以我上面特别先讲了mysqldump备份逻辑，当你明白备份逻辑后明显如果使用mysqldump命令是无法进行数据恢复的。<br>正确恢复应该是如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mysql -u 用户名 -p (密码) &lt; xxx.sql</div></pre></td></tr></table></figure></p>
<h2 id="附件：（中文帮助文档）"><a href="#附件：（中文帮助文档）" class="headerlink" title="附件：（中文帮助文档）"></a>附件：（中文帮助文档）</h2><p>–all-databases , -A<br>导出全部数据库。<br>mysqldump -uroot -p –all-databases<br>–all-tablespaces , -Y<br>导出全部表空间。<br>mysqldump -uroot -p –all-databases –all-tablespaces<br>–no-tablespaces , -y<br>不导出任何表空间信息。<br>mysqldump -uroot -p –all-databases –no-tablespaces<br>–add-drop-database<br>每个数据库创建之前添加drop数据库语句。<br>mysqldump -uroot -p –all-databases –add-drop-database<br>–add-drop-table<br>每个数据表创建之前添加drop数据表语句。(默认为打开状态，使用–skip-add-drop-table取消选项)<br>mysqldump -uroot -p –all-databases (默认添加drop语句)<br>mysqldump -uroot -p –all-databases –skip-add-drop-table (取消drop语句)<br>–add-locks<br>在每个表导出之前增加LOCK TABLES并且之后UNLOCK TABLE。(默认为打开状态，使用–skip-add-locks取消选项)<br>mysqldump -uroot -p –all-databases (默认添加LOCK语句)<br>mysqldump -uroot -p –all-databases –skip-add-locks (取消LOCK语句)<br>–allow-keywords<br>允许创建是关键词的列名字。这由表名前缀于每个列名做到。<br>mysqldump -uroot -p –all-databases –allow-keywords<br>–apply-slave-statements<br>在’CHANGE MASTER’前添加’STOP SLAVE’，并且在导出的最后添加’START SLAVE’。<br>mysqldump -uroot -p –all-databases –apply-slave-statements<br>–character-sets-dir<br>字符集文件的目录<br>mysqldump -uroot -p –all-databases –character-sets-dir=/usr/local/mysql/share/mysql/charsets<br>–comments<br>附加注释信息。默认为打开，可以用–skip-comments取消<br>mysqldump -uroot -p –all-databases (默认记录注释)<br>mysqldump -uroot -p –all-databases –skip-comments (取消注释)<br>–compatible<br>导出的数据将和其它数据库或旧版本的MySQL 相兼容。值可以为ansi、mysql323、mysql40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options、no_field_options等，<br>要使用几个值，用逗号将它们隔开。它并不保证能完全兼容，而是尽量兼容。<br>mysqldump -uroot -p –all-databases –compatible=ansi<br>–compact<br>导出更少的输出信息(用于调试)。去掉注释和头尾等结构。可以使用选项：–skip-add-drop-table –skip-add-locks –skip-comments –skip-disable-keys<br>mysqldump -uroot -p –all-databases –compact<br>–complete-insert, -c<br>使用完整的insert语句(包含列名称)。这么做能提高插入效率，但是可能会受到max_allowed_packet参数的影响而导致插入失败。<br>mysqldump -uroot -p –all-databases –complete-insert<br>–compress, -C<br>在客户端和服务器之间启用压缩传递所有信息<br>mysqldump -uroot -p –all-databases –compress<br>–create-options, -a<br>在CREATE TABLE语句中包括所有MySQL特性选项。(默认为打开状态)<br>mysqldump -uroot -p –all-databases<br>–databases, -B<br>导出几个数据库。参数后面所有名字参量都被看作数据库名。<br>mysqldump -uroot -p –databases test mysql<br>–debug<br>输出debug信息，用于调试。默认值为：d:t,/tmp/mysqldump.trace<br>mysqldump -uroot -p –all-databases –debug<br>mysqldump -uroot -p –all-databases –debug=” d:t,/tmp/debug.trace”<br>–debug-check<br>检查内存和打开文件使用说明并退出。<br>mysqldump -uroot -p –all-databases –debug-check<br>–debug-info<br>输出调试信息并退出<br>mysqldump -uroot -p –all-databases –debug-info<br>–default-character-set<br>设置默认字符集，默认值为utf8<br>mysqldump -uroot -p –all-databases –default-character-set=utf8<br>–delayed-insert<br>采用延时插入方式（INSERT DELAYED）导出数据<br>mysqldump -uroot -p –all-databases –delayed-insert<br>–delete-master-logs<br>master备份后删除日志. 这个参数将自动激活–master-data。<br>mysqldump -uroot -p –all-databases –delete-master-logs<br>–disable-keys<br>对于每个表，用/<em>!40000 ALTER TABLE tbl_name DISABLE KEYS </em>/;和/<em>!40000 ALTER TABLE tbl_name ENABLE KEYS </em>/;语句引用INSERT语句。这样可以更快地导入dump出来的文件，因为它是在插入所有行后创建索引的。该选项只适合MyISAM表，默认为打开状态。<br>mysqldump -uroot -p –all-databases<br>–dump-slave<br>该选项将主的binlog位置和文件名追加到导出数据的文件中(show slave status)。设置为1时，将会以CHANGE MASTER命令输出到数据文件；设置为2时，会在change前加上注释。该选项将会打开–lock-all-tables，除非–single-transaction被指定。该选项会自动关闭–lock-tables选项。默认值为0。<br>mysqldump -uroot -p –all-databases –dump-slave=1<br>mysqldump -uroot -p –all-databases –dump-slave=2 –master-data<br>该选项将当前服务器的binlog的位置和文件名追加到输出文件中(show master status)。如果为1，将会输出CHANGE MASTER 命令；如果为2，输出的CHANGE MASTER命令前添加注释信息。该选项将打开–lock-all-tables 选项，除非–single-transaction也被指定（在这种情况下，全局读锁在开始导出时获得很短的时间；其他内容参考下面的–single-transaction选项）。该选项自动关闭–lock-tables选项。<br>mysqldump -uroot -p –host=localhost –all-databases –master-data=1;<br>mysqldump -uroot -p –host=localhost –all-databases –master-data=2; –events, -E<br>导出事件。<br>mysqldump -uroot -p –all-databases –events<br>–extended-insert, -e<br>使用具有多个VALUES列的INSERT语法。这样使导出文件更小，并加速导入时的速度。默认为打开状态，使用–skip-extended-insert取消选项。<br>mysqldump -uroot -p –all-databases<br>mysqldump -uroot -p –all-databases–skip-extended-insert (取消选项)<br>–fields-terminated-by<br>导出文件中忽略给定字段。与–tab选项一起使用，不能用于–databases和–all-databases选项<br>mysqldump -uroot -p test test –tab=”/home/mysql” –fields-terminated-by=”#”<br>–fields-enclosed-by<br>输出文件中的各个字段用给定字符包裹。与–tab选项一起使用，不能用于–databases和–all-databases选项<br>mysqldump -uroot -p test test –tab=”/home/mysql” –fields-enclosed-by=”#”<br>–fields-optionally-enclosed-by<br>输出文件中的各个字段用给定字符选择性包裹。与–tab选项一起使用，不能用于–databases和–all-databases选项<br>mysqldump -uroot -p test test –tab=”/home/mysql” –fields-enclosed-by=”#” –fields-optionally-enclosed-by =”#”<br>–fields-escaped-by<br>输出文件中的各个字段忽略给定字符。与–tab选项一起使用，不能用于–databases和–all-databases选项<br>mysqldump -uroot -p mysql user –tab=”/home/mysql” –fields-escaped-by=”#”<br>–flush-logs<br>开始导出之前刷新日志。<br>请注意：假如一次导出多个数据库(使用选项–databases或者–all-databases)，将会逐个数据库刷新日志。除使用–lock-all-tables或者–master-data外。在这种情况下，日志将会被刷新一次，相应的所以表同时被锁定。因此，如果打算同时导出和刷新日志应该使用–lock-all-tables 或者–master-data 和–flush-logs。<br>mysqldump -uroot -p –all-databases –flush-logs<br>–flush-privileges<br>在导出mysql数据库之后，发出一条FLUSH PRIVILEGES 语句。为了正确恢复，该选项应该用于导出mysql数据库和依赖mysql数据库数据的任何时候。<br>mysqldump -uroot -p –all-databases –flush-privileges<br>–force<br>在导出过程中忽略出现的SQL错误。<br>mysqldump -uroot -p –all-databases –force<br>–help<br>显示帮助信息并退出。<br>mysqldump –help<br>–hex-blob<br>使用十六进制格式导出二进制字符串字段。如果有二进制数据就必须使用该选项。影响到的字段类型有BINARY、VARBINARY、BLOB。<br>mysqldump -uroot -p –all-databases –hex-blob<br>–host, -h<br>需要导出的主机信息<br>mysqldump -uroot -p –host=localhost –all-databases<br>–ignore-table<br>不导出指定表。指定忽略多个表时，需要重复多次，每次一个表。每个表必须同时指定数据库和表名。例如：–ignore-table=database.table1 –ignore-table=database.table2 ……<br>mysqldump -uroot -p –host=localhost –all-databases –ignore-table=mysql.user<br>–include-master-host-port<br>在–dump-slave产生的’CHANGE MASTER TO..’语句中增加’MASTER_HOST=<host>，MASTER_PORT=<port>‘<br>mysqldump -uroot -p –host=localhost –all-databases –include-master-host-port<br>–insert-ignore<br>在插入行时使用INSERT IGNORE语句.<br>mysqldump -uroot -p –host=localhost –all-databases –insert-ignore<br>–lines-terminated-by<br>输出文件的每行用给定字符串划分。与–tab选项一起使用，不能用于–databases和–all-databases选项。<br>mysqldump -uroot -p –host=localhost test test –tab=”/tmp/mysql” –lines-terminated-by=”##”<br>–lock-all-tables, -x<br>提交请求锁定所有数据库中的所有表，以保证数据的一致性。这是一个全局读锁，并且自动关闭–single-transaction 和–lock-tables 选项。<br>mysqldump -uroot -p –host=localhost –all-databases –lock-all-tables<br>–lock-tables, -l<br>开始导出前，锁定所有表。用READ LOCAL锁定表以允许MyISAM表并行插入。对于支持事务的表例如InnoDB和BDB，–single-transaction是一个更好的选择，因为它根本不需要锁定表。<br>请注意当导出多个数据库时，–lock-tables分别为每个数据库锁定表。因此，该选项不能保证导出文件中的表在数据库之间的逻辑一致性。不同数据库表的导出状态可以完全不同。<br>mysqldump -uroot -p –host=localhost –all-databases –lock-tables<br>–log-error<br>附加警告和错误信息到给定文件<br>mysqldump -uroot -p –host=localhost –all-databases –log-error=/tmp/mysqldump_error_log.err<br>–max_allowed_packet<br>服务器发送和接受的最大包长度。<br>mysqldump -uroot -p –host=localhost –all-databases –max_allowed_packet=10240<br>–net_buffer_length<br>TCP/IP和socket连接的缓存大小。<br>mysqldump -uroot -p –host=localhost –all-databases –net_buffer_length=1024<br>–no-autocommit<br>使用autocommit/commit 语句包裹表。<br>mysqldump -uroot -p –host=localhost –all-databases –no-autocommit<br>–no-create-db, -n<br>只导出数据，而不添加CREATE DATABASE 语句。<br>mysqldump -uroot -p –host=localhost –all-databases –no-create-db<br>–no-create-info, -t<br>只导出数据，而不添加CREATE TABLE 语句。<br>mysqldump -uroot -p –host=localhost –all-databases –no-create-info<br>–no-data, -d<br>不导出任何数据，只导出数据库表结构。<br>mysqldump -uroot -p –host=localhost –all-databases –no-data<br>–no-set-names, -N<br>等同于–skip-set-charset<br>mysqldump -uroot -p –host=localhost –all-databases –no-set-names<br>–opt<br>等同于–add-drop-table, –add-locks, –create-options, –quick, –extended-insert, –lock-tables, –set-charset, –disable-keys 该选项默认开启, 可以用–skip-opt禁用.<br>mysqldump -uroot -p –host=localhost –all-databases –opt<br>–order-by-primary<br>如果存在主键，或者第一个唯一键，对每个表的记录进行排序。在导出MyISAM表到InnoDB表时有效，但会使得导出工作花费很长时间。<br>mysqldump -uroot -p –host=localhost –all-databases –order-by-primary<br>–password, -p<br>连接数据库密码<br>–pipe(windows系统可用)<br>使用命名管道连接mysql<br>mysqldump -uroot -p –host=localhost –all-databases –pipe<br>–port, -P<br>连接数据库端口号<br>–protocol<br>使用的连接协议，包括：tcp, socket, pipe, memory.<br>mysqldump -uroot -p –host=localhost –all-databases –protocol=tcp<br>–quick, -q<br>不缓冲查询，直接导出到标准输出。默认为打开状态，使用–skip-quick取消该选项。<br>mysqldump -uroot -p –host=localhost –all-databases<br>mysqldump -uroot -p –host=localhost –all-databases –skip-quick<br>–quote-names,-Q<br>使用（`）引起表和列名。默认为打开状态，使用–skip-quote-names取消该选项。<br>mysqldump -uroot -p –host=localhost –all-databases<br>mysqldump -uroot -p –host=localhost –all-databases –skip-quote-names<br>–replace<br>使用REPLACE INTO 取代INSERT INTO.<br>mysqldump -uroot -p –host=localhost –all-databases –replace<br>–result-file, -r<br>直接输出到指定文件中。该选项应该用在使用回车换行对（\r\n）换行的系统上（例如：DOS，Windows）。该选项确保只有一行被使用。<br>mysqldump -uroot -p –host=localhost –all-databases –result-file=/tmp/mysqldump_result_file.txt<br>–routines, -R<br>导出存储过程以及自定义函数。<br>mysqldump -uroot -p –host=localhost –all-databases –routines<br>–set-charset<br>添加’SET NAMES default_character_set’到输出文件。默认为打开状态，使用–skip-set-charset关闭选项。<br>mysqldump -uroot -p –host=localhost –all-databases<br>mysqldump -uroot -p –host=localhost –all-databases –skip-set-charset<br>–single-transaction<br>该选项在导出数据之前提交一个BEGIN SQL语句，BEGIN 不会阻塞任何应用程序且能保证导出时数据库的一致性状态。它只适用于多版本存储引擎，仅InnoDB。本选项和–lock-tables 选项是互斥的，因为LOCK TABLES 会使任何挂起的事务隐含提交。要想导出大表的话，应结合使用–quick 选项。<br>mysqldump -uroot -p –host=localhost –all-databases –single-transaction<br>–dump-date<br>将导出时间添加到输出文件中。默认为打开状态，使用–skip-dump-date关闭选项。<br>mysqldump -uroot -p –host=localhost –all-databases<br>mysqldump -uroot -p –host=localhost –all-databases –skip-dump-date<br>–skip-opt<br>禁用–opt选项.<br>mysqldump -uroot -p –host=localhost –all-databases –skip-opt<br>–socket,-S<br>指定连接mysql的socket文件位置，默认路径/tmp/mysql.sock<br>mysqldump -uroot -p –host=localhost –all-databases –socket=/tmp/mysqld.sock<br>–tab,-T<br>为每个表在给定路径创建tab分割的文本文件。注意：仅仅用于mysqldump和mysqld服务器运行在相同机器上。<br>mysqldump -uroot -p –host=localhost test test –tab=”/home/mysql”<br>–tables<br>覆盖–databases (-B)参数，指定需要导出的表名。<br>mysqldump -uroot -p –host=localhost –databases test –tables test<br>–triggers<br>导出触发器。该选项默认启用，用–skip-triggers禁用它。<br>mysqldump -uroot -p –host=localhost –all-databases –triggers<br>–tz-utc<br>在导出顶部设置时区TIME_ZONE=’+00:00’ ，以保证在不同时区导出的TIMESTAMP 数据或者数据被移动其他时区时的正确性。<br>mysqldump -uroot -p –host=localhost –all-databases –tz-utc<br>–user, -u<br>指定连接的用户名。<br>–verbose, –v<br>输出多种平台信息。<br>–version, -V<br>输出mysqldump版本信息并退出<br>–where, -w<br>只转储给定的WHERE条件选择的记录。请注意如果条件包含命令解释符专用空格或字符，一定要将条件引用起来。<br>mysqldump -uroot -p –host=localhost –all-databases –where=” user=’root’”<br>–xml, -X<br>导出XML格式.<br>mysqldump -uroot -p –host=localhost –all-databases –xml<br>–plugin_dir<br>客户端插件的目录，用于兼容不同的插件版本。<br>mysqldump -uroot -p –host=localhost –all-databases –plugin_dir=”/usr/local/lib/plugin”<br>–default_auth<br>客户端插件默认使用权限。<br>mysqldump -uroot -p –host=localhost –all-databases –default-auth=”/u</port></host></p>
<blockquote>
<p>参考文档：<br><a href="http://dev.mysql.com/doc/refman/5.6/en/mysqldump.html#option_mysqldump_protocol" target="_blank" rel="external">http://dev.mysql.com/doc/refman/5.6/en/mysqldump.html#option_mysqldump_protocol</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Database </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vim快捷键整理]]></title>
      <url>http://www.pisces.ml/2016/10/14/linux-shortcut-key/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Vim是Mac OS和Linux里内置的一款强大的文本编辑器，能够和Shell无缝交互。同时也是SSH远程登录VPS时编辑文件的唯一选择。因此掌握Vim对于做服务器运维和Web后端开发的重要性不言而喻。<br>本文对Vim的快捷键操作进行了简单整理。</p>
</blockquote>
<p>Vim常见有两种模式一种是Insert模式，该模式下可以像其它文本编辑器一样正常输入字符；另一种是Normal模式，该模式下Vim监听用户的按键可以对文本进行快速修改。<br>想要从Insert模式切换到Normal模式只需按下ESC键即可。<br>想要从Normal模式切换到Insert模式，有很多方法。<br>最直接的是按下I键，效果是：在当前光标处插入文本。<br>如果按下A键，效果是：在下一光标处追加文本。<br>以下均是在Normal模式下的部分 快捷键说明：</p>
<h2 id="光标的快速移动"><a href="#光标的快速移动" class="headerlink" title="光标的快速移动"></a>光标的快速移动</h2><ul>
<li>h,j,k,l：左，下，上，右</li>
<li>w：光标移动至下一单词首位</li>
<li>b：光标移动至当前单词首位，如果光标已经在当前单词首位，就移动到前一单词首位</li>
<li>e：光标移动至当前单词末位</li>
<li>gg：光标移动至文本首行</li>
<li>Shift+g：光标移动至文本尾行</li>
<li>27+Shift+g：光标移动至文本第27行<h2 id="光标跳转"><a href="#光标跳转" class="headerlink" title="光标跳转"></a>光标跳转</h2></li>
<li>%: 可以匹配{},””,(),[]之间跳转。</li>
<li>H、M、L：直接跳转到当前屏幕的顶部、中部、底部。</li>
<li>#H：跳转到当前屏的第#行。</li>
<li>#L：跳转到当前屏的倒数第#行。</li>
<li>zt: 当前编辑行置为屏顶。</li>
<li>zz: 当前编辑行置为屏中。</li>
<li>zb: 当前编辑行置为屏底。</li>
<li>G：直接跳转到文件的底部。</li>
<li>gg: 跳转到文件首。</li>
<li>():跳转到当前的行首、行尾。</li>
<li>{}：向上、向下跳转到最近的空行。</li>
<li>[{：跳转到目前区块开头。</li>
<li>]}：跳转到目前区块结尾。</li>
<li>0: 跳转到行首。</li>
<li>$: 跳转到行尾。</li>
<li>2$: 跳转到下一行的行尾。</li>
<li>#G: 15G,跳转到15行。</li>
<li>:#：跳转到#行。</li>
<li>f’n’：跳转到下一个”n”字母后。</li>
<li>ctrl+b: 向后翻一页。</li>
<li>ctrl+f：向前翻一页。</li>
<li>ctrl+u: 向后翻半页。</li>
<li>ctrl+d: 向前翻半页。</li>
<li>ctry+e: 下滚一行。<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2></li>
<li>V: 选择一行。</li>
<li>^v: 矩形选择。</li>
<li>v3w: 选择三个字符<h2 id="插入行"><a href="#插入行" class="headerlink" title="插入行"></a>插入行</h2></li>
<li>i: 光标前插入。</li>
<li>I: 在当前行首插入。</li>
<li>a: 光标后插入。</li>
<li>A: 当前行尾插入。</li>
<li>O: 在当前行之前插入新行。</li>
<li>o: 在当前行之后插入新行。<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2></li>
<li>r: 替换光标所在处的字符。</li>
<li>R：替换光标所到之处的字符。</li>
<li>cw: 更改光标所在处的字到字尾处。</li>
<li>c#w: c3w 修改3个字符。</li>
<li>C：修改到行尾。</li>
<li>ci’：修改配对标点符号中的文本内容。</li>
<li>di’：删除配对标点符号中的文本内容。</li>
<li>yi’：复制配对标点符号中的文本内容。</li>
<li>vi’：选中配对标点符号中的文本内容。</li>
<li>s：替换当前一个光标所处字符。</li>
<li>#S：删除 # 行，并以新文本代替。<h2 id="删除与还原"><a href="#删除与还原" class="headerlink" title="删除与还原"></a>删除与还原</h2></li>
<li>u：还原上一个操作（不限于删除）</li>
<li>D：删除到行尾。</li>
<li>X: 每按一次，删除光标所在位置的前面一个字符。</li>
<li>x: 每按一次，删除光标所在位置的后面一个字符。</li>
<li>#x: 删除光标所在位置后面6个字符。</li>
<li>d^: 删至行首。</li>
<li>d$: 删至行尾。</li>
<li>dd:(剪切)删除光标所在行。</li>
<li>de：删除光标后的单词内容，同时被删除内容存于剪贴板上</li>
<li>dw: 删除一个单词/光标之后的单词剩余部分。</li>
<li>d4w: 删除4个word。</li>
<li>#dd: 从光标所在行开始删除#行。</li>
<li>daB: 删除{}及其内的内容。</li>
<li>diB: 删除{}中的内容。</li>
<li>n1,n2 d：将n1,n2行之间的内容删除。<h2 id="剪切、复制与粘贴"><a href="#剪切、复制与粘贴" class="headerlink" title="剪切、复制与粘贴"></a>剪切、复制与粘贴</h2></li>
<li>选定文本块：使用v进入可视模式；移动光标键选定内容</li>
<li>y：复制选定块</li>
<li>yy：复制光标所在整行</li>
<li>d：剪切选定块</li>
<li>dd：剪切光标所在整行</li>
<li>p：粘贴文本<h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2></li>
<li>gUU: 将当前行的字母改为大写。</li>
<li>guu: 将当前行的字母改为小写。</li>
<li>gUw: 将当前光标下的单词改为大写。</li>
<li>guw: 将当前光标下的单词改为小写。</li>
<li>ggguG: 整篇大写</li>
<li>gg: 光标到文件第一个字符。</li>
<li>gu: 把选择范围全部小写。</li>
<li>G: 到文件结束。</li>
<li>gggUG: 整篇小写：<h2 id="查找与替换"><a href="#查找与替换" class="headerlink" title="查找与替换"></a>查找与替换</h2></li>
<li>f+o：在当前行的光标之后查找字母o</li>
<li>F+b：在当前行的光标之前查找字母b</li>
<li>:/word：全文查找word。 按下:实际上是进入了Vim的命令模式。查找操作支持正则表达式。</li>
<li>r+p：将光标之后的字符替换为字母p</li>
<li>:s/word/replace：光标所在行的第一个word替换为replace。</li>
<li>:%s/from/to/：全文查找from并替换为to。</li>
<li>:1,50s/from/to/：在第1行和第50行之间（含）进行搜索和替换。</li>
<li>:45s/from/to/表示仅仅在第45行进行搜索和替换。而1,$行号范围和%是等价的。</li>
<li>:%s/from/to/g：全文查找from并替换为to,包含选项g的替换范围更广。</li>
<li>:%s/from/to/gc：全文查找from并替换为to，替换时询问。可以选择y/n/a/q/l/^E/^Y：y表示同意当前替换；n表示不同意当前替换；a表示替换当前和后面的并且不再确认；q表示立即结束替换操作；l表示把当前的替换后结束替换操作；^E向上滚屏^Y向下滚屏，用来帮助查看前后内容以决定进行操作。<h2 id="执行Shell命令"><a href="#执行Shell命令" class="headerlink" title="执行Shell命令"></a>执行Shell命令</h2></li>
<li>:!ls就等同于在Shell终端执行ls命令。<br>—————————————————–分割线————————————————<blockquote>
<p>原文参考链接：<a href="http://www.jianshu.com/p/c23136f68d2f" target="_blank" rel="external">http://www.jianshu.com/p/c23136f68d2f</a></p>
</blockquote>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jekyll 常用变量]]></title>
      <url>http://www.pisces.ml/2016/07/22/jekyll-Variables/</url>
      <content type="html"><![CDATA[<h2 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h2><p>Jekyll 会遍历你的网站搜寻要处理的文件。任何有 YAML 头信息的文件都是要处理的对象。对于每一个这样的文件，Jekyll 都会通过 Liquid 模板工具来生成一系列的数据。下面就是这些可用数据变量的参考和文档。</p>
<h3 id="全局-Global-变量"><a href="#全局-Global-变量" class="headerlink" title="全局(Global)变量"></a>全局(Global)变量</h3><table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">site</td>
<td style="text-align:center">来自_config.yml文件，全站范围的信息+配置。详细的信息请参考下文</td>
</tr>
<tr>
<td style="text-align:center">page</td>
<td style="text-align:center">页面专属的信息 + YAML 头文件信息。通过 YAML 头文件自定义的信息都可以在这里被获取。详情请参考下文。</td>
</tr>
<tr>
<td style="text-align:center">content</td>
<td style="text-align:center">被 layout 包裹的那些 Post 或者 Page 渲染生成的内容。但是又没定义在 Post 或者 Page 文件中的变量。</td>
</tr>
<tr>
<td style="text-align:center">paginator</td>
<td style="text-align:center">每当 paginate 配置选项被设置了的时候，这个变量就可用了。详情请看<a href="http://jekyllcn.com/docs/pagination/" target="_blank" rel="external">分页</a>。</td>
</tr>
</tbody>
</table>
<h3 id="全站-site-变量"><a href="#全站-site-变量" class="headerlink" title="全站(site)变量"></a>全站(site)变量</h3><table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">site.time</td>
<td style="text-align:center">当前时间（运行jekyll这个命令的时间点）。</td>
</tr>
<tr>
<td style="text-align:center">site.pages</td>
<td style="text-align:center">所有 Pages 的清单。</td>
</tr>
<tr>
<td style="text-align:center">site.posts</td>
<td style="text-align:center">一个按照时间倒序的所有 Posts 的清单。</td>
</tr>
<tr>
<td style="text-align:center">site.related_posts</td>
<td style="text-align:center">如果当前被处理的页面是一个 Post，这个变量就会包含最多10个相关的 Post。默认的情况下，相关性是低质量的，但是能被很快的计算出来。如果你需要高相关性，就要消耗更多的时间来计算。用 jekyll 这个命令带上 –lsi (latent semantic indexing) 选项来计算高相关性的 Post。注意，GitHub 在生成站点时不支持　lsi。</td>
</tr>
<tr>
<td style="text-align:center">site.static_files</td>
<td style="text-align:center">静态文件的列表 (此外的文件不会被 Jekyll 和 Liquid 处理。)。每个文件都具有三个属性： path， modified_time 以及 extname。</td>
</tr>
<tr>
<td style="text-align:center">site.html_pages</td>
<td style="text-align:center">‘site.pages’的子集，存储以‘.html’结尾的部分。</td>
</tr>
<tr>
<td style="text-align:center">site.html_files</td>
<td style="text-align:center">‘site.static_files’的子集，存储以‘.html’结尾的部分。</td>
</tr>
<tr>
<td style="text-align:center">site.collections</td>
<td style="text-align:center">一个所有集合（collection）的清单。</td>
</tr>
<tr>
<td style="text-align:center">site.data</td>
<td style="text-align:center">一个存储了 _data 目录下的YAML文件数据的清单。</td>
</tr>
<tr>
<td style="text-align:center">site.documents</td>
<td style="text-align:center">每一个集合（collection）中的全部文件的清单。</td>
</tr>
<tr>
<td style="text-align:center">site.categories.CATEGORY</td>
<td style="text-align:center">所有的在 CATEGORY 类别下的帖子。</td>
</tr>
<tr>
<td style="text-align:center">site.tags.TAG</td>
<td style="text-align:center">所有的在 TAG 标签下的帖子。</td>
</tr>
<tr>
<td style="text-align:center">site.[CONFIGURATION_DATA]</td>
<td style="text-align:center">所有的通过命令行和 _config.yml 设置的变量都会存到这个 site 里面。 举例来说，如果你设置了 url: <a href="http://mysite.com" target="_blank" rel="external">http://mysite.com</a> 在你的配置文件中，那么在你的 Posts 和 Pages 里面，这个变量就被存储在了 site.url。Jekyll 并不会把对 _config.yml 做的改动放到 watch 模式，所以你每次都要重启 Jekyll 来让你的变动生效。</td>
</tr>
</tbody>
</table>
<h3 id="页面-page-变量"><a href="#页面-page-变量" class="headerlink" title="页面(page)变量"></a>页面(page)变量</h3><table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">page.content</td>
<td style="text-align:center">页面内容的源码。</td>
</tr>
<tr>
<td style="text-align:center">page.title</td>
<td style="text-align:center">页面的标题。</td>
</tr>
<tr>
<td style="text-align:center">page.excerpt</td>
<td style="text-align:center">页面摘要的源码。</td>
</tr>
<tr>
<td style="text-align:center">page.url</td>
<td style="text-align:center">帖子以斜线打头的相对路径，例子： /2008/12/14/my-post.html。</td>
</tr>
<tr>
<td style="text-align:center">page.date</td>
<td style="text-align:center">帖子的日期。日期的可以在帖子的头信息中通过用以下格式 YYYY-MM-DD HH:MM:SS (假设是 UTC), 或者 YYYY-MM-DD HH:MM:SS +/-TTTT ( 用于声明不同于 UTC 的时区， 比如 2008-12-14 10:30:00 +0900) 来显示声明其他 日期/时间 的方式被改写，</td>
</tr>
<tr>
<td style="text-align:center">page.id</td>
<td style="text-align:center">帖子的唯一标识码（在RSS源里非常有用），比如 /2008/12/14/my-post</td>
</tr>
<tr>
<td style="text-align:center">page.categories</td>
<td style="text-align:center">i这个帖子所属的 Categories。Categories 是从这个帖子的 _posts 以上 的目录结构中提取的。举例来说, 一个在 /work/code/_posts/2008-12-24-closures.md 目录下的 Post，这个属性就会被设置成 [‘work’, ‘code’]。不过 Categories 也能在 YAML 头文件信息 中被设置。</td>
</tr>
<tr>
<td style="text-align:center">page.tags</td>
<td style="text-align:center">i这个 Post 所属的所有 tags。Tags 是在YAML 头文件信息中被定义的。</td>
</tr>
<tr>
<td style="text-align:center">page.path</td>
<td style="text-align:center">Post 或者 Page 的源文件地址。举例来说，一个页面在 GitHub 上的源文件地址。 这可以在 YAML 头文件信息 中被改写。</td>
</tr>
<tr>
<td style="text-align:center">page.next</td>
<td style="text-align:center">当前文章在site.posts中的位置对应的下一篇文章。若当前文章为最后一篇文章，返回nil</td>
</tr>
<tr>
<td style="text-align:center">page.previous</td>
<td style="text-align:center">当前文章在site.posts中的位置对应的上一篇文章。若当前文章为第一篇文章，返回nil</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>提示™: 使用自定义的头信息</strong></p>
<blockquote>
<p>任何你自定义的头文件信息都会在 page 中可用。 举例来说，如果你在一个 Page 的头文件中设置了 custom_css: true， 这个变量就可以这样被取到 page.custom_css。</p>
<h3 id="分页器-Paginator"><a href="#分页器-Paginator" class="headerlink" title="分页器(Paginator)"></a>分页器(Paginator)</h3><table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">paginator.per_page</td>
<td style="text-align:center">每一页 Posts 的数量。</td>
</tr>
<tr>
<td style="text-align:center">paginator.posts</td>
<td style="text-align:center">这一页可用的 Posts。</td>
</tr>
<tr>
<td style="text-align:center">paginator.total_posts</td>
<td style="text-align:center">Posts 的总数。</td>
</tr>
<tr>
<td style="text-align:center">paginator.total_pages</td>
<td style="text-align:center">Pages 的总数。</td>
</tr>
<tr>
<td style="text-align:center">paginator.page</td>
<td style="text-align:center">当前页号。</td>
</tr>
<tr>
<td style="text-align:center">paginator.previous_page</td>
<td style="text-align:center">前一页的页号。</td>
</tr>
<tr>
<td style="text-align:center">paginator.previous_page_path</td>
<td style="text-align:center">前一页的地址。</td>
</tr>
<tr>
<td style="text-align:center">paginator.next_page</td>
<td style="text-align:center">下一页的页号。</td>
</tr>
<tr>
<td style="text-align:center">paginator.next_page_path</td>
<td style="text-align:center">下一页的地址。</td>
</tr>
</tbody>
</table>
<p><strong>分页器变量的可用性</strong><br>这些变量仅在首页文件中可用，不过他们也会存在于子目录中，就像 /blog/index.html。<br>本文转自：<a href="http://jekyllcn.com/docs/variables/" target="_blank" rel="external">http://jekyllcn.com/docs/variables/</a><br>仅供学习使用.</p>
</blockquote>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Soft </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jekyll </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Keystone对接ActiveDirectory]]></title>
      <url>http://www.pisces.ml/2016/06/02/keystone-AD/</url>
      <content type="html"><![CDATA[<p>keystone对接AD(ActiveDirectory)，本文记录对接配置过程</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AD，指Windows的Active Directory，是LDAP协议的另一个实现，Keystone也可以和AD进行对接。</p>
<h2 id="AD服务安装配置"><a href="#AD服务安装配置" class="headerlink" title="AD服务安装配置"></a>AD服务安装配置</h2><p>首先我们需要配置好AD，以用来对接keystone。</p>
<h3 id="安装AD服务"><a href="#安装AD服务" class="headerlink" title="安装AD服务"></a>安装AD服务</h3><p>在window server 中安装AD服务，该过程可参考（<a href="https://support.rackspace.com/how-to/installing-active-directory-on-windows-server-2012/）这里不再细说。" target="_blank" rel="external">https://support.rackspace.com/how-to/installing-active-directory-on-windows-server-2012/）这里不再细说。</a></p>
<h3 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h3><p>AD服务安装完成后会生成Users的容器，该容器存放用户的分组以及用户。如下图所示：<br><img src="/images/image2016-5-23-1.png" alt=""><br>当然对于keystone我们也可以使用这种模式，将用户和分组同时都放在容器Users中，但是这样做会显的很乱。一种做法是我们可以单独给用户生成一个类似的容器来存放所有用户信息，也给分组生成一个容器来存放所有分组(当然也可以根据客户现在的账户体系进行规划，这里只做示例用)，如下步骤所示分别建立两个容器来存放用户和分组：<br>第一步：在根目录ustack下点击新建，容器类型为‘组织单位’<br><img src="/images/image2016-5-23-2.png" alt=""><br>第二步：生成Keystone_Users容器<br><img src="/images/image2016-5-23-3.png" alt=""><br>同样的方式创建容器Keystone_Groups来存放分组，新建完成后如下所示：<br><img src="/images/mage2016-5-23-4.png" alt=""><br>完成之后我们需要在容器Keystone_Users和Keystone_Groups中分别创建用户和分组，示例（在Keystone_Users新建用户）：<br>进入容器Keystone_Users，右击新建－用户，填上必要的用户信息确认即可，如下图所示<br><img src="/images/image2016-5-23-5.png" alt=""><br>同样的方式可以建立相应的分组，并将用户添加到该分组中。</p>
<h2 id="keystone的安装和配置"><a href="#keystone的安装和配置" class="headerlink" title="keystone的安装和配置"></a>keystone的安装和配置</h2><h3 id="keysotne安装"><a href="#keysotne安装" class="headerlink" title="keysotne安装"></a>keysotne安装</h3><p>keystone安装过程主要是根据社区文档进行安装部署即可，参考：<br>SUSE: <a href="http://docs.openstack.org/mitaka/install-guide-obs/index.html" target="_blank" rel="external">http://docs.openstack.org/mitaka/install-guide-obs/index.html</a> 主要执行以下步骤来安装配置keystone</p>
<ol>
<li><a href="http://docs.openstack.org/mitaka/install-guide-obs/environment-packages.html" target="_blank" rel="external">添加软件源并安装包python-openstackclient</a></li>
<li><a href="http://docs.openstack.org/mitaka/install-guide-obs/environment-sql-database.html" target="_blank" rel="external">安装数据库</a></li>
<li><a href="http://docs.openstack.org/mitaka/install-guide-obs/environment-memcached.html" target="_blank" rel="external">安装memcache服务器</a></li>
<li><a href="http://docs.openstack.org/mitaka/install-guide-obs/keystone.html" target="_blank" rel="external">安装keystone</a><br>Ubuntu:<a href="http://docs.openstack.org/mitaka/install-guide-ubuntu/" target="_blank" rel="external">http://docs.openstack.org/mitaka/install-guide-ubuntu/</a><br>Red Hat Enterprise Linux 7 and CentOS7: <a href="http://docs.openstack.org/mitaka/install-guide-rdo/" target="_blank" rel="external">http://docs.openstack.org/mitaka/install-guide-rdo/</a><h3 id="keystone对接AD配置"><a href="#keystone对接AD配置" class="headerlink" title="keystone对接AD配置"></a>keystone对接AD配置</h3>第一步：source keystone证书文件openrc(v3版本)，该文件内容如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root@ldap:~# cat openrc_v3</div><div class="line">export OS_PROJECT_DOMAIN_NAME=default</div><div class="line">export OS_USER_DOMAIN_NAME=default</div><div class="line">export OS_PROJECT_NAME=admin</div><div class="line">export OS_USERNAME=admin</div><div class="line">export OS_PASSWORD=root</div><div class="line">export OS_AUTH_URL=http://127.0.0.1:35357/v3</div><div class="line">export OS_IDENTITY_API_VERSION=3</div><div class="line">export OS_IMAGE_API_VERSION=2</div></pre></td></tr></table></figure>
</li>
</ol>
<p>第二步：在路径’/etc/keystone/‘下创建domains目录，并修改用户权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">＃　新建目录</div><div class="line">mkdir /etc/keystone/domains/</div><div class="line">＃　修改权限</div><div class="line">chown keystone /etc/keystone/domains/</div></pre></td></tr></table></figure></p>
<p>第三步：修改配置文件keystone.conf，做如下修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 文件位置　/etc/keystone</div><div class="line">[identity]</div><div class="line">domain_specific_drivers_enabled = true</div><div class="line">domain_config_dir = /etc/keystone/domains</div><div class="line">[assignment]</div><div class="line">driver = keystone.assignment.backends.sql.Assignment</div></pre></td></tr></table></figure></p>
<p>第四步：查看AD server的NetBIOS name 作为AD DS的域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PS C:\&gt; Get-ADDomain | select NetBIOSName</div><div class="line">NetBIOSName</div><div class="line">-----------</div><div class="line">USTACK</div></pre></td></tr></table></figure></p>
<p>由上所示我们可以看到NetBIOS name 为USTACK<br>第五步：用openstack命令创建AD 用户域<br>使用上步骤得到的NetBIOSName作为keystone账户中的域名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openstack domain create  USTACK</div></pre></td></tr></table></figure></p>
<p>第五步：在/etc/keystone/domains/下创建文件keystone.USTACK.conf（注意该文件的命名必须格式keystone.{NetBIOSName}.conf）并做如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">[ldap]</div><div class="line">url = ldap://172.16.10.13</div><div class="line">user = cn=chengkun,cn=Users,dc=ustack,dc=test</div><div class="line">password = Ustack2016</div><div class="line">suffix = dc=ustack,dc=test</div><div class="line">user_tree_dn = cn=Users,dc=ustack,dc=test</div><div class="line"># user_filter = (memberOf=cn=ustack_admin,OU=UserGroups,DC=ustack,DC=test)</div><div class="line">user_objectclass = person</div><div class="line">user_id_attribute = sAMAccountName</div><div class="line">user_name_attribute = sAMAccountName</div><div class="line">user_mail_attribute = mail</div><div class="line">user_pass_attribute =</div><div class="line">user_enabled_attribute = userAccountControl</div><div class="line">user_enabled_mask = 2</div><div class="line">user_enabled_default = 512</div><div class="line">user_attribute_ignore = password,tenant_id,tenants</div><div class="line">user_allow_create = false</div><div class="line">user_allow_update = false</div><div class="line">user_allow_delete = false</div><div class="line">group_tree_dn = OU=UserGroups,DC=ustack,DC=test</div><div class="line"># group_tree_dn = cn=Users,dc=ustack,dc=test</div><div class="line">group_objectclass = group</div><div class="line">group_id_attribute = cn</div><div class="line">group_name_attribute = cn</div><div class="line">group_allow_create = False</div><div class="line">group_allow_update = False</div><div class="line">group_allow_delete = False</div><div class="line">[identity]</div><div class="line">driver = keystone.identity.backends.ldap.Identity</div></pre></td></tr></table></figure></p>
<p>注意上面配置的用户信息根据实际用户信息填写即可。<br>修改该文件权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chown keystone /etc/keystone/domains/keystone.LAB.conf</div></pre></td></tr></table></figure></p>
<p>第六步：给AD账户domain分配权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#查看domain id</div><div class="line">[root@localhost ~]# openstack domain show USTACK</div><div class="line">+---------+----------------------------------+</div><div class="line">| Field   | Value                            |</div><div class="line">+---------+----------------------------------+</div><div class="line">| enabled | True                             |</div><div class="line">| id      | 1954d71a8445418482b4d3966e6a8cfe |</div><div class="line">| name    | USTACK                           |</div><div class="line">+---------+----------------------------------+</div><div class="line">#查询admin用户id</div><div class="line">[root@localhost ~]# openstack user list --domain default | grep admin</div><div class="line">| 8ef5b603ae1344cea4fe060d198d42ad | admin |</div><div class="line">#给用户admin在domain USTACK中添加admin的role</div><div class="line">openstack role add --domain 1954d71a8445418482b4d3966e6a8cfe --user 8ef5b603ae1344cea4fe060d198d42ad admin</div><div class="line">#可以通过以下命令查看是否已经添加上</div><div class="line">[root@localhost ~]# openstack role assignment list | grep 1954d71a8445418482b4d3966e6a8cfe | grep 8ef5b603ae1344cea4fe060d198d42ad</div><div class="line">| 9d9bb1f3f9e84e999cc18f99fd901398 | 8ef5b603ae1344cea4fe060d198d42ad                                 |                                  |                                  | 1954d71a8445418482b4d3966e6a8cfe |</div></pre></td></tr></table></figure></p>
<p>第七步：重启keystone服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 注：如果keystone跑在httpd上，直接重启httpd服务即可</div><div class="line">systemctl restart openstack-keystone.service</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.hpcloud.com/commercial/GA1/1.1commerical.services-identity-integrate-ldap.html#topic9275__connect" target="_blank" rel="external">https://docs.hpcloud.com/commercial/GA1/1.1commerical.services-identity-integrate-ldap.html#topic9275__connect</a></li>
<li><a href="https://access.redhat.com/documentation/en/red-hat-enterprise-linux-openstack-platform/7/integrate-with-identity-service/chapter-1-active-directory-integration" target="_blank" rel="external">https://access.redhat.com/documentation/en/red-hat-enterprise-linux-openstack-platform/7/integrate-with-identity-service/chapter-1-active-directory-integration</a></li>
<li><a href="https://technet.microsoft.com/en-us/library/ee617195.aspx" target="_blank" rel="external">https://technet.microsoft.com/en-us/library/ee617195.aspx</a></li>
<li><a href="http://windowsitpro.com/powershell/top-10-active-directory-tasks-solved-powershell" target="_blank" rel="external">http://windowsitpro.com/powershell/top-10-active-directory-tasks-solved-powershell</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Openstack </category>
            
        </categories>
        
        
        <tags>
            
            <tag> keystone </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[tcpdump命令详解]]></title>
      <url>http://www.pisces.ml/2016/05/22/tcpdump-usage/</url>
      <content type="html"><![CDATA[<p>这篇文章主要是记录关于tcpdump的使用，tcpdump是常用的抓包工具，该工具可以灵活的抓取在网络中包传输。<br>（操作系统：ubuntu 15.04）</p>
<h2 id="tcpdump命令格式"><a href="#tcpdump命令格式" class="headerlink" title="tcpdump命令格式"></a>tcpdump命令格式</h2><p>注意：详细解释可以通过man tcpdump来查看。<br>tcpdump [-i 网卡] -nnAX ‘表达式’<br>参数意义：<br>-i: interface 监听的网卡<br>-nn：表示以ip和port的方式显示来源主机和目的主机，而不是用主机名和服务<br>-A：以ascii的方式显示数据包，抓取web数据时很有用<br>-X：数据包将会以16进制和ascii的方式显示（这样显示有什么好处？）<br>表达式：表达式有很多种，常见的有：host 主机；port 端口；src host 发包主机；dst host 收包主机。多个条件可以用and、or组合，取反可以使用!，更多的使用可以查看man 7 pcap-filter。</p>
<h2 id="监听网卡"><a href="#监听网卡" class="headerlink" title="监听网卡"></a>监听网卡</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 监听eth0网卡</div><div class="line">tcpdump -i eth0</div></pre></td></tr></table></figure>
<p>可以使用ifconfig命令来查看网卡信息，以便通过tcpdump命令来监听相应网卡。</p>
<h2 id="监听指定协议的数据"><a href="#监听指定协议的数据" class="headerlink" title="监听指定协议的数据"></a>监听指定协议的数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 表示监听eth0网卡，并且只接收icmp协议数据</div><div class="line">tcpdump -i eth0 -nn &apos;icmp&apos;</div></pre></td></tr></table></figure>
<p>监听icmp协议类型数据，icmp即ping命令使用的协议。常用的协议类型有tcp,udp等。<br>示例：<br><img src="/images/tcpdump.png" alt=""><br>以上是抓取icmp协议类型数据，数据含义：<br>抓到包的时间 IP 发包的主机和端口 &gt; 接收的主机和端口 数据包内容</p>
<h2 id="监听指定的主机"><a href="#监听指定的主机" class="headerlink" title="监听指定的主机"></a>监听指定的主机</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcpdump -i eth0 -nn &apos;host 192.168.1.231&apos;</div></pre></td></tr></table></figure>
<p>该命令表示抓取主机192.168.1.231的发送包和接收包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcpdump -i eth0 -nn &apos;src host 192.168.1.231&apos;</div></pre></td></tr></table></figure></p>
<p>表示只抓取主机192.168.1.231发送的包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcpdump -i eth0 -nn &apos;dst host 192.168.1.231&apos;</div></pre></td></tr></table></figure></p>
<p>表示只抓取主机192.168.1.231接收到的包</p>
<h2 id="监听指定端口"><a href="#监听指定端口" class="headerlink" title="监听指定端口"></a>监听指定端口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcpdump -i eth0 -nnA &apos;port 80&apos;</div></pre></td></tr></table></figure>
<p>该命令表示抓取80端口的数据包，并以ascii的方式显示数据包，在web开发中很实用</p>
<h2 id="监听指定主机和端口"><a href="#监听指定主机和端口" class="headerlink" title="监听指定主机和端口"></a>监听指定主机和端口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcpdump -i eth0 -nnA &apos;port 80 and src host 192.168.1.231&apos;</div></pre></td></tr></table></figure>
<p>多个条件可以用and，or连接。上例表示监听192.168.1.231主机通过80端口发送的数据包。</p>
<h2 id="监听除某个端口外的其它端口"><a href="#监听除某个端口外的其它端口" class="headerlink" title="监听除某个端口外的其它端口"></a>监听除某个端口外的其它端口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcpdump -i eth0 -nnA &apos;!port 22&apos;</div></pre></td></tr></table></figure>
<p>如果需要排除某个端口或者主机，可以使用“!”符号，上例表示监听非22端口的数据包。<br>———————————————–华丽分割线—————————————–<br>以上内容记录以备后用。。。。。。。</p>
]]></content>
      
        <categories>
            
            <category> Network </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tcpdump </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[keystone架构和功能分析]]></title>
      <url>http://www.pisces.ml/2016/04/24/keystone-architecture/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Keystone(OpenStack Identity Service)是 OpenStack 框架中负责管理身份验证、服务规则和服务令牌功能等的模块。用户访问资源需要验证用户的身份与权限，服务执行操作也需要进行权限检测，这些都需要通过 Keystone 来处理。目前Keystone同时支持V2和V3版本．Keystone V3 版本做出了许多变化和改进，引入了 Domain 和 Group 等新概念．</p>
<h2 id="keystone基本概念"><a href="#keystone基本概念" class="headerlink" title="keystone基本概念"></a>keystone基本概念</h2><p>Keystone 中主要涉及到如下几个概念：User、Project(v3)、Domain、Region、Role、Token。下面对这几个概念进行简要说明。</p>
<ul>
<li>User：即使用服务的用户，可以是人、服务或者是系统，只要是使用了 Openstack 服务的对象都可以称为用户。</li>
<li>Project：项目或者理解为组织拥有的资源的合集。在一个项目中可以拥有很多个用户，这些用户可以根据权限的划分使用项目中的资源。</li>
<li>Domain: 作用域，即项目的集合，在一个域内可以创建多个项目。</li>
<li>Region: 作用范围，是域的集合，通过Region来划分区域，Region包括了所有的可用资源。</li>
<li>Role角色:用于分配操作的权限。角色可以被指定给用户，使得该用户获得角色对应的操作权限。</li>
<li>Credential 用户证据：用来证明用户身份的证据，可以是用户名和密码、用户名和API key，或者一个 Keystone 分配的身份token。</li>
<li>Token令牌：指的是一串比特值或者字符串，用来作为访问资源的记号。Token 中含有可访问资源的范围和有效时间。</li>
<li>Group组：分组可以跟项目或者域建立相应关系．同组的项目可以对项目或者域内享有相应的操作权限。</li>
<li>Service 服务：一个 OpenStack 服务，比如Nova、Swift或者Glance等。每个服务提供一个或者多个 endpoint 供用户访问资源以及进行操作。</li>
<li>Endpoint端点 ：一个网络可访问的服务地址，通过它你可以访问一个服务，通常是个 URL 地址。不同 region 有不同的service endpoint。endpoint告诉也可告诉 OpenStack service 去哪里访问特定的 servcie。比如，当 Nova 需要访问 Glance 服务去获取 image 时，Nova 通过访问 Keystone 拿到 Glance 的 endpoint，然后通过访问该 endpoint 去获取Glance服务。我们可以通过Endpoint的 region 属性去定义多个 region。Endpoint 该使用对象分为三类：<ol>
<li>adminurl:提供给admin访问</li>
<li>internalurl:该地址是给内部服务之间进行访问</li>
<li>publicurl:公共用户可以访问的地址</li>
</ol>
</li>
<li>Policy:OpenStack对用户的验证除了 OpenStack 的身份验证以外，还需要鉴别用户对某个服务是否有访问权限。Policy 机制就是用来控制某一个 User 在某个 Tenant 中某个操作的权限。这个 User 能执行什么操作，不能执行什么操作，就是通过 policy 机制来实现的。对于 Keystone 服务来说，policy 就是一个json 文件，默认是 /etc/keystone/policy.json。通过配置这个文件，Keystone Service 实现了对 User 的基于用户角色的权限管理。<h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><h3 id="账户关系"><a href="#账户关系" class="headerlink" title="账户关系"></a>账户关系</h3><img src="/images/relation_user_project_region.jpg" alt=""><br>从上图中，我们可以看出在一个 RegionOne中包含多个Domain，每个Domain共同使用Region所提供的资源。Domain1中包含 3 个 Projects,可以通过 Group1 将 Role admin直接赋予 Domain,那么 Group1 中的所有用户将会对 Domain1中的所有 Projects 都拥有admin权限。也可以通过 Group2 将 Role demo 只赋予 Project3,这样 Group2 中的 User 就只拥有对Project3有相应的权限，而不会影响其它 Projects。<h3 id="管理对象关系"><a href="#管理对象关系" class="headerlink" title="管理对象关系"></a>管理对象关系</h3><img src="/images/flow_chart.jpg" alt=""><br>从上图我们可以清晰的看到各个对象之间的总体关系，简单的说用户通过用户名密码登入（或者使用联合认证登入），验证成功keystone会返回相应的token(scope_token/unscope_token),scope_token中包含一系列的meta信息（包括端口／角色／项目），每次请求都会先验证token有效性，用户再拿这token去请求相应的资源，服务跟服务之间访问也是通过endpoint找到服务地址并进行请求资源信息，可见token在整个openstaqck家族起到了很重要的作用。另外需要提的是各个服务中的policy机制，policy是根据token中的角色信息来判断用户是否有相应的操作权限。<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h3><img src="/images/openstack.jpg" alt=""><br>由上图可知keystone为各个模块提供认证服务，所以各个模块与keystone都有所交互。其中登录认证体现在用户访问各个组件的API时，调用了WSGI框架的authtoken filter，该filter最先调用keystoneclient ，最终通过keystone验证token，完成对用户的登录认证。如果认证失败，用户将不能访问该API。<h3 id="keystone架构"><a href="#keystone架构" class="headerlink" title="keystone架构"></a>keystone架构</h3><h4 id="keystone源码结构"><a href="#keystone源码结构" class="headerlink" title="keystone源码结构"></a>keystone源码结构</h4>目录结构<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">├── assignment</div><div class="line">│   ├── backends</div><div class="line">│   ├── controllers.py</div><div class="line">│   ├── controllers.pyc</div><div class="line">│   ├── core.py</div><div class="line">│   ├── core.pyc</div><div class="line">│   ├── __init__.py</div><div class="line">│   ├── __init__.pyc</div><div class="line">│   ├── role_backends</div><div class="line">│   ├── routers.py</div><div class="line">│   ├── routers.pyc</div><div class="line">│   ├── schema.py</div><div class="line">│   └── schema.pyc</div><div class="line">├── auth</div><div class="line">│   ├── controllers.py</div><div class="line">│   ├── controllers.pyc</div><div class="line">│   ├── core.py</div><div class="line">│   ├── core.pyc</div><div class="line">│   ├── __init__.py</div><div class="line">│   ├── __init__.pyc</div><div class="line">│   ├── plugins</div><div class="line">│   ├── routers.py</div><div class="line">│   └── routers.pyc</div><div class="line">├── backends.pyc</div><div class="line">├── catalog</div><div class="line">│   ├── backends</div><div class="line">│   ├── controllers.py</div><div class="line">│   ├── controllers.pyc</div><div class="line">│   ├── core.py</div><div class="line">│   ├── core.pyc</div><div class="line">│   ├── __init__.py</div><div class="line">│   ├── __init__.pyc</div><div class="line">│   ├── routers.py</div><div class="line">│   ├── routers.pyc</div><div class="line">│   ├── schema.py</div><div class="line">│   └── schema.pyc</div><div class="line">├── clean.pyc</div><div class="line">├── cli.pyc</div><div class="line">├── cmd</div><div class="line">│   ├── all.py</div><div class="line">│   ├── all.pyc</div><div class="line">│   ├── cli.py</div><div class="line">│   ├── cli.pyc</div><div class="line">│   ├── __init__.py</div><div class="line">│   ├── __init__.pyc</div><div class="line">│   ├── manage.py</div><div class="line">│   └── manage.pyc</div><div class="line">......</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>cmd目录下(主要存放命令行工具)：<ul>
<li>keystone-all（本地启动服务监听35357和5000端口）</li>
<li>keystone-manage（keystone综合管理工具<br>  a. db_sync:初始化数据库<br>  b. db_version：打印数据库迁移版本<br>  c. fernet_rotate：Rotate Fernet encryption keys。<br>  d. fernet_setup：Setup a key repository for Fernet tokens<br>  e. mapping_purge:清空mapping表<br>  f. pki_setup：初始化生成密钥对和证书文件<br>  g. saml_idp_metadata：生成Identity Provider的metadata<br>  h. ssl_setup ：为https链接生成密钥对和证书<br>  i. token_flush ：清除过期token</li>
</ul>
</li>
<li>服务目录：<ul>
<li>服务目录如identity,token,catalog等，他们的架构类似都是通过router进行url路由到相应的controller上，controller进行逻辑处理，通过指定的driver调用相应的后台处理。</li>
</ul>
</li>
<li>server目录：<ul>
<li>服务入口，主要是加载配置启动服务监听相应端口</li>
</ul>
</li>
<li>middleware目录：<ul>
<li>中间键支持，用于预处理request请求<h4 id="keystone服务启动"><a href="#keystone服务启动" class="headerlink" title="keystone服务启动"></a>keystone服务启动</h4><em>启动方式</em><br>keystone可以通过两种方式启动分别是本地开发模式和部署环境：<br>本地开发环境：keystone-all –configl-file /etc/keystone/keystone.conf<br>部署环境：主要是将应用跑在httpd上，可参考配置文档：<a href="http://docs.openstack.org/developer/keystone/apache-httpd.html" target="_blank" rel="external">http://docs.openstack.org/developer/keystone/apache-httpd.html</a><br><em>启动模式分析</em><br>keystone通过paste deploy组织app，会启动admin(监听35357端口)和main(监听5000端口),对应keystone-paste.ini中的[composite:main]和[composite:admin]，如下所示配置文件：<br><img src="/images/image2016-3-4 16-57-3.png" alt=""><br>从上面配置文件我们可以看出admin应用主要是提供管理员app，main主要提供了公共app。他们同时都支持v2和v3版本api，我们可以看出v3版本的api在admin和main中是没有差异的（在v3版本中都是使用api_v3），但是在v2版本中存在差异，在main用了public_api而在admin中用了admin_api（这就可以解释为何在v2版本中向不同的端口发送相同的请求却返回不同结果）。简单的说在v2版本中还区分admin和public，在v3版本中已经不区分，v3版本中就是按照RBAC即访问控制来决定用户是否对该api有操作权限。<br>具体的factory构造，包括路由的实现，以及中间件的处理，到最终的应用处理有兴趣可以看看源码的实现，这里就不多说了。<h4 id="keystone-RESful-Api架构"><a href="#keystone-RESful-Api架构" class="headerlink" title="keystone RESful Api架构"></a>keystone RESful Api架构</h4>架构图：<br><img src="/images/RESTFul_API.jpg" alt=""><br>keystone是基于python WSGI框架实现的web应用，通过paste组织web应用服务网络，对外提供REST Api，主要提供了提供 Identity、Token、Catalog 、Resource、Assignment和 Policy 服务：</li>
</ul>
</li>
</ol>
<ul>
<li>Identity服务验证了身份验证凭证，并提供了所有相关的元数据。</li>
<li>Token服务验证并管理用于验证请求身份的令牌。</li>
<li>Catalog服务提供了可用于端点发现的服务注册表。</li>
<li>Policy服务暴露了一个基于规则的身份验证引擎。</li>
<li>Resource服务提供资源包括project/domain</li>
<li>Assignment服务分配角色<br>每个 Keystone 功能都支持用于集成到异构环境并展示不同功能的后端插件。通过下表我们看下各个服务所管理的对象：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">| 组件名称 | 管理对象 | 类型/格式 | 服务后台 | 配置后台 |</div><div class="line">|:-----:|:-----:|:-----:|:-----:|:-----:|</div><div class="line">| identity | keystone.identity.controllers.Groupl3 keystone.identity.controllers.UserV3 | -- | ldap/sql | [identity] driver = sql|</div><div class="line">| Token | keystone.token.controllers.Auth | uuid/pki/pkiz/fernet | kvs/sql/memcache/memcache_pool | [token] provider = uuid/pki/pkiz/fernet driver = sql/memcache/memcache_pool |</div><div class="line">|Catalog  | keystone.catalog.controllers.EndpointV3 keystone.catalog.controllers.RegionV3 keystone.catalog.controllers.ServiceV3 | -- |  kvs/templated/sql | [catalog] driver=sql/kvs/templated |</div><div class="line">| Policy | keystone.policy.controllers.PolicyV3 | -- | sql | [policy] driver=sql |</div><div class="line">| Resource | keystone.resource.controllers.DomainV3 keystone.resource.controllers.ProjectV3 | -- | ldap/sql | [resource] driver=ldap/sql |</div><div class="line">| Assignment | keystone.assignment.controllers.GrantAssignmentV3 keystone.assignment.controllers.ProjectAssignmentV3 keystone.assignment.controllers.TenantAssignment keystone.assignment.controllers.Role keystone.assignment.controllers.RoleAssignmentV2 keystone.assignment.controllers.RoleAssignmentV3 keystone.assignment.controllers.RoleV3 | -- | sql/ldap | [assignment] driver=sql/ldap |</div><div class="line">| Authentication | keystone.auth.controllers.Auth | password/saml2/token/oauth1 | -- | [auth] methods=external,password,token,oauth1 password=keystone.auth.plugins.password.Password token=keystone.auth.plugins.token.Token |</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p>可以通过两种方式安装keystone:</p>
<ul>
<li>源码安装</li>
<li>软件包安装<br><em>源码安装（本地环境）</em>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git clone https://git.openstack.org/openstack/keystone.git　#拷贝源码</div><div class="line">$ cd keystone/ &amp;&amp; virtualenv .venv #进入软件包，创建本地隔离环境</div><div class="line">$ source .venv/bin/activate</div><div class="line">$ pip install -r requirements.txt　＃安装软件依赖包</div><div class="line">$ python setup.py install/develop　＃可以根据需要选择已哪种方式安装，系统安装／开发者模式安装</div><div class="line">$ vim /etc/keystone/keystone.conf　＃根据具体需求配置keystone，可参考官方配置文档：http://docs.openstack.org/developer/keystone/configuration.html</div><div class="line"># 初始化数据库: keystone-manage --config-file etc/keystone.conf db_sync</div></pre></td></tr></table></figure>
</li>
</ul>
<p><em>软件包安装</em>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">＃Ubuntu</div><div class="line">$ sudo apt-get install keystone</div><div class="line"># Fedora</div><div class="line">$ sudo yum install openstack-keystone</div><div class="line"># 配置keystone配置文件keystone.conf</div><div class="line"># 初始化数据库: keystone-manage --config-file etc/keystone.conf db_sync</div></pre></td></tr></table></figure></p>
<h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><p>keystone代码的etc/目录下含有keystone的配置文件</p>
<ul>
<li>keystone.conf 主要配置文件</li>
<li>keystone-paste.ini paste配置文件, 可以通过修改此文件增减keystone运行时加载的扩展(contrib).</li>
<li>default_catalog.templates 定义service catalog的语法文件, 如果keystone的catalog driver 定义为keystone.catalog.backends.templated.Catalog 则会从文本文件中读取endpoint信息(严格注意语法, 空格等), 定义成keystone.catalog.backends.sql.Catalog 则会从数据库中加载endpoint.</li>
<li>policy.json keystone的接口权限控制定义.</li>
<li>policy.v3cloudsample.json keystone 官方的多domain部署方式中的权限控制example文件,我们没有使用.<br>keystone.conf 中主要配置选项说明:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">[DEFAULT]</div><div class="line">   admin_token = ADMIN   # 定义一个超级管理员的token, 使用此token可以绕过权限检查直接操作所有接口, 此参数应该只在安装完keystone后创建初始账户时使用, 生产环境中应该被禁用, 禁用方法为: 在keystone-paste.ini中将所有pipeline中的admin_token_auth这个filter删掉.</div><div class="line">debug = False # 打印debug级别的日志</div><div class="line">verbose = False  # 打印info级别的日志 ,</div><div class="line">   &quot;&quot;&quot;</div><div class="line">   日志级别控制的逻辑为:</div><div class="line">    if CONF.debug:</div><div class="line">        log_root.setLevel(logging.DEBUG)</div><div class="line">    elif CONF.verbose:</div><div class="line">        log_root.setLevel(logging.INFO)</div><div class="line">    else:</div><div class="line">        log_root.setLevel(logging.WARNING)</div><div class="line">&quot;&quot;&quot;</div><div class="line">log_file = /var/log/keystone.log   # 指定将log打到哪个日志文件中, 不设置,日志会打印到屏幕</div><div class="line"># 和rabbitmq相关的主要参数</div><div class="line">rabbit_host = localhost</div><div class="line">rabbit_port = 5672</div><div class="line">rabbit_userid = openstack</div><div class="line">rabbit_password = testing</div><div class="line">rabbit_virtual_host = /</div><div class="line">rabbit_ha_queues = True</div><div class="line">amqp_durable_queues = True  # 为true的话,所有rabbitmq相关的消息,queue,exchange都会变成持久化的.</div><div class="line">control_exchange  = keystone  # keystone 发送的 消息都会发到该 exchange</div><div class="line">[auth]</div><div class="line">methods = password, token   # 开启的认证方式</div><div class="line">password = keystone.auth.plugins.password.Password  # methods中每个定义的认证方法都需要在下方定义</div><div class="line">token = keystone.auth.plugins.token.Token</div><div class="line">[catalog]</div><div class="line">template_file = default_catalog.templates   # 如果driver为templated, 则此选项生效</div><div class="line">driver = keystone.catalog.backends.sql.Catalog</div><div class="line">[token]</div><div class="line">expiration = 3600  # token的过期时间, 按s计算,默认3600s</div><div class="line">provider = keystone.token.provider.uuid.Provider  # 使用的token格式, uuid/pki/pkiz/fernet</div><div class="line">[database]</div><div class="line">connection = mysql://root:root@localhost/keystone  # 定义数据库连接, 如果使用sqlite,则可以修改为sqlite:///keystone.db</div><div class="line">[os_inherit]</div><div class="line">enabled = True  # 日否开启os_inherit 扩展, 官方对此扩展的说明文档: https://github.com/openstack/identity-api/blob/master/v3/src/markdown/identity-api-v3-os-inherit-ext.md</div><div class="line">所有参数的默认值定义都在keystone/common/config.py中</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="FQA"><a href="#FQA" class="headerlink" title="FQA"></a>FQA</h2><p>Ｑ：keystone的35357和5000端口有什么区别?<br>Ａ：在keystone的 v3 api中35357 和5000 没有任何区别, 建议统一只使用35357端口, 在v2.0的api中, 5000是public api的端口,35357是admin api的端口, 两者提供api的具体差别可以看keystone-paste.ini中的[pipeline:public_api] 和[pipeline:admin_api].<br>Ｑ：如何开启一个默认未启用的扩展?<br>Ａ：keystone的扩展,都以filter的形式在keystone-paste.ini中定义, 需要开启只需要将其加入相应的pipeline中,注意的是有些扩展还依赖一些数据库表, 这些表默认安装是不会生成的, 需要用keystone-manage 命令额外初始化.<br>比如要启用oauth1扩展, 此扩展有自己的数据库表:<br>oauth1在keystone-paste.ini中的定义为[filter:oauth1_extension], 将其加入[pipeline:api_v3], 顺序最好放在service_v3之前. PS: 有些扩展只支持v2.0 api,有些只支持v3 api,实际情况可以查看它们的实现,比如oauth1: keystone.contrib.oauth1.controllers, 其中所有的controller都是继承自V3Controller, 则此api只能在v3下使用. keystone-manage –config-file etc/keystone.conf db_sync –extension oauth1 接下来即可使用oauth1扩展定义的api了.</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://docs.openstack.org/developer/keystone/" target="_blank" rel="external">http://docs.openstack.org/developer/keystone/</a><br><a href="http://docs.openstack.org/developer/keystone/architecture.html#application-construction" target="_blank" rel="external">http://docs.openstack.org/developer/keystone/architecture.html#application-construction</a><br><a href="http://docs.openstack.org/developer/keystone/installing.html" target="_blank" rel="external">http://docs.openstack.org/developer/keystone/installing.html</a><br><a href="http://docs.openstack.org/developer/keystone/developing.html" target="_blank" rel="external">http://docs.openstack.org/developer/keystone/developing.html</a><br><a href="http://www.ibm.com/developerworks/cn/cloud/library/cl-openstack-keystone/index.html" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/cloud/library/cl-openstack-keystone/index.html</a><br><a href="https://www.ibm.com/developerworks/cn/cloud/library/cl-openstack-pythonapis/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/cloud/library/cl-openstack-pythonapis/</a><br><a href="http://www.cnblogs.com/sammyliu/p/4272611.html" target="_blank" rel="external">http://www.cnblogs.com/sammyliu/p/4272611.html</a><br><a href="http://blog.csdn.net/hzrandd/article/details/10834381" target="_blank" rel="external">http://blog.csdn.net/hzrandd/article/details/10834381</a></p>
]]></content>
      
        <categories>
            
            <category> Openstack </category>
            
        </categories>
        
        
        <tags>
            
            <tag> keystone </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux病毒扫描软件ClamAV安装于使用]]></title>
      <url>http://www.pisces.ml/2016/03/27/articles/linux/2016328/</url>
      <content type="html"><![CDATA[<p>近期安装的几台虚拟机网络出去流量高的惊人，达到400~600M/s，直接导致网络几乎瘫痪。直接导致远程连接不上主机，网络延迟特别高。查询原因发现后台有一个进程消耗一半cpu，并且该进程杀死后又会自动启动另外一个进程，无法杀掉。当断掉公网ip后就能kill掉该进程，且不会再自动启动。且该局域网中所有主机均出现该状况，<br>根据该现象有可能是ddos攻击导致。于是上网查了一些杀毒软件，试图kill掉该病毒。网上查询到了一款ubuntu上的开源杀毒软件，尝试了以下果然有效果。下面我们来介绍下这款软件clamAV，尝试了以下果然有效果。下面我们来介绍下这款软件clamAV。</p>
<h2 id="什么是clamAV"><a href="#什么是clamAV" class="headerlink" title="什么是clamAV"></a>什么是clamAV</h2><p>clamAV全名Clam AntiVirus，是一款开源的杀毒软件，能够预防许多的恶意软件主要应用于邮件服务器。扫描并清理系统中的恶意软件。<br>clamAV包含了大量的实用程序如：命令行扫描，自动跟新数据库和可扩展多线程守护进程，以及反病毒引擎。<br>接下来我们就来介绍下clamAV的安装和使用。</p>
<h2 id="安装＆配置"><a href="#安装＆配置" class="headerlink" title="安装＆配置"></a>安装＆配置</h2><p>1.安装软件包<br>clamAV安装方法有很多可以直接去官网<a href="http://www.clamav.net/download.html" target="_blank" rel="external">下载</a>并进行安装，为了方便我们可以直接执行以下命令直接在ubuntu系统中安装该软件包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 如果安装不了我们可以先更新下软件源`apt-get update`</div><div class="line">sudo apt-get install clamav clamav-daemon</div></pre></td></tr></table></figure></p>
<p>2.更新病毒数据库<br>安装完成后clamAV会提示你安装病毒数据库，clamAV会根据数据库中提供的数据对系统进行搜索查询，我们只需要执行以下命令来同步远程病毒数据库,该命令会下载main.cvd和daily.cvd文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo freshclam</div></pre></td></tr></table></figure></p>
<h2 id="clamAV使用"><a href="#clamAV使用" class="headerlink" title="clamAV使用"></a>clamAV使用</h2><p>安装很简单，使用更简单，就一个<code>clamscan</code>命令即可。示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 扫描/home目录下的文件</div><div class="line">clamscan -r /home</div><div class="line"># 全盘扫描(该命令可能执行时间比较长)</div><div class="line">clamscan -r /</div><div class="line"># 格式化输出，只输出显示病毒文件或者是恶意进程</div><div class="line">clamscan -r --bell -i /</div><div class="line"># 查询任意位置，并将结果写入新文件记录</div><div class="line">sudo clamscan -r /folder/to/scan/ | grep FOUND &gt;&gt; /path/to/save/report/myfile.txt</div></pre></td></tr></table></figure></p>
<p>如上命令会扫描目录，如果发现恶意软件或者病毒文件会自动清理<br>我们还可以为clamAV建立定时任务执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">crontab -e</div></pre></td></tr></table></figure></p>
<p>并在定时任务中写入如下任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">00 00 * * * clamscan -r /location_of_files_or_folder # 根据实际指定搜索文件夹</div></pre></td></tr></table></figure></p>
<p>另外如果你不习惯使用命令行，还可以使用clamAV的GUI界面，需要执行以下命令安装GUI<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install ClamTK</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> clamAV </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[openstack 多节点安装]]></title>
      <url>http://www.pisces.ml/2016/03/27/openstack-deploy/</url>
      <content type="html"><![CDATA[<p>本文记录双节点openstack部署流程,根据<a href="http://docs.openstack.org/liberty/install-guide-ubuntu/" target="_blank" rel="external">官方文档</a>,一步一步搭建openstack,并且记录搭建过程遇到的坑。</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>openstack是一个开源社区，提供IAAS解决方案，我们首先来了解下基础服务：</p>
<ul>
<li><a href="http://docs.openstack.org/developer/horizon/" target="_blank" rel="external">Horizon</a>:面板服务，直接面向用户，为用户提供可视操作。</li>
<li><a href="http://docs.openstack.org/developer/nova/" target="_blank" rel="external">Nova</a>:计算服务，提供计算机生命周期管理，如新建虚拟机等。</li>
<li><a href="http://docs.openstack.org/developer/neutron/" target="_blank" rel="external">Neutron</a>:网络服务，提供云计算环境下的虚拟网络功能。</li>
<li><a href="http://docs.openstack.org/developer/keystone/" target="_blank" rel="external">Keystone</a>:认证服务，提供用户认证以及openstack中服务认证。</li>
<li><a href="http://docs.openstack.org/developer/glance/" target="_blank" rel="external">Glance</a>:镜像服务，提供镜像存储。</li>
<li><a href="http://docs.openstack.org/developer/ceilometer/" target="_blank" rel="external">Ceilometer</a>:监控服务，负责资源监控实时了解资源情况。</li>
<li><a href="http://docs.openstack.org/developer/swift/" target="_blank" rel="external">Swift</a>:对象存储服务，提供多租户的对象存储。</li>
<li><a href="http://docs.openstack.org/developer/cinder/" target="_blank" rel="external">Cinder</a>:块存储服务，提供块存储。<h2 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h2><h3 id="硬件架构"><a href="#硬件架构" class="headerlink" title="硬件架构"></a>硬件架构</h3><img src="/images/hwreqs.png" alt="部署结构图"><br>常规部署主要有分为控制节点，计算节点，网络节点。我们以最简方式部署，如上图所示使用两个节点，控制节点和计算节点，我们不单独部署网络节点将网络agent部署在控制节点不单独部署在网络节点。另外配置至少如上要求所示。<h3 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h3>1.软件部署架构如下图所示：<br><img src="/images/network2-services.png" alt=""><br><strong>控制节点</strong><br>控制节点主要部署openstack基础服务如：keystone,horizon,Neutron等，以及基础服务的支持服务，如：消息队列，NTP，mysql等。<br><strong>计算节点</strong><br>计算节点主要部署hypervisor，根据nova调度算法创建实例，以及网络服务。<br>2.网络拓扑架构图：<br><img src="/images/networklayout.png" alt=""><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="基础环境搭建"><a href="#基础环境搭建" class="headerlink" title="基础环境搭建"></a>基础环境搭建</h3>以下环境搭建在通过<a href="https://console.ustack.com" target="_blank" rel="external">ustack</a>云平台进行搭建：</li>
</ul>
<ol>
<li>新建路由器route0</li>
<li>创建私有网络public-network和management-network</li>
<li>申请名为net的公网并且绑定到路由器route</li>
<li>将私有网络public-network关联到路由器route</li>
<li>创建控制节点controller(2vcpu,8G)和计算节点compute(4vcpu,8G),将controller加入私有网络public-network,将compute加入私有网络public-network和management-network<br>搭建完成后网络拓扑如下所示：<br><img src="/images/topology.png" alt=""><h3 id="配置host"><a href="#配置host" class="headerlink" title="配置host"></a>配置host</h3>接着我们来配置控制节点和计算几点host<br>修改文件/etc/hosts,如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 控制节点编辑文件/etc/hosts</div><div class="line">192.168.2.2 controller</div><div class="line">192.168.2.5 compute</div><div class="line"># 计算节点同上操作</div><div class="line">192.168.2.2 controller</div><div class="line">192.168.2.5 compute</div></pre></td></tr></table></figure>
</li>
</ol>
<p>可以通过以下命令在控制节点和计算节点验证是否配置正确：</p>
<blockquote>
<p>root@compute:~# ping controller<br>PING controller (192.168.2.2) 56(84) bytes of data.<br>64 bytes from controller (192.168.2.2): icmp_seq=1 ttl=64 time=0.407 ms<br>64 bytes from controller (192.168.2.2): icmp_seq=2 ttl=64 time=0.508 ms<br>64 bytes from controller (192.168.2.2): icmp_seq=3 ttl=64 time=0.571 ms<br>root@compute:~# ping -c 4 openstack.org<br>PING openstack.org (162.242.140.107) 56(84) bytes of data.<br>64 bytes from 162.242.140.107: icmp_seq=1 ttl=42 time=386 ms<br>64 bytes from 162.242.140.107: icmp_seq=2 ttl=42 time=384 ms<br>64 bytes from 162.242.140.107: icmp_seq=3 ttl=42 time=386 ms</p>
</blockquote>
<h3 id="安装支持软件"><a href="#安装支持软件" class="headerlink" title="安装支持软件"></a>安装支持软件</h3><h4 id="安装NTP服务"><a href="#安装NTP服务" class="headerlink" title="安装NTP服务"></a>安装NTP服务</h4><p>控制节点controller：<br>1.安装chrony包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install chrony</div></pre></td></tr></table></figure></p>
<p>2.编辑文件/etc/chrony/chrony.conf插入以下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 以asia.pool.ntp.org时间为例</div><div class="line">server asia.pool.ntp.org iburst</div></pre></td></tr></table></figure></p>
<p>3.重启NTP服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service chrony restart</div></pre></td></tr></table></figure></p>
<p>计算节点compute：<br>安装步骤跟控制节点一样，在编辑/etc/chrony/chrony.conf文件时需要插入以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 表示跟controller节点时间同步</div><div class="line">server controller iburst</div></pre></td></tr></table></figure></p>
<p>验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># *表示当前所用的时间</div><div class="line"># 控制节点</div><div class="line">root@controller:~# chronyc sources</div><div class="line">210 Number of sources = 1</div><div class="line">MS Name/IP address         Stratum Poll Reach LastRx Last sample</div><div class="line">===============================================================================</div><div class="line">^* host-2.net50.sol.az           4   6   177    55  +3003us[ +313us] +/-  694ms</div><div class="line"># 计算节点</div><div class="line">root@compute:~# chronyc sources</div><div class="line">210 Number of sources = 1</div><div class="line">MS Name/IP address         Stratum Poll Reach LastRx Last sample</div><div class="line">===============================================================================</div><div class="line">^* controller                    5   6   377    36  +4607us[  +27ms] +/-  734ms</div></pre></td></tr></table></figure></p>
<h4 id="安装openstack软件包支持"><a href="#安装openstack软件包支持" class="headerlink" title="安装openstack软件包支持"></a>安装openstack软件包支持</h4><p>该操作在所有节点均执行<br>修改文件/etc/apt/sources.list，增加以下内容：</p>
<blockquote>
<p>deb <a href="http://ubuntu-cloud.archive.canonical.com/ubuntu" target="_blank" rel="external">http://ubuntu-cloud.archive.canonical.com/ubuntu</a> trusty-updates/liberty main</p>
</blockquote>
<p>执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get update &amp;&amp; apt-get dist-upgrade</div></pre></td></tr></table></figure></p>
<p>如果出现如下错误：</p>
<blockquote>
<p>error:<br>W: GPG error: <a href="http://ubuntu-cloud.archive.canonical.com" target="_blank" rel="external">http://ubuntu-cloud.archive.canonical.com</a> trusty-updates/liberty Release: The following signatures couldn’t be verified because the public key is not available: NO_PUBKEY 5EDB1B62EC4926EA<br>执行命令<figure class="highlight plain"><figcaption><span>adv --keyserver keyserver.ubuntu.com --recv-keys 5EDB1B62EC4926EA```后在运行```apt-get update && apt-get dist-upgrade```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 安装SQL数据库</div><div class="line">在控制节点执行如下操作：</div><div class="line">1.安装sql包,并且设置root用户密码</div></pre></td></tr></table></figure></p>
</blockquote>
<p>apt-get install mariadb-server python-pymysql<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.修改文件/etc/mysql/my.cnf并添加如下内容允许所有节点请求。</div></pre></td></tr></table></figure></p>
<p>[mysqld]<br>bind-address = 0.0.0.0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.重启sql服务</div></pre></td></tr></table></figure></p>
<p>service mysql restart<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#### 安装消息队列rabbitmq</div><div class="line">1.安装rabbitmq软件包</div></pre></td></tr></table></figure></p>
<p>apt-get install rabbitmq-server<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.添加openstack用户</div></pre></td></tr></table></figure></p>
<p>rabbitmqctl add_user openstack root<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.给openstack用户添加读写权限</div></pre></td></tr></table></figure></p>
<p>rabbitmqctl set_permissions openstack “.<em>“ “.</em>“ “.*”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">## 安装openstack软件</div><div class="line">### 安装keystone</div><div class="line">#### 创建keystone数据库</div><div class="line">创建keystone数据库以及生成admin token</div><div class="line">1.登入数据库</div></pre></td></tr></table></figure></p>
<p>mysql -uroot<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.创建keystone数据库</div></pre></td></tr></table></figure></p>
<p>CREATE DATABASE keystone;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.添加数据库访问权限</div></pre></td></tr></table></figure></p>
<p>GRANT ALL PRIVILEGES ON keystone.<em> TO ‘keystone’@’localhost’ \<br>  IDENTIFIED BY ‘root’;<br>GRANT ALL PRIVILEGES ON keystone.</em> TO ‘keystone’@’%’ \<br>  IDENTIFIED BY ‘root’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#### 随机生成admin token</div><div class="line">执行以下命令生成admin token以便后续步骤使用</div></pre></td></tr></table></figure></p>
<p>root@controller:~# openssl rand -hex 10<br>e770648f049dd983575b<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#### 安装keystone服务</div><div class="line">1.从源安装keystone</div></pre></td></tr></table></figure></p>
<h1 id="禁止安装完后启动服务"><a href="#禁止安装完后启动服务" class="headerlink" title="禁止安装完后启动服务"></a>禁止安装完后启动服务</h1><p>echo “manual” &gt; /etc/init/keystone.override<br>apt-get install keystone apache2 libapache2-mod-wsgi \<br>  memcached python-memcache<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.配置keystone配置文件/etc/keystone/keystone.conf,修改以下配置</div></pre></td></tr></table></figure></p>
<p>[DEFAULT]<br>…<br>admin_token = e770648f049dd983575b<br>[database]<br>…<br>connection = mysql://keystone:root@controller/keystone?charset=utf8<br>[memcache]<br>…<br>servers = localhost:11211<br>[token]<br>…<br>provider = uuid<br>driver = memcache<br>[revoke]<br>…<br>driver = sql<br>[DEFAULT]<br>…<br>verbose = True<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.同步数据库</div></pre></td></tr></table></figure></p>
<p>su -s /bin/sh -c “keystone-manage db_sync” keystone<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#### 配置apache服务器</div><div class="line">1.编辑文件/etc/apache2/apache2.conf修改Servername</div></pre></td></tr></table></figure></p>
<p>ServerName controller<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.创建文件/etc/apache2/sites-available/wsgi-keystone.conf，并添加如下内容</div></pre></td></tr></table></figure></p>
<p>Listen 5000<br>Listen 35357</p>
<p><virtualhost *:5000=""><br>    WSGIDaemonProcess keystone-public processes=5 threads=1 user=keystone group=keystone display-name=%{GROUP}<br>    WSGIProcessGroup keystone-public<br>    WSGIScriptAlias / /usr/bin/keystone-wsgi-public<br>    WSGIApplicationGroup %{GLOBAL}<br>    WSGIPassAuthorization On<br>    <ifversion>= 2.4&gt;<br>      ErrorLogFormat “%{cu}t %M”<br>    </ifversion><br>    ErrorLog /var/log/apache2/keystone.log<br>    CustomLog /var/log/apache2/keystone_access.log combined<br>    <directory usr="" bin=""><br>        <ifversion>= 2.4&gt;<br>            Require all granted<br>        </ifversion><br>        <ifversion <="" 2.4=""><br>            Order allow,deny<br>            Allow from all<br>        </ifversion><br>    </directory><br></virtualhost></p>
<p><virtualhost *:35357=""><br>    WSGIDaemonProcess keystone-admin processes=5 threads=1 user=keystone group=keystone display-name=%{GROUP}<br>    WSGIProcessGroup keystone-admin<br>    WSGIScriptAlias / /usr/bin/keystone-wsgi-admin<br>    WSGIApplicationGroup %{GLOBAL}<br>    WSGIPassAuthorization On<br>    <ifversion>= 2.4&gt;<br>      ErrorLogFormat “%{cu}t %M”<br>    </ifversion><br>    ErrorLog /var/log/apache2/keystone.log<br>    CustomLog /var/log/apache2/keystone_access.log combined<br>    <directory usr="" bin=""><br>        <ifversion>= 2.4&gt;<br>            Require all granted<br>        </ifversion><br>        <ifversion <="" 2.4=""><br>            Order allow,deny<br>            Allow from all<br>        </ifversion><br>    </directory><br></virtualhost><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.允许加载keystone服务并重启apache服务器</div></pre></td></tr></table></figure></p>
<p>ln -s /etc/apache2/sites-available/wsgi-keystone.conf /etc/apache2/sites-enabled<br>service apache2 restart<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#### 创建service entity和API endpoints</div><div class="line">1.配置认证信息</div></pre></td></tr></table></figure></p>
<p>export OS_TOKEN=e770648f049dd983575b<br>export OS_URL=<a href="http://controller:35357/v3" target="_blank" rel="external">http://controller:35357/v3</a><br>export OS_IDENTITY_API_VERSION=3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.创建keystone服务</div></pre></td></tr></table></figure></p>
<p>root@controller:~# openstack service create \<br>   –name keystone –description “OpenStack Identity” identity<br>+————-+———————————-+<br>| Field       | Value                            |<br>+————-+———————————-+<br>| description | OpenStack Identity               |<br>| enabled     | True                             |<br>| id          | 70c001520bc346f5a24cbce02251edc0 |<br>| name        | keystone                         |<br>| type        | identity                         |<br>+————-+———————————-+<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.创建endpoints</div></pre></td></tr></table></figure></p>
<p>root@controller:~# openstack endpoint create –region RegionOne \<br>   identity public <a href="http://controller:5000/v2.0" target="_blank" rel="external">http://controller:5000/v2.0</a><br>+————–+———————————-+<br>| Field        | Value                            |<br>+————–+———————————-+<br>| enabled      | True                             |<br>| id           | 20ff23f26e9044bab521cf3aa449107c |<br>| interface    | public                           |<br>| region       | RegionOne                        |<br>| region_id    | RegionOne                        |<br>| service_id   | 70c001520bc346f5a24cbce02251edc0 |<br>| service_name | keystone                         |<br>| service_type | identity                         |<br>| url          | <a href="http://controller:5000/v2.0" target="_blank" rel="external">http://controller:5000/v2.0</a>      |<br>+————–+———————————-+<br>root@controller:~# openstack endpoint create –region RegionOne \<br>   identity internal <a href="http://controller:5000/v2.0" target="_blank" rel="external">http://controller:5000/v2.0</a><br>+————–+———————————-+<br>| Field        | Value                            |<br>+————–+———————————-+<br>| enabled      | True                             |<br>| id           | 2f61696b382f4d18be1dbf26958affc9 |<br>| interface    | internal                         |<br>| region       | RegionOne                        |<br>| region_id    | RegionOne                        |<br>| service_id   | 70c001520bc346f5a24cbce02251edc0 |<br>| service_name | keystone                         |<br>| service_type | identity                         |<br>| url          | <a href="http://controller:5000/v2.0" target="_blank" rel="external">http://controller:5000/v2.0</a>      |<br>+————–+———————————-+<br>root@controller:~# openstack endpoint create –region RegionOne \<br>   identity admin <a href="http://controller:35357/v2.0" target="_blank" rel="external">http://controller:35357/v2.0</a><br>+————–+———————————-+<br>| Field        | Value                            |<br>+————–+———————————-+<br>| enabled      | True                             |<br>| id           | cce98996793948f8841e9e809c1fcce0 |<br>| interface    | admin                            |<br>| region       | RegionOne                        |<br>| region_id    | RegionOne                        |<br>| service_id   | 70c001520bc346f5a24cbce02251edc0 |<br>| service_name | keystone                         |<br>| service_type | identity                         |<br>| url          | <a href="http://controller:35357/v2.0" target="_blank" rel="external">http://controller:35357/v2.0</a>     |<br>+————–+———————————-+<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#### 创建projects, users, and roles</div><div class="line">1.创建管理员用户</div></pre></td></tr></table></figure></p>
<h1 id="创建管理员项目"><a href="#创建管理员项目" class="headerlink" title="创建管理员项目"></a>创建管理员项目</h1><p>root@controller:~# openstack project create –domain default \<br>   –description “Admin Project” admin<br>+————-+———————————-+<br>| Field       | Value                            |<br>+————-+———————————-+<br>| description | Admin Project                    |<br>| domain_id   | default                          |<br>| enabled     | True                             |<br>| id          | ae557b315d7c430c929f31b480084ada |<br>| is_domain   | False                            |<br>| name        | admin                            |<br>| parent_id   | None                             |<br>+————-+———————————-+</p>
<h1 id="创建admin账户"><a href="#创建admin账户" class="headerlink" title="创建admin账户"></a>创建admin账户</h1><p>root@controller:~# openstack user create –domain default \<br>   –password-prompt admin<br>User Password:<br>Repeat User Password:<br>+———–+———————————-+<br>| Field     | Value                            |<br>+———–+———————————-+<br>| domain_id | default                          |<br>| enabled   | True                             |<br>| id        | 59a21d5fea5a42908d5911635eb92742 |<br>| name      | admin                            |<br>+———–+———————————-+</p>
<h1 id="创建admin角色"><a href="#创建admin角色" class="headerlink" title="创建admin角色"></a>创建admin角色</h1><p>root@controller:~# openstack role create admin<br>+——-+———————————-+<br>| Field | Value                            |<br>+——-+———————————-+<br>| id    | 28754433fefd4572be420fcf91be7788 |<br>| name  | admin                            |<br>+——-+———————————-+</p>
<h1 id="添加权限"><a href="#添加权限" class="headerlink" title="添加权限"></a>添加权限</h1><p>root@controller:~# openstack role add –project admin –user admin admin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.创建service项目</div></pre></td></tr></table></figure></p>
<p>root@controller:~# openstack project create –domain default \<br>   –description “Service Project” service<br>+————-+———————————-+<br>| Field       | Value                            |<br>+————-+———————————-+<br>| description | Service Project                  |<br>| domain_id   | default                          |<br>| enabled     | True                             |<br>| id          | c0f3b4ac140e4d98a4ec87adbfb54c60 |<br>| is_domain   | False                            |<br>| name        | service                          |<br>| parent_id   | None                             |<br>+————-+———————————-+<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.创建普通用户</div></pre></td></tr></table></figure></p>
<h1 id="创建demo项目"><a href="#创建demo项目" class="headerlink" title="创建demo项目"></a>创建demo项目</h1><p>root@controller:~# openstack project create –domain default \<br>   –description “Demo Project” demo<br>+————-+———————————-+<br>| Field       | Value                            |<br>+————-+———————————-+<br>| description | Demo Project                     |<br>| domain_id   | default                          |<br>| enabled     | True                             |<br>| id          | 89149a8b334a4a05bf50772944d41dad |<br>| is_domain   | False                            |<br>| name        | demo                             |<br>| parent_id   | None                             |<br>+————-+———————————-+</p>
<h1 id="创建demo用户"><a href="#创建demo用户" class="headerlink" title="创建demo用户"></a>创建demo用户</h1><p>root@controller:~# openstack user create –domain default \<br>   –password-prompt demo<br>User Password:<br>Repeat User Password:<br>+———–+———————————-+<br>| Field     | Value                            |<br>+———–+———————————-+<br>| domain_id | default                          |<br>| enabled   | True                             |<br>| id        | c86e83459c21400c9092e4b68aac0e6e |<br>| name      | demo                             |<br>+———–+———————————-+</p>
<h1 id="创建user角色"><a href="#创建user角色" class="headerlink" title="创建user角色"></a>创建user角色</h1><p>root@controller:~# openstack role create user<br>+——-+———————————-+<br>| Field | Value                            |<br>+——-+———————————-+<br>| id    | 48b053ac809d48d58b0032e52be9d057 |<br>| name  | user                             |<br>+——-+———————————-+</p>
<h1 id="分配角色"><a href="#分配角色" class="headerlink" title="分配角色"></a>分配角色</h1><p>root@controller:~# openstack role add –project demo –user demo user<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#### 验证配置</div><div class="line">1.清除原有环境变量</div></pre></td></tr></table></figure></p>
<p>unset OS_TOKEN OS_URL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.使用用户名密码获取token</div></pre></td></tr></table></figure></p>
<p>root@controller:~#  openstack –os-auth-url <a href="http://controller:35357/v3" target="_blank" rel="external">http://controller:35357/v3</a> \<br>   –os-project-domain-id default –os-user-domain-id default \<br>   –os-project-name admin –os-username admin –os-auth-type password \<br>   token issue<br>Password:<br>+————+———————————-+<br>| Field      | Value                            |<br>+————+———————————-+<br>| expires    | 2016-03-24T11:06:17.423633Z      |<br>| id         | d55f1ceaabf14b93aef5516c497c2d7e |<br>| project_id | ae557b315d7c430c929f31b480084ada |<br>| user_id    | 59a21d5fea5a42908d5911635eb92742 |<br>+————+———————————-+<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#### 创建openstack命令行证书文件</div><div class="line">新建文件admin-openrc.sh，并添加如下内容：</div></pre></td></tr></table></figure></p>
<p>export OS_PROJECT_DOMAIN_ID=default<br>export OS_USER_DOMAIN_ID=default<br>export OS_PROJECT_NAME=admin<br>export OS_TENANT_NAME=admin<br>export OS_USERNAME=admin<br>export OS_PASSWORD=root #根据实际填写<br>export OS_AUTH_URL=<a href="http://controller:35357/v3" target="_blank" rel="external">http://controller:35357/v3</a><br>export OS_IDENTITY_API_VERSION=3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">### 安装镜像服务glance</div><div class="line">#### 基础配置准备</div><div class="line">1.进入数据库服务创建glance数据库</div></pre></td></tr></table></figure></p>
<h1 id="创建glance数据库"><a href="#创建glance数据库" class="headerlink" title="创建glance数据库"></a>创建glance数据库</h1><p>CREATE DATABASE glance;<br>分配相应的访问权限<br>GRANT ALL PRIVILEGES ON glance.<em> TO ‘glance’@’localhost’ \<br>  IDENTIFIED BY ‘root’;<br>GRANT ALL PRIVILEGES ON glance.</em> TO ‘glance’@’%’ \<br>  IDENTIFIED BY ‘root’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.source证书文件admin-openrc.sh</div></pre></td></tr></table></figure></p>
<p>root@controller:~# source admin-openrc.sh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.在keystone中创建glance用户信息</div></pre></td></tr></table></figure></p>
<h1 id="创建glance用户"><a href="#创建glance用户" class="headerlink" title="创建glance用户"></a>创建glance用户</h1><p>root@controller:~# openstack user create –domain default –password-prompt glance<br>User Password:<br>Repeat User Password:<br>+———–+———————————-+<br>| Field     | Value                            |<br>+———–+———————————-+<br>| domain_id | default                          |<br>| enabled   | True                             |<br>| id        | dc680f9b12e44ebb93c91dfdeeabcb8f |<br>| name      | glance                           |<br>+———–+———————————-+</p>
<h1 id="为glance用户在service项目添加admin权限"><a href="#为glance用户在service项目添加admin权限" class="headerlink" title="为glance用户在service项目添加admin权限"></a>为glance用户在service项目添加admin权限</h1><p>root@controller:~# openstack role add –project service –user glance admin</p>
<h1 id="创建glance服务"><a href="#创建glance服务" class="headerlink" title="创建glance服务"></a>创建glance服务</h1><p>root@controller:~# openstack service create –name glance \<br>   –description “OpenStack Image service” image<br>+————-+———————————-+<br>| Field       | Value                            |<br>+————-+———————————-+<br>| description | OpenStack Image service          |<br>| enabled     | True                             |<br>| id          | 0fc59e7791d9463085c7f84a39c1f3c8 |<br>| name        | glance                           |<br>| type        | image                            |<br>+————-+———————————-+</p>
<h1 id="创建镜像服务endpoint"><a href="#创建镜像服务endpoint" class="headerlink" title="创建镜像服务endpoint"></a>创建镜像服务endpoint</h1><p>root@controller:~# openstack endpoint create –region RegionOne \<br>   image public <a href="http://controller:9292" target="_blank" rel="external">http://controller:9292</a><br>+————–+———————————-+<br>| Field        | Value                            |<br>+————–+———————————-+<br>| enabled      | True                             |<br>| id           | 9c34be6312974f9dabc8783816771103 |<br>| interface    | public                           |<br>| region       | RegionOne                        |<br>| region_id    | RegionOne                        |<br>| service_id   | 0fc59e7791d9463085c7f84a39c1f3c8 |<br>| service_name | glance                           |<br>| service_type | image                            |<br>| url          | <a href="http://controller:9292" target="_blank" rel="external">http://controller:9292</a>           |<br>+————–+———————————-+<br>root@controller:~# openstack endpoint create –region RegionOne \<br>   image internal <a href="http://controller:9292" target="_blank" rel="external">http://controller:9292</a><br>+————–+———————————-+<br>| Field        | Value                            |<br>+————–+———————————-+<br>| enabled      | True                             |<br>| id           | a6f97076343248ec98ec7a800ec94577 |<br>| interface    | internal                         |<br>| region       | RegionOne                        |<br>| region_id    | RegionOne                        |<br>| service_id   | 0fc59e7791d9463085c7f84a39c1f3c8 |<br>| service_name | glance                           |<br>| service_type | image                            |<br>| url          | <a href="http://controller:9292" target="_blank" rel="external">http://controller:9292</a>           |<br>+————–+———————————-+<br>root@controller:~#  openstack endpoint create –region RegionOne \<br>   image admin <a href="http://controller:9292" target="_blank" rel="external">http://controller:9292</a><br>+————–+———————————-+<br>| Field        | Value                            |<br>+————–+———————————-+<br>| enabled      | True                             |<br>| id           | e01dbccee82a406e8deaae02b6590b44 |<br>| interface    | admin                            |<br>| region       | RegionOne                        |<br>| region_id    | RegionOne                        |<br>| service_id   | 0fc59e7791d9463085c7f84a39c1f3c8 |<br>| service_name | glance                           |<br>| service_type | image                            |<br>| url          | <a href="http://controller:9292" target="_blank" rel="external">http://controller:9292</a>           |<br>+————–+———————————-+<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#### 安装配置glance软件包</div><div class="line">1.安装软件包</div></pre></td></tr></table></figure></p>
<p>apt-get install glance python-glanceclient<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.修改配置文件/etc/glance/glance-api.conf和/etc/glance/glance-registry.conf</div></pre></td></tr></table></figure></p>
<h1 id="修改文件-etc-glance-glance-api-conf"><a href="#修改文件-etc-glance-glance-api-conf" class="headerlink" title="修改文件/etc/glance/glance-api.conf"></a>修改文件/etc/glance/glance-api.conf</h1><p>[database]<br>…<br>connection = mysql+pymysql://glance:GLANCE_DBPASS@controller/glance<br>[keystone_authtoken]<br>…<br>auth_uri = <a href="http://controller:5000" target="_blank" rel="external">http://controller:5000</a><br>auth_url = <a href="http://controller:35357" target="_blank" rel="external">http://controller:35357</a><br>auth_plugin = password<br>project_domain_id = default<br>user_domain_id = default<br>project_name = service<br>username = glance<br>password = root<br>[paste_deploy]<br>…<br>flavor = keystone<br>[glance_store]<br>…<br>default_store = file<br>filesystem_store_datadir = /var/lib/glance/images/<br>[DEFAULT]<br>…<br>notification_driver = noop</p>
<h1 id="verbose-True"><a href="#verbose-True" class="headerlink" title="verbose = True"></a>verbose = True</h1><h1 id="修改配置文件-etc-glance-glance-registry-conf"><a href="#修改配置文件-etc-glance-glance-registry-conf" class="headerlink" title="修改配置文件/etc/glance/glance-registry.conf"></a>修改配置文件/etc/glance/glance-registry.conf</h1><p>[database]<br>…<br>connection = mysql+pymysql://glance:root@controller/glance<br>[keystone_authtoken]<br>…<br>auth_uri = <a href="http://controller:5000" target="_blank" rel="external">http://controller:5000</a><br>auth_url = <a href="http://controller:35357" target="_blank" rel="external">http://controller:35357</a><br>auth_plugin = password<br>project_domain_id = default<br>user_domain_id = default<br>project_name = service<br>username = glance<br>password = root<br>[paste_deploy]<br>…<br>flavor = keystone<br>[DEFAULT]<br>…<br>notification_driver = noop<br>verbose = True<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.同步glance数据库并重启服务</div></pre></td></tr></table></figure></p>
<h1 id="同步数据库"><a href="#同步数据库" class="headerlink" title="同步数据库"></a>同步数据库</h1><p>su -s /bin/sh -c “glance-manage db_sync” glance</p>
<h1 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h1><p>service glance-registry restart<br>service glance-api restart<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p</div><div class="line">#### 验证glance服务</div><div class="line">1.将镜像版本信息写入证书文件admin-openrc.sh</div></pre></td></tr></table></figure></p>
<p>echo “export OS_IMAGE_API_VERSION=2” \<br>  | tee -a admin-openrc.sh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.source文件admin-openrc.sh</div></pre></td></tr></table></figure></p>
<p>source admin-openrc.sh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.下载测试镜像</div></pre></td></tr></table></figure></p>
<p>wget <a href="http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img" target="_blank" rel="external">http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4.在glance创建镜像</div></pre></td></tr></table></figure></p>
<h1 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h1><p>root@controller:~# glance image-create –name “cirros” \<br>   –file cirros-0.3.4-x86_64-disk.img \<br>   –disk-format qcow2 –container-format bare \<br>   –visibility public –progress<br>[=============================&gt;] 100%<br>+——————+————————————–+<br>| Property         | Value                                |<br>+——————+————————————–+<br>| checksum         | ee1eca47dc88f4879d8a229cc70a07c6     |<br>| container_format | bare                                 |<br>| created_at       | 2016-03-25T06:23:07Z                 |<br>| disk_format      | qcow2                                |<br>| id               | 67cfd037-5704-4432-9b2c-cf5fffdb6319 |<br>| min_disk         | 0                                    |<br>| min_ram          | 0                                    |<br>| name             | cirros                               |<br>| owner            | ae557b315d7c430c929f31b480084ada     |<br>| protected        | False                                |<br>| size             | 13287936                             |<br>| status           | active                               |<br>| tags             | []                                   |<br>| updated_at       | 2016-03-25T06:23:08Z                 |<br>| virtual_size     | None                                 |<br>| visibility       | public                               |<br>+——————+————————————–+<br>]]</p>
<h1 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h1><p>root@controller:~# glance image-list<br>+————————————–+——–+<br>| ID                                   | Name   |<br>+————————————–+——–+<br>| 67cfd037-5704-4432-9b2c-cf5fffdb6319 | cirros |<br>+————————————–+——–+<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">### 安装计算服务Nova</div><div class="line">#### 安装控制节点</div><div class="line">##### 前期准备</div><div class="line">1.创建nova数据库，并分配权限</div></pre></td></tr></table></figure></p>
<h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><p>CREATE DATABASE nova;</p>
<h1 id="分配访问权限"><a href="#分配访问权限" class="headerlink" title="分配访问权限"></a>分配访问权限</h1><p>GRANT ALL PRIVILEGES ON nova.<em> TO ‘nova’@’localhost’ \<br>  IDENTIFIED BY ‘NOVA_DBPASS’;<br>GRANT ALL PRIVILEGES ON nova.</em> TO ‘nova’@’%’ \<br>  IDENTIFIED BY ‘NOVA_DBPASS’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.在keystone中创建nova用户,服务以及endpoint</div></pre></td></tr></table></figure></p>
<h1 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h1><p>root@controller:~# openstack user create –domain default –password-prompt nova<br>User Password:<br>Repeat User Password:<br>+———–+———————————-+<br>| Field     | Value                            |<br>+———–+———————————-+<br>| domain_id | default                          |<br>| enabled   | True                             |<br>| id        | 77a5b14032ed484ebeefa981e1c0ac00 |<br>| name      | nova                             |<br>+———–+———————————-+</p>
<h1 id="给nova添加admin权限"><a href="#给nova添加admin权限" class="headerlink" title="给nova添加admin权限"></a>给nova添加admin权限</h1><p>root@controller:~# openstack role add –project service –user nova admin</p>
<h1 id="创建nova服务"><a href="#创建nova服务" class="headerlink" title="创建nova服务"></a>创建nova服务</h1><p>root@controller:~# openstack service create –name nova \<br>   –description “OpenStack Compute” compute<br>+————-+———————————-+<br>| Field       | Value                            |<br>+————-+———————————-+<br>| description | OpenStack Compute                |<br>| enabled     | True                             |<br>| id          | 023a040a53b44ff69cb9d5d8f210323b |<br>| name        | nova                             |<br>| type        | compute                          |<br>+————-+———————————-+</p>
<h1 id="添加endpoint"><a href="#添加endpoint" class="headerlink" title="添加endpoint"></a>添加endpoint</h1><p>root@controller:~# openstack endpoint create –region RegionOne \<br>   compute public <a href="http://controller:8774/v2/%\(tenant_id\)s" target="_blank" rel="external">http://controller:8774/v2/%\(tenant_id\)s</a><br>+————–+—————————————–+<br>| Field        | Value                                   |<br>+————–+—————————————–+<br>| enabled      | True                                    |<br>| id           | df485e2cbf9b414ab57be9d9a0d9b253        |<br>| interface    | public                                  |<br>| region       | RegionOne                               |<br>| region_id    | RegionOne                               |<br>| service_id   | 023a040a53b44ff69cb9d5d8f210323b        |<br>| service_name | nova                                    |<br>| service_type | compute                                 |<br>| url          | <a href="http://controller:8774/v2/%(tenant_id)s" target="_blank" rel="external">http://controller:8774/v2/%(tenant_id)s</a> |<br>+————–+—————————————–+<br>root@controller:~# openstack endpoint create –region RegionOne \<br>   compute internal <a href="http://controller:8774/v2/%\(tenant_id\)s" target="_blank" rel="external">http://controller:8774/v2/%\(tenant_id\)s</a><br>+————–+—————————————–+<br>| Field        | Value                                   |<br>+————–+—————————————–+<br>| enabled      | True                                    |<br>| id           | bf83399e62c0481593d3c923ddce2820        |<br>| interface    | internal                                |<br>| region       | RegionOne                               |<br>| region_id    | RegionOne                               |<br>| service_id   | 023a040a53b44ff69cb9d5d8f210323b        |<br>| service_name | nova                                    |<br>| service_type | compute                                 |<br>| url          | <a href="http://controller:8774/v2/%(tenant_id)s" target="_blank" rel="external">http://controller:8774/v2/%(tenant_id)s</a> |<br>+————–+—————————————–+<br>root@controller:~# openstack endpoint create –region RegionOne \<br>   compute admin <a href="http://controller:8774/v2/%\(tenant_id\)s" target="_blank" rel="external">http://controller:8774/v2/%\(tenant_id\)s</a><br>+————–+—————————————–+<br>| Field        | Value                                   |<br>+————–+—————————————–+<br>| enabled      | True                                    |<br>| id           | 1a3972fe66f243b08bbc5e98e27b3110        |<br>| interface    | admin                                   |<br>| region       | RegionOne                               |<br>| region_id    | RegionOne                               |<br>| service_id   | 023a040a53b44ff69cb9d5d8f210323b        |<br>| service_name | nova                                    |<br>| service_type | compute                                 |<br>| url          | <a href="http://controller:8774/v2/%(tenant_id)s" target="_blank" rel="external">http://controller:8774/v2/%(tenant_id)s</a> |<br>+————–+—————————————–+<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">##### 安装nova软件包并配置</div><div class="line">1.安装软件包</div></pre></td></tr></table></figure></p>
<p> apt-get install nova-api nova-cert nova-conductor \<br>   nova-consoleauth nova-novncproxy nova-scheduler \<br>     python-novaclient<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.编辑配置文件/etc/nova/nova.conf 修改以下配置</div></pre></td></tr></table></figure></p>
<p>[database]<br>…<br>connection = mysql+pymysql://nova:root@controller/nova<br>[DEFAULT]<br>…<br>rpc_backend = rabbit<br>[oslo_messaging_rabbit]<br>…<br>rabbit_host = controller<br>rabbit_userid = openstack<br>rabbit_password = root<br>…<br>auth_strategy = keystone<br>…<br>my_ip = 192.168.2.2<br>…<br>network_api_class = nova.network.neutronv2.api.API<br>security_group_api = neutron<br>linuxnet_interface_driver = nova.network.linux_net.NeutronLinuxBridgeInterfaceDriver<br>firewall_driver = nova.virt.firewall.NoopFirewallDriver<br>…<br>enabled_apis=osapi_compute,metadata<br>…<br>verbose = True<br>[keystone_authtoken]<br>…<br>auth_uri = <a href="http://controller:5000" target="_blank" rel="external">http://controller:5000</a><br>auth_url = <a href="http://controller:35357" target="_blank" rel="external">http://controller:35357</a><br>auth_plugin = password<br>project_domain_id = default<br>user_domain_id = default<br>project_name = service<br>username = nova<br>password = root<br>[vnc]<br>…<br>vncserver_listen = $my_ip<br>vncserver_proxyclient_address = $my_ip<br>[glance]<br>…<br>host = controller<br>[oslo_concurrency]<br>…<br>lock_path = /var/lib/nova/tmp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.同步数据库</div></pre></td></tr></table></figure></p>
<p>su -s /bin/sh -c “nova-manage db sync” nova<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4.重启nova服务</div></pre></td></tr></table></figure></p>
<p>service nova-api restart<br>service nova-cert restart<br>service nova-consoleauth restart<br>service nova-scheduler restart<br>service nova-conductor restart<br>service nova-novncproxy restart<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">### 安装计算节点</div><div class="line">1.安装软件包</div></pre></td></tr></table></figure></p>
<p>apt-get install nova-compute sysfsutils<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.修改配置文件/etc/nova/nova.conf</div></pre></td></tr></table></figure></p>
<p>[DEFAULT]<br>…<br>rpc_backend = rabbit<br>…<br>auth_strategy = keystone<br>…<br>my_ip = 192.168.2.2 # compute节点的ip地址<br>…<br>network_api_class = nova.network.neutronv2.api.API<br>security_group_api = neutron<br>linuxnet_interface_driver = nova.network.linux_net.NeutronLinuxBridgeInterfaceDriver<br>firewall_driver = nova.virt.firewall.NoopFirewallDriver<br>…<br>verbose = True<br>[oslo_messaging_rabbit]<br>…<br>rabbit_host = controller<br>rabbit_userid = openstack<br>rabbit_password = root<br>[keystone_authtoken]<br>…<br>auth_uri = <a href="http://controller:5000" target="_blank" rel="external">http://controller:5000</a><br>auth_url = <a href="http://controller:35357" target="_blank" rel="external">http://controller:35357</a><br>auth_plugin = password<br>project_domain_id = default<br>user_domain_id = default<br>project_name = service<br>username = nova<br>password = root<br>[vnc]<br>…<br>enabled = True<br>vncserver_listen = 0.0.0.0<br>vncserver_proxyclient_address = $my_ip<br>novncproxy_base_url = <a href="http://controller:6080/vnc_auto.html" target="_blank" rel="external">http://controller:6080/vnc_auto.html</a><br>[glance]<br>…<br>host = controller<br>[oslo_concurrency]<br>…<br>lock_path = /var/lib/nova/tmp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.验证是否支持虚拟化</div></pre></td></tr></table></figure></p>
<h1 id="执行以下命令如果返回０则表示不支持"><a href="#执行以下命令如果返回０则表示不支持" class="headerlink" title="执行以下命令如果返回０则表示不支持"></a>执行以下命令如果返回０则表示不支持</h1><p>egrep -c ‘(vmx|svm)’ /proc/cpuinfo</p>
<h1 id="我们的环境是在虚拟化环境中所以肯定不支持再次虚拟化，所以需要在-etc-nova-nova-compute-conf中做如下配置"><a href="#我们的环境是在虚拟化环境中所以肯定不支持再次虚拟化，所以需要在-etc-nova-nova-compute-conf中做如下配置" class="headerlink" title="我们的环境是在虚拟化环境中所以肯定不支持再次虚拟化，所以需要在/etc/nova/nova-compute.conf中做如下配置"></a>我们的环境是在虚拟化环境中所以肯定不支持再次虚拟化，所以需要在/etc/nova/nova-compute.conf中做如下配置</h1><p>[libvirt]<br>…<br>virt_type = qemu # 如果支持的话可以设置为kvm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4.重启nova compute服务</div></pre></td></tr></table></figure></p>
<p>service nova-compute restart<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">### 验证服务</div><div class="line">在控制节点执行以下命令</div></pre></td></tr></table></figure></p>
<h1 id="列出nova所有服务列表"><a href="#列出nova所有服务列表" class="headerlink" title="列出nova所有服务列表"></a>列出nova所有服务列表</h1><p>root@controller:~# nova service-list<br>+—-+——————+————+———-+———+——-+—————————-+—————–+<br>| Id | Binary           | Host       | Zone     | Status  | State | Updated_at                 | Disabled Reason |<br>+—-+——————+————+———-+———+——-+—————————-+—————–+<br>| 1  | nova-cert        | controller | internal | enabled | up    | 2016-03-27T11:48:59.000000 | -               |<br>| 2  | nova-consoleauth | controller | internal | enabled | up    | 2016-03-27T11:48:59.000000 | -               |<br>| 3  | nova-conductor   | controller | internal | enabled | up    | 2016-03-27T11:48:59.000000 | -               |<br>| 4  | nova-scheduler   | controller | internal | enabled | up    | 2016-03-27T11:48:59.000000 | -               |<br>| 5  | nova-compute     | compute    | nova     | enabled | up    | 2016-03-27T11:48:59.000000 | -               |<br>+—-+——————+————+———-+———+——-+—————————-+—————–+</p>
<h1 id="查看镜像-1"><a href="#查看镜像-1" class="headerlink" title="查看镜像"></a>查看镜像</h1><p>root@controller:~# nova image-list<br>+————————————–+——–+——–+——–+<br>| ID                                   | Name   | Status | Server |<br>+————————————–+——–+——–+——–+<br>| 67cfd037-5704-4432-9b2c-cf5fffdb6319 | cirros | ACTIVE |        |<br>+————————————–+——–+——–+——–+<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">### 安装网络服务neutron</div><div class="line">#### 安装控制节点</div><div class="line">1.创建neutron数据库并分配相应权限</div></pre></td></tr></table></figure></p>
<h1 id="创建数据库-1"><a href="#创建数据库-1" class="headerlink" title="创建数据库"></a>创建数据库</h1><p>CREATE DATABASE neutron;</p>
<h1 id="分配访问权限-1"><a href="#分配访问权限-1" class="headerlink" title="分配访问权限"></a>分配访问权限</h1><p>GRANT ALL PRIVILEGES ON neutron.<em> TO ‘neutron’@’localhost’ \<br>  IDENTIFIED BY ‘root’;<br>GRANT ALL PRIVILEGES ON neutron.</em> TO ‘neutron’@’%’ \<br>  IDENTIFIED BY ‘root’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.在keystone中创建neutron服务以及endpoint</div></pre></td></tr></table></figure></p>
<h1 id="创建neutron用户"><a href="#创建neutron用户" class="headerlink" title="创建neutron用户"></a>创建neutron用户</h1><p>root@controller:~# openstack user create –domain default –password-prompt neutron<br>User Password:<br>Repeat User Password:<br>+———–+———————————-+<br>| Field     | Value                            |<br>+———–+———————————-+<br>| domain_id | default                          |<br>| enabled   | True                             |<br>| id        | a8edd66b5dc64ce2b2a37cf66546297f |<br>| name      | neutron                          |<br>+———–+———————————-+</p>
<h1 id="给neutron用户分配admin权限"><a href="#给neutron用户分配admin权限" class="headerlink" title="给neutron用户分配admin权限"></a>给neutron用户分配admin权限</h1><p>root@controller:~# openstack role add –project service –user neutron admin</p>
<h1 id="创建neutron服务"><a href="#创建neutron服务" class="headerlink" title="创建neutron服务"></a>创建neutron服务</h1><p>root@controller:~# openstack service create –name neutron \<br>   –description “OpenStack Networking” network<br>+————-+———————————-+<br>| Field       | Value                            |<br>+————-+———————————-+<br>| description | OpenStack Networking             |<br>| enabled     | True                             |<br>| id          | 4a3333006f844469b2ae735014a24ec9 |<br>| name        | neutron                          |<br>| type        | network                          |<br>+————-+———————————-+</p>
<h1 id="创建网络服务endpoint"><a href="#创建网络服务endpoint" class="headerlink" title="创建网络服务endpoint"></a>创建网络服务endpoint</h1><p>root@controller:~# openstack endpoint create –region RegionOne \<br>   network public <a href="http://controller:9696" target="_blank" rel="external">http://controller:9696</a><br>+————–+———————————-+<br>| Field        | Value                            |<br>+————–+———————————-+<br>| enabled      | True                             |<br>| id           | e7b234ba729b46cbbaa86db2df71e0f2 |<br>| interface    | public                           |<br>| region       | RegionOne                        |<br>| region_id    | RegionOne                        |<br>| service_id   | 4a3333006f844469b2ae735014a24ec9 |<br>| service_name | neutron                          |<br>| service_type | network                          |<br>| url          | <a href="http://controller:9696" target="_blank" rel="external">http://controller:9696</a>           |<br>+————–+———————————-+<br>root@controller:~# openstack endpoint create –region RegionOne \<br>   network internal <a href="http://controller:9696" target="_blank" rel="external">http://controller:9696</a><br>+————–+———————————-+<br>| Field        | Value                            |<br>+————–+———————————-+<br>| enabled      | True                             |<br>| id           | fadda1557ca846edbeab3f6f8dc79823 |<br>| interface    | internal                         |<br>| region       | RegionOne                        |<br>| region_id    | RegionOne                        |<br>| service_id   | 4a3333006f844469b2ae735014a24ec9 |<br>| service_name | neutron                          |<br>| service_type | network                          |<br>| url          | <a href="http://controller:9696" target="_blank" rel="external">http://controller:9696</a>           |<br>+————–+———————————-+<br>root@controller:~# openstack endpoint create –region RegionOne \<br>   network admin <a href="http://controller:9696" target="_blank" rel="external">http://controller:9696</a><br>+————–+———————————-+<br>| Field        | Value                            |<br>+————–+———————————-+<br>| enabled      | True                             |<br>| id           | 3f9866732fd84b70bb14e00fcee597a3 |<br>| interface    | admin                            |<br>| region       | RegionOne                        |<br>| region_id    | RegionOne                        |<br>| service_id   | 4a3333006f844469b2ae735014a24ec9 |<br>| service_name | neutron                          |<br>| service_type | network                          |<br>| url          | <a href="http://controller:9696" target="_blank" rel="external">http://controller:9696</a>           |<br>+————–+———————————-+<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.安装neutron软件（根据Self-service网络方式）</div></pre></td></tr></table></figure></p>
<p>apt-get install neutron-server neutron-plugin-ml2 \<br>  neutron-plugin-linuxbridge-agent neutron-l3-agent neutron-dhcp-agent \<br>    neutron-metadata-agent python-neutronclient conntrack<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4.修改配置文件/etc/neutron/neutron.conf</div></pre></td></tr></table></figure></p>
<p>[database]<br>…<br>connection = mysql+pymysql://neutron:root@controller/neutron<br>[DEFAULT]<br>…<br>core_plugin = ml2<br>service_plugins = router<br>allow_overlapping_ips = True<br>…<br>rpc_backend = rabbit<br>…<br>auth_strategy = keystone<br>…<br>notify_nova_on_port_status_changes = True<br>notify_nova_on_port_data_changes = True<br>nova_url = <a href="http://controller:8774/v2" target="_blank" rel="external">http://controller:8774/v2</a><br>…<br>verbose = True<br>[oslo_messaging_rabbit]<br>…<br>rabbit_host = controller<br>rabbit_userid = openstack<br>rabbit_password = RABBIT_PASS<br>[keystone_authtoken]<br>…<br>auth_uri = <a href="http://controller:5000" target="_blank" rel="external">http://controller:5000</a><br>auth_url = <a href="http://controller:35357" target="_blank" rel="external">http://controller:35357</a><br>auth_plugin = password<br>project_domain_id = default<br>user_domain_id = default<br>project_name = service<br>username = neutron<br>password = NEUTRON_PASS<br>[nova]<br>…<br>auth_url = <a href="http://controller:35357" target="_blank" rel="external">http://controller:35357</a><br>auth_plugin = password<br>project_domain_id = default<br>user_domain_id = default<br>region_name = RegionOne<br>project_name = service<br>username = nova<br>password = NOVA_PASS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">5.修改配置文件/etc/neutron/plugins/ml2/ml2_conf.ini</div></pre></td></tr></table></figure></p>
<p>[ml2]<br>…<br>type_drivers = flat,vlan,vxlan<br>…<br>tenant_network_types = vxlan<br>…<br>mechanism_drivers = linuxbridge,l2population<br>…<br>extension_drivers = port_security<br>[ml2_type_flat]<br>…<br>flat_networks = public<br>[ml2_type_vxlan]<br>…<br>vni_ranges = 1:1000<br>[securitygroup]<br>…<br>enable_ipset = True<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">6.修改配置文件/etc/neutron/plugins/ml2/linuxbridge_agent.ini</div></pre></td></tr></table></figure></p>
<p>[linux_bridge]<br>physical_interface_mappings = public:eth0<br>[vxlan]<br>enable_vxlan = True<br>local_ip = 192.168.2.2<br>l2_population = True<br>[agent]<br>…<br>prevent_arp_spoofing = True<br>[securitygroup]<br>…<br>enable_security_group = True<br>firewall_driver = neutron.agent.linux.iptables_firewall.IptablesFirewallDriver<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">7.修改配置文件/etc/neutron/l3_agent.ini</div></pre></td></tr></table></figure></p>
<p>[DEFAULT]<br>…<br>interface_driver = neutron.agent.linux.interface.BridgeInterfaceDriver<br>…<br>verbose = True<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">8.修改配置文件/etc/neutron/dhcp_agent.ini</div></pre></td></tr></table></figure></p>
<p>[DEFAULT]<br>…<br>interface_driver = neutron.agent.linux.interface.BridgeInterfaceDriver<br>dhcp_driver = neutron.agent.linux.dhcp.Dnsmasq<br>enable_isolated_metadata = True<br>…<br>verbose = True<br>…<br>dnsmasq_config_file = /etc/neutron/dnsmasq-neutron.conf</p>
<h1 id="创建文件-etc-neutron-dnsmasq-neutron-conf并写入如下内容"><a href="#创建文件-etc-neutron-dnsmasq-neutron-conf并写入如下内容" class="headerlink" title="创建文件/etc/neutron/dnsmasq-neutron.conf并写入如下内容"></a>创建文件/etc/neutron/dnsmasq-neutron.conf并写入如下内容</h1><p>dhcp-option-force=26,1450<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">9.修改配置文件/etc/neutron/metadata_agent.ini</div></pre></td></tr></table></figure></p>
<p>[DEFAULT]<br>…<br>auth_uri = <a href="http://controller:5000" target="_blank" rel="external">http://controller:5000</a><br>auth_url = <a href="http://controller:35357" target="_blank" rel="external">http://controller:35357</a><br>auth_region = RegionOne<br>auth_plugin = password<br>project_domain_id = default<br>user_domain_id = default<br>project_name = service<br>username = neutron<br>password = root<br>…<br>nova_metadata_ip = controller<br>…<br>metadata_proxy_shared_secret = root<br>…<br>verbose = True<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10.修改配置文件/etc/nova/nova.conf</div></pre></td></tr></table></figure></p>
<p>[neutron]<br>…<br>url = <a href="http://controller:9696" target="_blank" rel="external">http://controller:9696</a><br>auth_url = <a href="http://controller:35357" target="_blank" rel="external">http://controller:35357</a><br>auth_plugin = password<br>project_domain_id = default<br>user_domain_id = default<br>region_name = RegionOne<br>project_name = service<br>username = neutron<br>password = root<br>service_metadata_proxy = True<br>metadata_proxy_shared_secret = root<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">11.同步数据库</div></pre></td></tr></table></figure></p>
<p>su -s /bin/sh -c “neutron-db-manage –config-file /etc/neutron/neutron.conf \<br>  –config-file /etc/neutron/plugins/ml2/ml2_conf.ini upgrade head” neutron<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">12.重启服务</div></pre></td></tr></table></figure></p>
<h1 id="重启nova"><a href="#重启nova" class="headerlink" title="重启nova"></a>重启nova</h1><p>service nova-api restart</p>
<h1 id="重启neutron"><a href="#重启neutron" class="headerlink" title="重启neutron"></a>重启neutron</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#### 安装计算节点</div><div class="line">1.安装软件包</div></pre></td></tr></table></figure>
<p>apt-get install neutron-plugin-linuxbridge-agent conntrack<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.修改配置文件/etc/neutron/neutron.conf</div></pre></td></tr></table></figure></p>
<p>[DEFAULT]<br>…<br>rpc_backend = rabbit<br>…<br>auth_strategy = keystone<br>…<br>verbose = True<br>[oslo_messaging_rabbit]<br>…<br>rabbit_host = controller<br>rabbit_userid = openstack<br>rabbit_password = root<br>[keystone_authtoken]<br>…<br>auth_uri = <a href="http://controller:5000" target="_blank" rel="external">http://controller:5000</a><br>auth_url = <a href="http://controller:35357" target="_blank" rel="external">http://controller:35357</a><br>auth_plugin = password<br>project_domain_id = default<br>user_domain_id = default<br>project_name = service<br>username = neutron<br>password = root<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.修改配置文件/etc/neutron/plugins/ml2/linuxbridge_agent.ini</div></pre></td></tr></table></figure></p>
<p>[linux_bridge]<br>physical_interface_mappings = public:eth0<br>[vxlan]<br>enable_vxlan = True<br>local_ip = 192.168.2.6<br>l2_population = True<br>[agent]<br>…<br>prevent_arp_spoofing = True<br>[securitygroup]<br>…<br>enable_security_group = True<br>firewall_driver = neutron.agent.linux.iptables_firewall.IptablesFirewallDriver<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4.修改配置文件/etc/nova/nova.conf</div></pre></td></tr></table></figure></p>
<p>[neutron]<br>…<br>url = <a href="http://controller:9696" target="_blank" rel="external">http://controller:9696</a><br>auth_url = <a href="http://controller:35357" target="_blank" rel="external">http://controller:35357</a><br>auth_plugin = password<br>project_domain_id = default<br>user_domain_id = default<br>region_name = RegionOne<br>project_name = service<br>username = neutron<br>password = root<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">5.重启服务</div></pre></td></tr></table></figure></p>
<h1 id="重启nova-compute"><a href="#重启nova-compute" class="headerlink" title="重启nova-compute"></a>重启nova-compute</h1><p>service nova-compute restart</p>
<h1 id="重启网络服务"><a href="#重启网络服务" class="headerlink" title="重启网络服务"></a>重启网络服务</h1><p>service neutron-plugin-linuxbridge-agent restart<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">6.验证</div></pre></td></tr></table></figure></p>
<h1 id="验证是否成功加载插件"><a href="#验证是否成功加载插件" class="headerlink" title="验证是否成功加载插件"></a>验证是否成功加载插件</h1><p>root@controller:~# neutron ext-list<br>+———————–+———————————————–+<br>| alias                 | name                                          |<br>+———————–+———————————————–+<br>| dns-integration       | DNS Integration                               |<br>| ext-gw-mode           | Neutron L3 Configurable external gateway mode |<br>| binding               | Port Binding                                  |<br>| agent                 | agent                                         |<br>| subnet_allocation     | Subnet Allocation                             |<br>| l3_agent_scheduler    | L3 Agent Scheduler                            |<br>| external-net          | Neutron external network                      |<br>| flavors               | Neutron Service Flavors                       |<br>| net-mtu               | Network MTU                                   |<br>| quotas                | Quota management support                      |<br>| l3-ha                 | HA Router extension                           |<br>| provider              | Provider Network                              |<br>| multi-provider        | Multi Provider Network                        |<br>| extraroute            | Neutron Extra Route                           |<br>| router                | Neutron L3 Router                             |<br>| extra_dhcp_opt        | Neutron Extra DHCP opts                       |<br>| security-group        | security-group                                |<br>| dhcp_agent_scheduler  | DHCP Agent Scheduler                          |<br>| rbac-policies         | RBAC Policies                                 |<br>| port-security         | Port Security                                 |<br>| allowed-address-pairs | Allowed Address Pairs                         |<br>| dvr                   | Distributed Virtual Router                    |<br>+———————–+———————————————–+</p>
<h1 id="验证neutron-agents是否正确"><a href="#验证neutron-agents是否正确" class="headerlink" title="验证neutron agents是否正确"></a>验证neutron agents是否正确</h1><p>root@controller:~# neutron agent-list<br>+————————————–+——————–+————+——-+—————-+—————————+<br>| id                                   | agent_type         | host       | alive | admin_state_up | binary                    |<br>+————————————–+——————–+————+——-+—————-+—————————+<br>| 28e6e70f-063e-433a-943f-ded82ec083fb | Metadata agent     | controller | :-)   | True           | neutron-metadata-agent    |<br>| 2abdf6a3-f0cd-4a3e-87a3-def58f03aeba | Linux bridge agent | controller | :-)   | True           | neutron-linuxbridge-agent |<br>| 5e78f457-95f6-4e95-929d-268d35f49037 | DHCP agent         | controller | :-)   | True           | neutron-dhcp-agent        |<br>| 82c1d9fa-a906-45fc-9a56-56390c8a35fb | L3 agent           | controller | :-)   | True           | neutron-l3-agent          |<br>| dbbb522e-a424-4606-8a69-77250154e5d3 | Linux bridge agent | compute    | :-)   | True           | neutron-linuxbridge-agent |<br>+————————————–+——————–+————+——-+—————-+—————————+<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">### 安装面板服务horizon</div><div class="line">1.安装horizon软件包</div></pre></td></tr></table></figure></p>
<p>apt-get install openstack-dashboard<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.修改配置文件</div></pre></td></tr></table></figure></p>
<p>OPENSTACK_HOST = “controller”<br>ALLOWED_HOSTS = [‘*’, ]<br>CACHES = {<br>    ‘default’: {<br>        ‘BACKEND’: ‘django.core.cache.backends.memcached.MemcachedCache’,<br>        ‘LOCATION’: ‘127.0.0.1:11211’,<br>    }<br>}<br>OPENSTACK_KEYSTONE_DEFAULT_ROLE = “user”<br>OPENSTACK_KEYSTONE_MULTIDOMAIN_SUPPORT = True<br>OPENSTACK_API_VERSIONS = {<br>    “identity”: 3,<br>    “volume”: 2,<br>}<br>OPENSTACK_NEUTRON_NETWORK = {<br>    ‘enable_router’: False,<br>    ‘enable_quotas’: False,<br>    ‘enable_distributed_router’: False,<br>    ‘enable_ha_router’: False,<br>    ‘enable_lb’: False,<br>    ‘enable_firewall’: False,<br>    ‘enable_vpn’: False,<br>    ‘enable_fip_topology_check’: False,<br>}<br>TIME_ZONE = “TIME_ZONE”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3.验证面板</div></pre></td></tr></table></figure></p>
<p>登入面板测试面板可用性<br>```</p>
]]></content>
      
        <categories>
            
            <category> Openstack </category>
            
        </categories>
        
        
        <tags>
            
            <tag> openstack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DNS域名含义解析]]></title>
      <url>http://www.pisces.ml/2016/03/22/dns/</url>
      <content type="html"><![CDATA[<p>域名注册完成后首先需要做域名解析，域名解析就是把域名指向网站所在服务器的IP，让人们通过注册的域名可以访问到网站。IP地址是网络上标识服务器的数字地址，为了方便记忆，使用域名来代替IP地址。域名解析就是域名到IP地址的转换过程，域名的解析工作由DNS服务器完成。DNS服务器会把域名解析到一个IP地址，然后在此IP地址的主机上将一个子目录与域名绑定。域名解析时会添加解析记录，这些记录有：A记录、AAAA记录、CNAME记录、MX记录、NS记录、TXT记录、SRV记录、URL转发。</p>
<h2 id="DNS域名解析记录"><a href="#DNS域名解析记录" class="headerlink" title="DNS域名解析记录"></a>DNS域名解析记录</h2><p><strong>A记录</strong>： 将域名指向一个IPv4地址（例如：100.100.100.100），需要增加A记录<br><strong>CNAME记录</strong>： 如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。这个域名一般是主机服务商提供的一个域名<br><strong>MX记录</strong>： 建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录。建立邮箱时，一般会根据邮箱服务商提供的MX记录填写此记录<br><strong>NS记录</strong>： 域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录<br><strong>TXT记录</strong>： 可任意填写，可为空。一般做一些验证记录时会使用此项，如：做SPF（反垃圾邮件）记录<br><strong>AAAA记录</strong>： 将主机名（或域名）指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1），需要添加AAAA记录<br><strong>SRV记录</strong>： 添加服务记录服务器服务记录时会添加此项，SRV记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）。<br><strong>SOA记录</strong>： SOA叫做起始授权机构记录，NS用于标识多台域名解析服务器，SOA记录用于在众多NS记录中那一台是主服务器<br><strong>PTR记录</strong>： PTR记录是A记录的逆向记录，又称做IP反查记录或指针记录，负责将IP反向解析为域名<br><strong>显性URL转发记录</strong>： 将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址。例如：将www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址为：www.itbilu.com。<br><strong>隐性UR转发记录</strong>： 将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址，隐性转发会隐藏真实的目标地址。例如：将www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址仍然是：www.picses.ga。</p>
<h2 id="DNS解析中的问题"><a href="#DNS解析中的问题" class="headerlink" title="DNS解析中的问题"></a>DNS解析中的问题</h2><h3 id="A记录与CNAME记录"><a href="#A记录与CNAME记录" class="headerlink" title="A记录与CNAME记录"></a>A记录与CNAME记录</h3><p>A记录是把一个域名解析到一个IP地址，而CNAME记录是把域名解析到另外一个域名，而这个域名最终会指向一个A记录，在功能实现在上A记录与CNAME记录没有区别。<br>CNAME记录在做IP地址变更时要比A记录方便。CNAME记录允许将多个名字映射到同一台计算机，当有多个域名需要指向同一服务器IP，此时可以将一个域名做A记录指向服务器IP，然后将其他的域名做别名(即：CNAME)到A记录的域名上。当服务器IP地址变更时，只需要更改A记录的那个域名到新IP上，其它做别名的域名会自动更改到新的IP地址上，而不必对每个域名做更改。</p>
<h3 id="A记录与AAAA记录"><a href="#A记录与AAAA记录" class="headerlink" title="A记录与AAAA记录"></a>A记录与AAAA记录</h3><p>二者都是指向一个IP地址，但对应的IP版本不同。A记录指向IPv4地址，AAAA记录指向IPv6地址。AAAA记录是A记录的升级版本。</p>
<h3 id="IPv4与IPv6"><a href="#IPv4与IPv6" class="headerlink" title="IPv4与IPv6"></a>IPv4与IPv6</h3><p>IPv4，是互联网协议（Internet Protocol，IP）的第四版，也是第一个被广泛使用的版本，是构成现今互联网技术的基础协议。IPv4 的下一个版本就是IPv6，在将来将取代目前被广泛使用的IPv4。<br>IPv4中规定IP地址长度为32位（按TCP/IP参考模型划分) ，即有2^32-1个地址。IPv6的提出最早是为了解决，随着互联网的迅速发展IPv4地址空间将被耗尽的问题。为了扩大地址空间，IPv6将IP地址的长度由32位增加到了128位。在IPv6的设计过程中除了一劳永逸地解决了地址短缺问题以外，还解决了IPv4中的其它问题，如：端到端IP连接、服务质量（QoS）、安全性、多播、移动性、即插即用等。</p>
<h3 id="TTL值"><a href="#TTL值" class="headerlink" title="TTL值"></a>TTL值</h3><p>TTL－生存时间（Time To Live），表示解析记录在DNS服务器中的缓存时间，TTL的时间长度单位是秒，一般为3600秒。比如：在访问www.itbilu.com时，如果在DNS服务器的缓存中没有该记录，就会向某个NS服务器发出请求，获得该记录后，该记录会在DNS服务器上保存TTL的时间长度，在TTL有效期内访问www.itbilu.com，DNS服务器会直接缓存中返回刚才的记录。</p>
]]></content>
      
        <categories>
            
            <category> Network </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://www.pisces.ml/2016/01/22/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <url>http://www.pisces.ml/404.html</url>
      <content type="html"><![CDATA[<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Page Not Found</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        * {
            line-height: 1.2;
            margin: 0;
        }
        html {
            color: #888;
            display: table;
            font-family: sans-serif;
            height: 100%;
            text-align: center;
            width: 100%;
        }
        body {
            display: table-cell;
            vertical-align: middle;
            margin: 2em auto;
        }
        h1 {
            color: #555;
            font-size: 2em;
            font-weight: 400;
        }
        p {
            margin: 0 auto;
            width: 280px;
        }
        @media only screen and (max-width: 280px) {
            body, p {
                width: 95%;
            }
            h1 {
                font-size: 1.5em;
                margin: 0 0 0.3em;
            }
        }
    </style>
</head>
<body>
    <h1>Page Not Found</h1>
    <p>Sorry, but the page you were trying to view does not exist.</p>
    <script type="text/javascript" src="http://www.qq.com/404/search_children.js" charset="utf-8"></script>script>
</body>
</html>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[分类]]></title>
      <url>http://www.pisces.ml/categories/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[about]]></title>
      <url>http://www.pisces.ml/about/index.html</url>
      <content type="html"><![CDATA[<h2 id="知识整理"><a href="#知识整理" class="headerlink" title="知识整理"></a>知识整理</h2><h3 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h3><ol>
<li><a href="https://www.zifangsky.cn/627.html" target="_blank" rel="external">zabbix自定义脚本实现短信报警提醒</a></li>
</ol>
<h3 id="kvm虚拟机"><a href="#kvm虚拟机" class="headerlink" title="kvm虚拟机"></a>kvm虚拟机</h3><ol>
<li><a href="http://my.oschina.net/u/3062408/blog/803865" target="_blank" rel="external">KVM的虚拟机网络配置</a></li>
</ol>
<h3 id="运维知识学习"><a href="#运维知识学习" class="headerlink" title="运维知识学习"></a>运维知识学习</h3><ol>
<li><a href="http://ansible-tran.readthedocs.io/en/latest/docs/intro_installation.html" target="_blank" rel="external">Ansible中文权威指南</a></li>
<li><a href="https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Linux/7/html/High_Availability_Add-On_Reference/ch-overview-HAAR.html" target="_blank" rel="external">Pacemaker使用指南</a></li>
</ol>
<h3 id="git技能提升"><a href="#git技能提升" class="headerlink" title="git技能提升"></a>git技能提升</h3><ol>
<li><a href="https://github.com/edx/edx-platform/wiki/How-to-Rebase-a-Pull-Request" target="_blank" rel="external">How to Rebase a Pull Request</a></li>
</ol>
<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ol>
<li><a href="http://www.kancloud.cn/kancloud/tmux/62459" target="_blank" rel="external">tmux: Productive Mouse-Free Development</a></li>
<li><a href="https://wolfpaulus.com/mac/tomcat/" target="_blank" rel="external">Installing Tomcat on macOS 10.12 Sierra</a></li>
<li><a href="https://cloud.smartdraw.com/" target="_blank" rel="external">smartdraw</a>  推荐指数：✨✨✨✨✨</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>http://www.pisces.ml/romance/love.html</url>
      <content type="html"><![CDATA[<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Forever Love</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<div class="container">

  <div id="carousel-example-generic" class="carousel slide" data-ride="carousel">
    <ol class="carousel-indicators">
      <li data-target="#carousel-example-generic" data-slide-to="0" class="active"></li>
      <li data-target="#carousel-example-generic" data-slide-to="1" class=""></li>
      <li data-target="#carousel-example-generic" data-slide-to="2" class=""></li>
    </ol>
    <div class="carousel-inner">
      <div class="item active">
        <img alt="First slide" src="../images/love/2015-06-21 123358.jpg">
      </div>
      <div class="item">
        <img alt="Second slide" src="../images/love/2016-01-10 112447.jpg">
      </div>
      <div class="item">
        <img alt="Third slide" src="../images/love/2016-01-10 112914.jpg">
      </div>
    </div>
    <a class="left carousel-control" href="#carousel-example-generic" data-slide="prev">
      <span class="glyphicon glyphicon-chevron-left"></span>
    </a>
    <a class="right carousel-control" href="#carousel-example-generic" data-slide="next">
      <span class="glyphicon glyphicon-chevron-right"></span>
    </a>
  </div>

  <div id="CountMsg">
    <div id="countdown_prompt">
      <h1><a>爱情计时器</a></h1>
    </div>
  <div id="countdown" class="lead">
    <a>最美的时光感谢有你陪我走过，</a><br>
    <a> 如果你问我人生最开心的日子是什么日子？</a> <br>
    <a>那么我的答案是：‘<strong>有你的日子’</strong></a> <br>
    <a>一首"愿得一人心" 送给你，我最爱的那个她</a> <br>
    <div style="font-size:20px;width:100%;height:40px;color:red;">
    <p class="text-center">❤️❤️我们相守走过
      <span id="t_d">00天</span>
      <span id="t_h">00时</span>
      <span id="t_m">00分</span>
      <span id="t_s">00秒</span>
      今天是第
      <span id="t_month">00</span>个月第
      <span id="t_year">00</span>年❤️❤️
    </p> <br>
    </div>
    <div>
      <h1>纪念属于我们的521</h1>
    </div>
  </div>
  <div>
    <video width="320" height="40" controls autoplay name="media">
      <source src="http://qqma.tingge123.com:83/123/2012/9/%E4%B8%AD%E5%9B%BD%E5%A5%BD%E5%A3%B0%E9%9F%B3%20%E6%84%BF%E5%BE%97%E4%B8%80%E4%BA%BA%E5%BF%83-%E6%9D%8E%E8%A1%8C%E4%BA%AE.mp3">
    </video>
  </div>
  </div>

  <!-- <div class="page-header"> -->
  <!-- <h1><a href="photo_wall.html">照片墙</a></h1> -->
  <!-- </div> -->

</div>

<!-- JavaScript Includes -->
<script src="../js/src/private/love.js"></script>
<script src="../js/src/private/love-time.js"></script>
<script src="../js/src/bootstrap/jquery.min.js"></script>
<script src="../js/src/bootstrap/carousel.js"></script>

</body>
</html>
]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>http://www.pisces.ml/romance/photo_wall.html</url>
      <content type="html"><![CDATA[<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Forever Love</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        #screen {
          position: absolute;
          left: 20%;
          top: 11%;
          width: 60%;
          height: 80%;
          background: #3e495d;
        }
        #screen img {
          position: absolute;
          cursor: pointer;
          visibility: hidden;
          width: 0px;
          height: 0px;
        }
        #screen .tvover {
          border: solid #876;
          opacity: 1;
          filter: alpha(opacity=100);
        }
        #screen .tvout {
          border: solid #fff;
          opacity: 0.7;
        }
        #bankImages {
          display: none;
        }
    </style>
</head>
<body>

<div id="screen">
    <div id="bankImages">
      <img alt="" src="../images/love/1.jpg">
      <img alt="" src="../images/love/2.jpg">
      <img alt="" src="../images/love/3.jpg">
      <img alt="" src="../images/love/4.jpg">
      <img alt="" src="../images/love/5.jpg">
      <img alt="" src="../images/love/6.jpg">
      <img alt="" src="../images/love/7.jpg">
      <img alt="" src="../images/love/8.jpg">
      <img alt="" src="../images/love/1.jpg">
      <img alt="" src="../images/love/2.jpg">
      <img alt="" src="../images/love/3.jpg">
      <img alt="" src="../images/love/4.jpg">
      <img alt="" src="../images/love/5.jpg">
      <img alt="" src="../images/love/6.jpg">
      <img alt="" src="../images/love/7.jpg">
      <img alt="" src="../images/love/8.jpg">
    </div>
</div>

<!-- JavaScript Includes -->
<script src="../js/src/private/love.js"></script>
<script src="../js/src/private/3d-tv.js" type="text/javascript"></script>
<script type="text/javascript">
  /* ==== start script ==== */
  onresize = tv.resize;
  tv.init();
</script>

</body>
</html>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[All tags]]></title>
      <url>http://www.pisces.ml/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>

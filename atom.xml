<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pirates</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.pisces.ml/"/>
  <updated>2019-08-28T10:16:06.459Z</updated>
  <id>http://www.pisces.ml/</id>
  
  <author>
    <name>Summer Smith</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>centos源码安装vim</title>
    <link href="http://www.pisces.ml/2019/08/28/centos%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85vim/"/>
    <id>http://www.pisces.ml/2019/08/28/centos源码安装vim/</id>
    <published>2019-08-28T09:28:18.000Z</published>
    <updated>2019-08-28T10:16:06.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录vim源码安装，由于开发环境中系统自带的vim版本旧，以及现有的vim特性无法满足需求。故需要通过手动从源码编译安装vim。以下记录整个无坑安装部署过程。</p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>操作系统：CentOS Linux release 7.6.1810 (Core)</p>
<p>shell: zsh</p>
<h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><ol>
<li><p>移除系统自带vim</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum remove -y vim-filesystem-7.4.160-4.el7.x86_64 vim-common-7.4.160-4.el7.x86_64 vim-enhanced-7.4.160-4.el7.x86_64</div></pre></td></tr></table></figure>
</li>
<li><p>克隆vim源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/vim/vim.git</div></pre></td></tr></table></figure>
</li>
<li><p>安装vim依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y ruby ruby-devel lua lua-devel luajit luajit-devel ctags git python python-devel python3 python3-devel tcl-devel perl perl-devel perl-ExtUtils-ParseXS perl-ExtUtils-XSpp perl-ExtUtils-CBuilder perl-ExtUtils-Embed ncurses-devel</div></pre></td></tr></table></figure>
</li>
<li><p>进入vim项目中根据自己需求切换到相应版，并执行如下命令生成Makefile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">./configure --with-features=huge \</div><div class="line">        --enable-multibyte \</div><div class="line">        --enable-rubyinterp=yes \</div><div class="line">        --enable-python3interp=yes \</div><div class="line">        --with-python-config-dir=/usr/lib64/python2.7/config \</div><div class="line">        --enable-perlinterp=yes \</div><div class="line">        --enable-luainterp=yes \</div><div class="line">        --enable-gui=gtk2 \</div><div class="line">        --enable-cscope \</div><div class="line">        --prefix=/usr/local</div></pre></td></tr></table></figure>
</li>
<li><p>编译文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make VIMRUNTIMEDIR=/usr/local/share/vim/vim81</div></pre></td></tr></table></figure>
</li>
<li><p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make install</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;记录vim源码安装，由于开发环境中系统自带的vim版本旧，以及现有的vim特性无法满足需求。故需要通过手动从源码编译安装vim。以下记录整个
    
    </summary>
    
      <category term="Linux" scheme="http://www.pisces.ml/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://www.pisces.ml/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>系统运维记录</title>
    <link href="http://www.pisces.ml/2018/07/27/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.pisces.ml/2018/07/27/系统运维记录/</id>
    <published>2018-07-27T03:29:57.000Z</published>
    <updated>2018-08-07T07:15:07.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h1><p>1.查看硬盘信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/opt/storcli/storcli64 /c0/e8/s6 show all</div><div class="line"># or</div><div class="line">smartctl --all /dev/sdx</div></pre></td></tr></table></figure>
<h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><p>1.ssh连接慢问题：</p>
<p>重启systemd-logind.service服务</p>
<p>本文用于记录日常系统运维，持续更新中………………</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;硬盘&quot;&gt;&lt;a href=&quot;#硬盘&quot; class=&quot;headerlink&quot; title=&quot;硬盘&quot;&gt;&lt;/a&gt;硬盘&lt;/h1&gt;&lt;p&gt;1.查看硬盘信息&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
    
    </summary>
    
      <category term="linux" scheme="http://www.pisces.ml/categories/linux/"/>
    
    
      <category term="运维" scheme="http://www.pisces.ml/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>linux常用shell脚本记录（附带脚本解析）</title>
    <link href="http://www.pisces.ml/2018/05/10/linux%E5%B8%B8%E7%94%A8shell%E8%84%9A%E6%9C%AC%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.pisces.ml/2018/05/10/linux常用shell脚本记录/</id>
    <published>2018-05-10T08:09:08.000Z</published>
    <updated>2018-05-11T07:14:39.631Z</updated>
    
    <content type="html"><![CDATA[<p>由于工作中经常会用到一些shell来统计或者做一些批量操作，一些shell用的少，突然用的时候可能会忘记。本文用于记录工作中用到shell命令，以便日后备用。好记性不如烂笔头嘛！！！</p>
<h3 id="统计服务器socket连接数"><a href="#统计服务器socket连接数" class="headerlink" title="统计服务器socket连接数"></a>统计服务器socket连接数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;</div></pre></td></tr></table></figure>
<p>shell脚本解析：通过netstat列出当前socket连接信息，并通过管道将结果传递给awk命令，作为awk命令处理的参数，awk命令首先执行正则匹配，过滤出TCP socket，然后用$NF取行的最后一个值作为统计值进行sum统计，最后将得到的数组S打印出来。</p>
<p>awk内建函数参考示例： <a href="https://www.linuxnix.com/awk-scripting-learn-awk-built-in-variables-with-examples/" target="_blank" rel="external">https://www.linuxnix.com/awk-scripting-learn-awk-built-in-variables-with-examples/</a></p>
<p>题外话：<a href="https://jaminzhang.github.io/network/the-difference-between-unix-domain-socket-and-tcp-ip-socket/" target="_blank" rel="external">Unix domain socket 和 TCP/IP socket 的区别</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于工作中经常会用到一些shell来统计或者做一些批量操作，一些shell用的少，突然用的时候可能会忘记。本文用于记录工作中用到shell命令，以便日后备用。好记性不如烂笔头嘛！！！&lt;/p&gt;
&lt;h3 id=&quot;统计服务器socket连接数&quot;&gt;&lt;a href=&quot;#统计服务器so
    
    </summary>
    
      <category term="Shell" scheme="http://www.pisces.ml/categories/Shell/"/>
    
    
      <category term="shell" scheme="http://www.pisces.ml/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>python基础知识——装饰器篇</title>
    <link href="http://www.pisces.ml/2018/05/08/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E5%99%A8%E7%AF%87/"/>
    <id>http://www.pisces.ml/2018/05/08/python基础知识——装饰器篇/</id>
    <published>2018-05-08T09:49:50.000Z</published>
    <updated>2018-05-11T07:14:39.626Z</updated>
    
    <content type="html"><![CDATA[<p>​    本篇文章主要来总结下python中的几种常用的装饰器用法。我们知道在python编程中经常会用到装饰器，因为使用装饰器，我们可以简化代码，避免重复造轮子，使得代码看着更加整洁，增强代码可读性。</p>
<p>​    说到装饰器的用法，不得不提下装饰器在openstack中的应用。本人入行已有三年之久，现在专注于云计算开发运维，编程习惯以及编码风格受了openstack社区极大影响，社区大牛多之前就看了keystone的源码，你会发现刚开始看的时候一脸懵逼，静下心好好看看你会发现真的是匠心之作。基本上将装饰器应用到了极致，社区为了简化代码用了很多嵌套的装饰器（真的是层层嵌套），毕竟在设计上许多功能是需要重复使用的，所以其中也大量的用到了装饰器，并且是使用了模块化的层层嵌套，将许多功能封装成许多装饰器，又通过装饰器的组合嵌套来使用，这样一方面避免了代码冗余，另外还实现了代码的组合使用类似于模块化组件，使得代码更加简洁。</p>
<p>​    谈装饰器前还需要注意下，Python 中的函数和 Java、C++不太一样，Python 中的函数可以像普通变量一样当做参数传递给另外一个函数</p>
<h3 id="简单装饰器"><a href="#简单装饰器" class="headerlink" title="简单装饰器"></a>简单装饰器</h3><p>python中通过符号”@“引入装饰器，如下所示是一种简单装饰器写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></div><div class="line">        logging.warn(<span class="string">"%s is running"</span> % func.__name__)</div><div class="line">        <span class="keyword">return</span> func()</div><div class="line">    <span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"><span class="meta">@use_logging</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"i am foo"</span>)</div><div class="line"></div><div class="line">foo()</div></pre></td></tr></table></figure>
<p>​    如上图所示，foo方法作为参数传递给user_logging方法，在user_logging方法中执行完日志功能之后返回foo方法，这样只需要将需要打印日志的地方在函数预定义的地方添加这个装饰器就能实现日志功能。这样做避免了重复在函数中写日志搜集功能相关代码，也使得代码更加简洁明了。</p>
<h3 id="args、-kwargs"><a href="#args、-kwargs" class="headerlink" title="args、*kwargs"></a><em>args、*</em>kwargs</h3><p>​    如上述简单装饰器中，你可能会问如果foo函数需要参数需要怎么办？例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def foo(name)：</div><div class="line">    print("i am %s" % name)</div></pre></td></tr></table></figure>
<p>​    增对参数传递，我们只需将参数传递给wrapper函数，再由wrapper函数传递给foo函数即可。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(name)</span>:</span> <span class="comment"># 此处参数如果未知或者多个可用*args/**kwargs替代，一般情况下我们使用*args/**kwargs</span></div><div class="line">    logging.warn(<span class="string">"%s is running"</span> % func.__name__)</div><div class="line">    <span class="keyword">return</span> func(name)</div></pre></td></tr></table></figure>
<p>​    结合起来完整代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args)</span>:</span> <span class="comment"># 由于函数参数无法确定我们需要使用*args替代</span></div><div class="line">        logging.warn(<span class="string">"%s is running"</span> % func.__name__)</div><div class="line">        <span class="keyword">return</span> func(*args)</div><div class="line">    <span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"><span class="meta">@use_logging</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name)</span>:</span></div><div class="line">    print(<span class="string">"i am %s"</span> % name)</div><div class="line"></div><div class="line">foo(name)</div></pre></td></tr></table></figure>
<h3 id="带参数装饰器"><a href="#带参数装饰器" class="headerlink" title="带参数装饰器"></a>带参数装饰器</h3><p>装饰器在使用中还支持接收参数，如上示例中每个执行函数所需的日志级别肯定不尽相同，我们需要实现功能根据实际需求提供日志级别，这样我们就需要改写user_logging方法，使其支持参数传递，这样就能根据不容参数传入，来选择相应的日志级别。更改如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(level)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">            <span class="keyword">if</span> level == <span class="string">"warn"</span>:</div><div class="line">                logging.warn(<span class="string">"%s is running"</span> % func.__name__)</div><div class="line">            <span class="keyword">elif</span> level == <span class="string">"info"</span>:</div><div class="line">                logging.info(<span class="string">"%s is running"</span> % func.__name__)</div><div class="line">            <span class="keyword">return</span> func(*args)</div><div class="line">        <span class="keyword">return</span> wrapper</div><div class="line">    <span class="keyword">return</span> decorate</div></pre></td></tr></table></figure>
<p>那么我们该如何调用呢？其实也很简单，形同函数传参一样调用时加上相应参数即可。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@use_logging(level="warn")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name)</span>:</span></div><div class="line">    print(<span class="string">"i am %s"</span> %name)</div><div class="line">				</div><div class="line">foo(<span class="string">"hero"</span>)</div></pre></td></tr></table></figure>
<h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>python装饰器实现中不仅仅可以使函数方法，也可以是以类的方式实现。相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器主要依靠类函数的<a href="http://pycoders-weekly-chinese.readthedocs.org/en/latest/issue6/a-guide-to-pythons-magic-methods.html" target="_blank" rel="external">魔术方法</a>“_ <em>call </em> _” ,当调用时只需用语法糖@引入即可，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></div><div class="line">        self._func = func</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></div><div class="line">        logging.warn(<span class="string">"%s is running"</span> % self._func.__name)</div><div class="line"> 		self._func()</div><div class="line"> </div><div class="line"><span class="meta">@Log</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"I am foo"</span>)</div><div class="line"></div><div class="line">foo()</div></pre></td></tr></table></figure>
<h3 id="装饰器顺序"><a href="#装饰器顺序" class="headerlink" title="装饰器顺序"></a>装饰器顺序</h3><p>我们知道一个函数是可以引入多个装饰器的，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@func1</span></div><div class="line"><span class="meta">@func2</span></div><div class="line"><span class="meta">@func3</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"do something"</span>)</div></pre></td></tr></table></figure>
<p>执行顺序是从里到外的，即先执行func3再到func1。以下示例能更好的解释执行顺序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f = func1(func2(func3(foo)))</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    本篇文章主要来总结下python中的几种常用的装饰器用法。我们知道在python编程中经常会用到装饰器，因为使用装饰器，我们可以简化代码，避免重复造轮子，使得代码看着更加整洁，增强代码可读性。&lt;/p&gt;
&lt;p&gt;​    说到装饰器的用法，不得不提下装饰器在opens
    
    </summary>
    
      <category term="Python" scheme="http://www.pisces.ml/categories/Python/"/>
    
    
      <category term="装饰器" scheme="http://www.pisces.ml/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>linux 常用软件包命令集锦</title>
    <link href="http://www.pisces.ml/2018/03/24/linux-%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%91%BD%E4%BB%A4%E9%9B%86%E9%94%A6/"/>
    <id>http://www.pisces.ml/2018/03/24/linux-常用软件包命令集锦/</id>
    <published>2018-03-24T01:55:44.000Z</published>
    <updated>2018-05-11T07:14:39.622Z</updated>
    
    <content type="html"><![CDATA[<p>本篇用于记录常用linux操作系统软件包安装命令集锦</p>
<h2 id="查询rpm包的依赖关系"><a href="#查询rpm包的依赖关系" class="headerlink" title="查询rpm包的依赖关系"></a>查询rpm包的依赖关系</h2><p><strong><em>查询未安装软件包的依赖关系</em></strong></p>
<p>rpm -qRp xxxxx.rpm</p>
<p><strong>查询已安装软件包依赖</strong></p>
<p>rpm -qR xxxxx</p>
<h2 id="离线下载软件包"><a href="#离线下载软件包" class="headerlink" title="离线下载软件包"></a>离线下载软件包</h2><p>yum install -y –downloadonly –downloaddir=/xxx/xxx xxxxx</p>
<h2 id="搜索仓库所有版本软件包"><a href="#搜索仓库所有版本软件包" class="headerlink" title="搜索仓库所有版本软件包"></a>搜索仓库所有版本软件包</h2><p>yum search –showduplicates xxxxxxx</p>
<h2 id="本地安装rpm软件包"><a href="#本地安装rpm软件包" class="headerlink" title="本地安装rpm软件包"></a>本地安装rpm软件包</h2><p>rpm -ivh xxxxx.rpm or rpm -ivh –force xxxxx.rpm</p>
<h2 id="经验记录"><a href="#经验记录" class="headerlink" title="经验记录"></a>经验记录</h2><p>大部分公司都是私有环境，虽然有自己的私有仓库，但是问题是并不会实时去同步官方的仓库，经常遇到软件包不存在，需要自己离线去下载并上传安装。常用的做法就是本地先起一个相同内核版本的linux操作系统，然后离线下载软件包（包括依赖），最后上传到服务器上用rpm命令进行本地安装。本地安装可能会出现以下类似报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">rpm -ivh openssl-*                                                                                                     准备中...                          ################################# [100%]</div><div class="line">        file /usr/lib64/.libcrypto.so.10.hmac from install of openssl-libs-1:1.0.2k-8.el7.x86_64 conflicts with file from package openssl-libs-1:1.0.1e-60.el7.x86_64</div><div class="line">        file /usr/lib64/.libssl.so.10.hmac from install of openssl-libs-1:1.0.2k-8.el7.x86_64 conflicts with file from package openssl-libs-1:1.0.1e-60.el7.x86_64</div><div class="line">        file /usr/lib64/libcrypto.so.10 from install of openssl-libs-1:1.0.2k-8.el7.x86_64 conflicts with file from package openssl-libs-1:1.0.1e-60.el7.x86_64</div><div class="line">        file /usr/lib64/libssl.so.10 from install of openssl-libs-1:1.0.2k-8.el7.x86_64 conflicts with file from package openssl-libs-1:1.0.1e-60.el7.x86_64</div></pre></td></tr></table></figure>
<p>此时可以尝试强制安装命令（<strong>强制安装前需要检查软件包的依赖，查看系统有的软件包是否满足安装依赖需求</strong>）：</p>
<p>rpm -ivh –force xxxxxx.rpm</p>
<p>由于强制安装并不会将之前的版本卸载了，如下所示我们能看到两个版本的软件包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># rpm -qa | grep openssl</div><div class="line">openssl-libs-1.0.2k-8.el7.x86_64</div><div class="line">openssl-libs-1.0.1e-60.el7.x86_64</div><div class="line">openssl-1.0.2k-8.el7.x86_64</div><div class="line">openssl-1.0.1e-60.el7.x86_64</div></pre></td></tr></table></figure>
<p>执行yum check命令会有如下错误提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># yum check</div><div class="line">已加载插件：fastestmirror</div><div class="line">audit-2.7.6-3.el7.x86_64 是 audit-2.6.5-3.el7.x86_64 的副本</div><div class="line">audit-libs-2.7.6-3.el7.x86_64 是 audit-libs-2.6.5-3.el7.x86_64 的副本</div><div class="line">libsemanage-2.5-8.el7.x86_64 是 libsemanage-2.5-4.el7.x86_64 的副本</div><div class="line">1:openssl-1.0.2k-8.el7.x86_64 是 1:openssl-1.0.1e-60.el7.x86_64 的副本</div><div class="line">1:openssl-libs-1.0.2k-8.el7.x86_64 是 1:openssl-libs-1.0.1e-60.el7.x86_64 的副本</div><div class="line">policycoreutils-2.5-17.1.el7.x86_64 是 policycoreutils-2.5-8.el7.x86_64 的副本</div></pre></td></tr></table></figure>
<p>所以我们需要执行以下命令清除重复的软件包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">package-cleanup --cleandupes</div></pre></td></tr></table></figure>
<p>清除完后软件包就可以正常运行了。</p>
<p>本篇工作记录，持续更新……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇用于记录常用linux操作系统软件包安装命令集锦&lt;/p&gt;
&lt;h2 id=&quot;查询rpm包的依赖关系&quot;&gt;&lt;a href=&quot;#查询rpm包的依赖关系&quot; class=&quot;headerlink&quot; title=&quot;查询rpm包的依赖关系&quot;&gt;&lt;/a&gt;查询rpm包的依赖关系&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://www.pisces.ml/categories/Linux/"/>
    
    
      <category term="rpm" scheme="http://www.pisces.ml/tags/rpm/"/>
    
  </entry>
  
  <entry>
    <title>openstack——云硬盘的备份与恢复</title>
    <link href="http://www.pisces.ml/2017/09/22/openstack%E2%80%94%E2%80%94%E4%BA%91%E7%A1%AC%E7%9B%98%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <id>http://www.pisces.ml/2017/09/22/openstack——云硬盘的备份与恢复/</id>
    <published>2017-09-22T06:51:35.000Z</published>
    <updated>2018-05-11T07:14:39.617Z</updated>
    
    <content type="html"><![CDATA[<p>本文会讲述如何进行跨平台云硬盘的备份与恢复，cinder提供的backup功能目前支持多种后端driver备份，比如：nfs、swift、ceph、tsm等等，可见目前常见的存储后端都是支持的。cinder在很早就已经支持备份，主要有以下优势：</p>
<ol>
<li>重要数据及时备份</li>
<li>异地容灾备份（基于cinder备份功能独立的后端driver实现）</li>
<li>openstack集群升级与迁移（冷迁移）</li>
</ol>
<p>下文增对openstack集群迁移来讲解，使用cinder backup来实现数据跨集群备份与恢复。</p>
<h1 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h1><p>以下主要概括备份与恢复大概思路。</p>
<p>在openstack集群A中做如下操作：</p>
<ol>
<li>配置cinder的backup使用ceph作为后端driver</li>
<li>创建云盘备份</li>
<li>导出云盘备份的metadata</li>
</ol>
<p>在openstack集群B中做如下操作：</p>
<ol>
<li>配置cinder的backup使用ceph作为后端driver</li>
<li>导入云盘的metadata信息</li>
<li>创建新的云硬盘，大小与原云盘一致</li>
<li>将备份从ceph存储中恢复到新建的云硬盘中</li>
</ol>
<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><p>前期准备：</p>
<ul>
<li>[x] openstack集群两套（也可一套仅仅做云盘备份用）</li>
<li>[x] 一套ceph集群专门用作云盘备份</li>
</ul>
<h2 id="创建云盘备份"><a href="#创建云盘备份" class="headerlink" title="创建云盘备份"></a>创建云盘备份</h2><p>首先将ceph集群中的配置文件以及认证文件拷贝到cinder所在节点的/etc/ceph目录下并重命名（防止与原来的ceph配置重叠）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scp /etc/ceph/ceph.conf root@cinder_host_addr:/etc/ceph/ceph-backup.conf</div><div class="line">scp /etc/ceph/ceph.client.admin.keyring root@cinder_host_addr:/etc/ceph/ceph.client.cinder-backup.keyring</div></pre></td></tr></table></figure>
<p>在两套集群中cinder所在节点修改ceph-backup.conf文件，在【global】分组中添加如下配置（<strong>important</strong>）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keyring = /etc/ceph/ceph.client.cinder-backup.keyring</div></pre></td></tr></table></figure>
<p>在两套集群中配置cinder的backup后端driver，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">backup_driver=cinder.backup.drivers.ceph</div><div class="line">backup_ceph_conf=/etc/ceph/ceph-backup.conf</div><div class="line">backup_ceph_user=admin</div><div class="line">backup_ceph_chunk_size=<span class="number">134217728</span></div><div class="line">backup_ceph_pool=sata<span class="number">-00</span> <span class="comment"># 存储pool根据实际ceph中规划的pool填写</span></div></pre></td></tr></table></figure>
<p>重启cinder-backup服务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart openstack-cinder-backup</div></pre></td></tr></table></figure>
<p>在集群A中创建volume备份：</p>
<blockquote>
<p>注意备份云盘前需将云盘从云主机中解绑才行</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cinder backup-create <span class="number">0</span>c7006e8<span class="number">-4</span>c01<span class="number">-4</span>bdb-b4b2<span class="number">-6</span>be5336263d0 <span class="comment"># volume ID</span></div></pre></td></tr></table></figure>
<p>等待几秒查看备份是否成功，状态为available即表示创建成功：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[root@controller ~]<span class="comment"># cinder backup-show 46fc9fc6-d783-4dd3-8096-839e21c49c68</span></div><div class="line">+-----------------------+--------------------------------------+</div><div class="line">|        Property       |                Value                 |</div><div class="line">+-----------------------+--------------------------------------+</div><div class="line">|   availability_zone   |                 nova                 |</div><div class="line">|       container       |               sata<span class="number">-00</span>                |</div><div class="line">|       created_at      |      <span class="number">2017</span><span class="number">-09</span><span class="number">-23</span>T06:<span class="number">22</span>:<span class="number">21.000000</span>      |</div><div class="line">|      description      |                 <span class="keyword">None</span>                 |</div><div class="line">|      fail_reason      |                 <span class="keyword">None</span>                 |</div><div class="line">| has_dependent_backups |                <span class="keyword">False</span>                 |</div><div class="line">|           id          | <span class="number">46</span>fc9fc6-d783<span class="number">-4</span>dd3<span class="number">-8096</span><span class="number">-839e21</span>c49c68 |</div><div class="line">|     is_incremental    |                <span class="keyword">False</span>                 |</div><div class="line">|          name         |                 <span class="keyword">None</span>                 |</div><div class="line">|      object_count     |                  <span class="number">0</span>                   |</div><div class="line">|          size         |                  <span class="number">10</span>                  |</div><div class="line">|         status        |              available               |</div><div class="line">|       volume_id       | <span class="number">0</span>c7006e8<span class="number">-4</span>c01<span class="number">-4</span>bdb-b4b2<span class="number">-6</span>be5336263d0 |</div><div class="line">+-----------------------+--------------------------------------+</div></pre></td></tr></table></figure>
<p>查看ceph集群中是否已经有该云盘备份：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@server<span class="number">-17</span> ~]<span class="comment"># rbd -p sata-00 ls | grep 0c7006e8-4c01-4bdb-b4b2-6be5336263d0</span></div><div class="line">volume<span class="number">-0</span>c7006e8<span class="number">-4</span>c01<span class="number">-4</span>bdb-b4b2<span class="number">-6</span>be5336263d0.backup.base</div></pre></td></tr></table></figure>
<p>至此云盘备份已经完成。</p>
<h2 id="导出云盘backup的metadata"><a href="#导出云盘backup的metadata" class="headerlink" title="导出云盘backup的metadata"></a>导出云盘backup的metadata</h2><blockquote>
<p>目前openstackclient命令暂不支持backup-export命令，社区已经有提出并提交了代码来支持:<a href="https://review.openstack.org/#/c/497167/" target="_blank" rel="external">https://review.openstack.org/#/c/497167/</a></p>
</blockquote>
<p>下面我们需要将集群A中的云盘本分的metadata信息导出，执行如下命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">[root@controller ~]<span class="comment"># cinder backup-export 46fc9fc6-d783-4dd3-8096-839e21c49c68</span></div><div class="line">+----------------+------------------------------------------------------------------------------+</div><div class="line">|    Property    |                                    Value                                     |</div><div class="line">+----------------+------------------------------------------------------------------------------+</div><div class="line">| backup_service |                          cinder.backup.drivers.ceph                          |</div><div class="line">|   backup_url   | eyJzdGF0dXMiOiAiYXZhaWxhYmxlIiwgImRpc3BsYXlfbmFtZSI6IG51bGwsICJhdmFpbGFiaWxp |</div><div class="line">|                | dHlfem9uZSI6ICJub3ZhIiwgImRlbGV0ZWQiOiBmYWxzZSwgInVwZGF0ZWRfYXQiOiAiMjAxNy0w |</div><div class="line">|                | OS0yM1QwNjoyMjozOFoiLCAiaG9zdCI6ICJjaW5kZXIiLCAidm9sdW1lX2lkIjogIjBjNzAwNmU4 |</div><div class="line">|                | LTRjMDEtNGJkYi1iNGIyLTZiZTUzMzYyNjNkMCIsICJjb250YWluZXIiOiAic2F0YS0wMCIsICJz |</div><div class="line">|                | ZXJ2aWNlX21ldGFkYXRhIjogbnVsbCwgImlkIjogIjQ2ZmM5ZmM2LWQ3ODMtNGRkMy04MDk2LTgz |</div><div class="line">|                | OWUyMWM0OWM2OCIsICJzaXplIjogMTAsICJvYmplY3RfY291bnQiOiAwLCAicHJvamVjdF9pZCI6 |</div><div class="line">|                | ICI2NWZlNzg2NTY3YTM0MTgyOWFhMDU3NTFiMmI3MzYwZiIsICJkZWxldGVkX2F0IjogbnVsbCwg |</div><div class="line">|                | InVzZXJfaWQiOiAib3BlbnN0YWNrX2FkbWluIiwgInNlcnZpY2UiOiAiY2luZGVyLmJhY2t1cC5k |</div><div class="line">|                | cml2ZXJzLmNlcGgiLCAiZHJpdmVyX2luZm8iOiB7fSwgImNyZWF0ZWRfYXQiOiAiMjAxNy0wOS0y |</div><div class="line">|                | M1QwNjoyMjoyMVoiLCAiZGlzcGxheV9kZXNjcmlwdGlvbiI6IG51bGwsICJwYXJlbnRfaWQiOiBu |</div><div class="line">|                | dWxsLCAibnVtX2RlcGVuZGVudF9iYWNrdXBzIjogMCwgImZhaWxfcmVhc29uIjogbnVsbCwgInRl |</div><div class="line">|                |       bXBfc25hcHNob3RfaWQiOiBudWxsLCAidGVtcF92b2x1bWVfaWQiOiBudWxsfQ==       |</div><div class="line">|                |                                                                              |</div><div class="line">+----------------+------------------------------------------------------------------------------+</div></pre></td></tr></table></figure>
<p>其中backup_url就是我们所需要的metadata信息，这一串东西就是metadata经过base64过后的字符，我们用base64进行解码后就能得到如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;status&quot;: &quot;available&quot;, &quot;display_name&quot;: null, &quot;availability_zone&quot;: &quot;nova&quot;, &quot;deleted&quot;: false, &quot;updated_at&quot;: &quot;2017-09-23T06:22:38Z&quot;, &quot;host&quot;: &quot;cinder&quot;, &quot;volume_id&quot;: &quot;0c7006e8-4c01-4bdb-b4b2-6be5336263d0&quot;, &quot;container&quot;: &quot;sata-00&quot;, &quot;service_metadata&quot;: null, &quot;id&quot;: &quot;46fc9fc6-d783-4dd3-8096-839e21c49c68&quot;, &quot;size&quot;: 10, &quot;object_count&quot;: 0, &quot;project_id&quot;: &quot;65fe786567a341829aa05751b2b7360f&quot;, &quot;deleted_at&quot;: null, &quot;user_id&quot;: &quot;75fc9fc6-d783-4dd3-8096-839e21c49c68&quot;, &quot;service&quot;: &quot;cinder.backup.drivers.ceph&quot;, &quot;driver_info&quot;: &#123;&#125;, &quot;created_at&quot;: &quot;2017-09-23T06:22:21Z&quot;, &quot;display_description&quot;: null, &quot;parent_id&quot;: null, &quot;num_dependent_backups&quot;: 0, &quot;fail_reason&quot;: null, &quot;temp_snapshot_id&quot;: null, &quot;temp_volume_id&quot;: null&#125;</div></pre></td></tr></table></figure>
<p>可以用如下命令得到backup_url:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[root@controller ~]<span class="comment"># cinder backup-export 46fc9fc6-d783-4dd3-8096-839e21c49c68 |  sed -n '/backup_url/,$ s/|.*|  *\(.*\) |/\1/p'</span></div><div class="line">eyJzdGF0dXMiOiAiYXZhaWxhYmxlIiwgImRpc3BsYXlfbmFtZSI6IG51bGwsICJhdmFpbGFiaWxp</div><div class="line">dHlfem9uZSI6ICJub3ZhIiwgImRlbGV0ZWQiOiBmYWxzZSwgInVwZGF0ZWRfYXQiOiAiMjAxNy0w</div><div class="line">OS0yM1QwNjoyMjozOFoiLCAiaG9zdCI6ICJjaW5kZXIiLCAidm9sdW1lX2lkIjogIjBjNzAwNmU4</div><div class="line">LTRjMDEtNGJkYi1iNGIyLTZiZTUzMzYyNjNkMCIsICJjb250YWluZXIiOiAic2F0YS0wMCIsICJz</div><div class="line">ZXJ2aWNlX21ldGFkYXRhIjogbnVsbCwgImlkIjogIjQ2ZmM5ZmM2LWQ3ODMtNGRkMy04MDk2LTgz</div><div class="line">OWUyMWM0OWM2OCIsICJzaXplIjogMTAsICJvYmplY3RfY291bnQiOiAwLCAicHJvamVjdF9pZCI6</div><div class="line">ICI2NWZlNzg2NTY3YTM0MTgyOWFhMDU3NTFiMmI3MzYwZiIsICJkZWxldGVkX2F0IjogbnVsbCwg</div><div class="line">InVzZXJfaWQiOiAib3BlbnN0YWNrX2FkbWluIiwgInNlcnZpY2UiOiAiY2luZGVyLmJhY2t1cC5k</div><div class="line">cml2ZXJzLmNlcGgiLCAiZHJpdmVyX2luZm8iOiB7fSwgImNyZWF0ZWRfYXQiOiAiMjAxNy0wOS0y</div><div class="line">M1QwNjoyMjoyMVoiLCAiZGlzcGxheV9kZXNjcmlwdGlvbiI6IG51bGwsICJwYXJlbnRfaWQiOiBu</div><div class="line">dWxsLCAibnVtX2RlcGVuZGVudF9iYWNrdXBzIjogMCwgImZhaWxfcmVhc29uIjogbnVsbCwgInRl</div><div class="line">bXBfc25hcHNob3RfaWQiOiBudWxsLCAidGVtcF92b2x1bWVfaWQiOiBudWxsfQ==</div></pre></td></tr></table></figure>
<h2 id="导入云盘backup的metadata"><a href="#导入云盘backup的metadata" class="headerlink" title="导入云盘backup的metadata"></a>导入云盘backup的metadata</h2><p>根据上面步骤得到的backup_url，我将将其写到metadata.txt文件中，然后再集群B中导入该metadata信息，操作步骤如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cinder backup-import cinder.backup.drivers.ceph $(tr -d &apos;\n&apos; &lt; metadata.txt)</div><div class="line">+----------+--------------------------------------+</div><div class="line">| Property |                Value                 |</div><div class="line">+----------+--------------------------------------+</div><div class="line">|    id    | b238d4b5-e757-4d8f-5623-3d982e5616dc |</div><div class="line">|   name   |                 None                 |</div><div class="line">+----------+--------------------------------------+</div></pre></td></tr></table></figure>
<p>导入成功后我们能用cinder backup-list看到新导入的metadata信息。</p>
<h2 id="创建新的云硬盘"><a href="#创建新的云硬盘" class="headerlink" title="创建新的云硬盘"></a>创建新的云硬盘</h2><p>在集群B中创建一个新的云硬盘，磁盘大小跟原来的一样，执行如下命令创建：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">[root@controller ~]<span class="comment"># cinder create --display_name backup_recover 10</span></div><div class="line">+---------------------------------------+--------------------------------------+</div><div class="line">|                Property               |                Value                 |</div><div class="line">+---------------------------------------+--------------------------------------+</div><div class="line">|              attachments              |                  []                  |</div><div class="line">|           availability_zone           |                 nova                 |</div><div class="line">|                bootable               |                false                 |</div><div class="line">|          consistencygroup_id          |                 <span class="keyword">None</span>                 |</div><div class="line">|               created_at              |      <span class="number">2017</span><span class="number">-09</span><span class="number">-23</span>T06:<span class="number">53</span>:<span class="number">13.000000</span>      |</div><div class="line">|              description              |                 <span class="keyword">None</span>                 |</div><div class="line">|               encrypted               |                <span class="keyword">False</span>                 |</div><div class="line">|                   id                  | d0431cee<span class="number">-3</span>de2<span class="number">-458</span>f-a70d<span class="number">-95935</span>d7ffd9f |</div><div class="line">|                metadata               |                  &#123;&#125;                  |</div><div class="line">|            migration_status           |                 <span class="keyword">None</span>                 |</div><div class="line">|              multiattach              |                <span class="keyword">False</span>                 |</div><div class="line">|                  name                 |            backup_recover            |</div><div class="line">|         os-vol-host-attr:host         |         cinder@ssd-ceph<span class="comment">#ssd          |</span></div><div class="line">|     os-vol-mig-status-attr:migstat    |                 <span class="keyword">None</span>                 |</div><div class="line">|     os-vol-mig-status-attr:name_id    |                 <span class="keyword">None</span>                 |</div><div class="line">|      os-vol-tenant-attr:tenant_id     |   <span class="number">65</span>fe786567a341829aa05751b2b7360f   |</div></pre></td></tr></table></figure>
<h2 id="云盘恢复"><a href="#云盘恢复" class="headerlink" title="云盘恢复"></a>云盘恢复</h2><p>现在需要将原来的云盘的备份恢复到新建的云硬盘中，我们需要在集群B的cinder节点执行如下恢复操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@controller ~]# cinder backup-restore --volume d0431cee-3de2-458f-a70d-95935d7ffd9f b238d4b5-e757-4d8f-5623-3d982e5616dc</div><div class="line">+-------------+--------------------------------------+</div><div class="line">|   Property  |                Value                 |</div><div class="line">+-------------+--------------------------------------+</div><div class="line">|  backup_id  | b238d4b5-e757-4d8f-5623-3d982e5616dc |</div><div class="line">|  volume_id  | d0431cee-3de2-458f-a70d-95935d7ffd9f |</div><div class="line">| volume_name |            backup_recover            |</div><div class="line">+-------------+--------------------------------------+</div></pre></td></tr></table></figure>
<p>恢复成功后backup的状态会从restoring变为available，到此表示恢复完成，我们需要做的就是将恢复完成的云盘挂载到云主机中，来查看数据是否已经恢复。THE END。。。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文会讲述如何进行跨平台云硬盘的备份与恢复，cinder提供的backup功能目前支持多种后端driver备份，比如：nfs、swift、ceph、tsm等等，可见目前常见的存储后端都是支持的。cinder在很早就已经支持备份，主要有以下优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重
    
    </summary>
    
      <category term="Openstack" scheme="http://www.pisces.ml/categories/Openstack/"/>
    
    
      <category term="cinder" scheme="http://www.pisces.ml/tags/cinder/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS X 下文件名乱码问题解决</title>
    <link href="http://www.pisces.ml/2017/09/15/Mac-OS-X-%E4%B8%8B%E6%96%87%E4%BB%B6%E5%90%8D%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://www.pisces.ml/2017/09/15/Mac-OS-X-下文件名乱码问题解决/</id>
    <published>2017-09-15T07:47:16.000Z</published>
    <updated>2018-05-11T07:14:39.613Z</updated>
    
    <content type="html"><![CDATA[<p>​    在 GB2312 等编码环境下的 zip 格式压缩包在 Mac OS X 环境下解压，或者从各种奇怪编码格式的 ftp 下载文件，以及从各种生产环境竟然不是utf-8的古代论坛下载到附件之类的事情之后，文件名很可能会变成乱码。这些乱码是由于 GB2312 编码（或者其它编码）下的文字的binary形式被错误地使用 utf-8 方式解码产生的。</p>
<p>​    mac系统默认用归档实用工具打开zip格式压缩包mac，系统自带的归档实用工具只能用utf-8的方式解码，且不能配置解码格式，所以当我们用归档实用工具打开的zip压缩文件会显示错误编码格式（此处只想吐槽）</p>
<p>​    既然mac系统自带的解压工具仅支持utf-8编码格式，我们就不得不使用其他工具代替，去商店搜索解压软件，只有一款解压软件是免费的——Rar解压王，下载使用之后果然应验了那句话天下没有免费的午餐，没有用，没有用，没有用！！！重要的事情说三遍，，，没用还带广告真是无力吐槽……</p>
<p>​    难道真的没有免费的面包吃么？深深被开源思想灌溉的我不信（咋不说口袋空空呢⊙﹏⊙），这怎么可能（毕竟这么实用的功能），Google了一番，终于找到一个免费开源的解压软件（最重要还没有广告哦）：<a href="https://theunarchiver.com/" target="_blank" rel="external">unarchiver</a> 该解压软件支持多种压缩格式，类似于window中的rar解压软件一样，并且能够自动识别文件编码，并用正确编码格式进行解码。perfect！perfect！perfect！完美解决。喝杯咖啡压压惊</p>
<p>  end</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    在 GB2312 等编码环境下的 zip 格式压缩包在 Mac OS X 环境下解压，或者从各种奇怪编码格式的 ftp 下载文件，以及从各种生产环境竟然不是utf-8的古代论坛下载到附件之类的事情之后，文件名很可能会变成乱码。这些乱码是由于 GB2312 编码（或
    
    </summary>
    
      <category term="Mac" scheme="http://www.pisces.ml/categories/Mac/"/>
    
    
      <category term="code" scheme="http://www.pisces.ml/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Mac命令行终端下使用shadowsocks翻墙（转）</title>
    <link href="http://www.pisces.ml/2017/08/22/Mac%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%88%E7%AB%AF%E4%B8%8B%E4%BD%BF%E7%94%A8shadowsocks%E7%BF%BB%E5%A2%99/"/>
    <id>http://www.pisces.ml/2017/08/22/Mac命令行终端下使用shadowsocks翻墙/</id>
    <published>2017-08-22T08:19:30.000Z</published>
    <updated>2018-05-11T07:14:39.609Z</updated>
    
    <content type="html"><![CDATA[<p>原文转自：<a href="http://www.cashqian.net/blog/001486989831982332565298e4942a2bb8f56b08f9d2475000" target="_blank" rel="external">http://www.cashqian.net/blog/001486989831982332565298e4942a2bb8f56b08f9d2475000</a> 仅供学习使用</p>
<p>配置好shadowsocks服务器端后，安装对应系统的客户端，浏览器安装相应插件就可以翻墙上网了，这都很简单。</p>
<p>问题是对于经常在命令行终端下工作的码农们，SS无法正常工作。因为在终端下不支持socks5代理，只支持http代理，这就很尴尬了。wget、curl、git、brew等命令行工具都会变得很慢。</p>
<p>Linux系统就简单一些，安装proxychains-NG等软件就可以解决了，但是在Mac下有点麻烦。OS X 10.11之前的系统海好说，都还比较顺利，但是OS X 10.11之后较新的系统默认设置下不会安装成功。</p>
<p>因为苹果在新系统中加入了SIP安全机制，他会阻止第三方程序向系统目录内（/System，/bin，/sbin，/usr(除了/usr/local)）进行写操作，sudo也不行。办法是先把SIP关了，等装好软件配置好后再打开SIP。或者改用其他软件。</p>
<p>我懒得去把SIP关了开开了关了，找了另外一个软件privoxy，它刚好就是安装在/usr/local内，不需要关闭SIP也可以正常使用。</p>
<h3 id="privoxy安装"><a href="#privoxy安装" class="headerlink" title="privoxy安装"></a>privoxy安装</h3><p>安装很简单用brew安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install privoxy</div></pre></td></tr></table></figure>
<h3 id="privoxy配置"><a href="#privoxy配置" class="headerlink" title="privoxy配置"></a>privoxy配置</h3><p>打开配置文件 <code>/usr/local/etc/privoxy/config</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /usr/local/etc/privoxy/config</div></pre></td></tr></table></figure>
<p>加入下面这两项配置项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">listen-address 0.0.0.0:8118</div><div class="line">forward-socks5 / localhost:1080 .</div></pre></td></tr></table></figure>
<p>第一行设置privoxy监听任意IP地址的8118端口。第二行设置本地socks5代理客户端端口，注意不要忘了最后有一个空格和点号。</p>
<h3 id="启动privoxy"><a href="#启动privoxy" class="headerlink" title="启动privoxy"></a>启动privoxy</h3><p>因为没有安装在系统目录内，所以启动的时候需要打全路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /usr/local/sbin/privoxy /usr/local/etc/privoxy/config</div></pre></td></tr></table></figure>
<h3 id="查看是否启动成功"><a href="#查看是否启动成功" class="headerlink" title="查看是否启动成功"></a>查看是否启动成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -na | grep 8118</div></pre></td></tr></table></figure>
<p>看到有类似如下信息就表示启动成功了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcp4       0      0  *.8118                 *.*                    LISTEN</div></pre></td></tr></table></figure>
<p>如果没有，可以查看日志信息，判断哪里出了问题。打开配置文件找到 <code>logdir</code> 配置项，查看log文件。</p>
<h3 id="privoxy使用"><a href="#privoxy使用" class="headerlink" title="privoxy使用"></a>privoxy使用</h3><p>在命令行终端中输入如下命令后，该终端即可翻墙了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export http_proxy=&apos;http://localhost:8118&apos;</div><div class="line">export https_proxy=&apos;http://localhost:8118&apos;</div></pre></td></tr></table></figure>
<p>他的原理是讲socks5代理转化成http代理给命令行终端使用。</p>
<p>如果不想用了取消即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unset http_proxy</div><div class="line">unset https_proxy</div></pre></td></tr></table></figure>
<p>如果关闭终端窗口，功能就会失效，如果需要代理一直生效，则可以把上述两行代码添加到 ~/.bash_profile 文件最后。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vim ~/.bash_profile</div><div class="line">-----------------------------------------------------</div><div class="line">export http_proxy=&apos;http://localhost:8118&apos;</div><div class="line">export https_proxy=&apos;http://localhost:8118&apos;</div><div class="line">-----------------------------------------------------</div></pre></td></tr></table></figure>
<p>使配置立即生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source  ~/.bash_profile</div></pre></td></tr></table></figure>
<p>还可以在 <code>~/.bash_profile</code> 里加入开关函数，使用起来更方便</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function proxy_off()&#123;</div><div class="line">    unset http_proxy</div><div class="line">    unset https_proxy</div><div class="line">    echo -e &quot;已关闭代理&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function proxy_on() &#123;</div><div class="line">    export no_proxy=&quot;localhost,127.0.0.1,localaddress,.localdomain.com&quot;</div><div class="line">    export http_proxy=&quot;http://127.0.0.1:8118&quot;</div><div class="line">    export https_proxy=$http_proxy</div><div class="line">    echo -e &quot;已开启代理&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="更多设置"><a href="#更多设置" class="headerlink" title="更多设置"></a>更多设置</h3><p>privoxy更多设置项可以参考这篇文章：</p>
<blockquote>
<p><a href="http://blog.devtang.com/2012/12/08/use-privoxy/" target="_blank" rel="external">使用Privoxy做智能代理切换</a></p>
</blockquote>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><blockquote>
<p>1、<a href="http://ian.wang/270.htm" target="_blank" rel="external">http://ian.wang/270.htm</a></p>
<p>2、<a href="http://www.yinqisen.cn/blog-707.html" target="_blank" rel="external">http://www.yinqisen.cn/blog-707.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文转自：&lt;a href=&quot;http://www.cashqian.net/blog/001486989831982332565298e4942a2bb8f56b08f9d2475000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.
    
    </summary>
    
      <category term="Mac" scheme="http://www.pisces.ml/categories/Mac/"/>
    
    
      <category term="shadowsocks" scheme="http://www.pisces.ml/tags/shadowsocks/"/>
    
      <category term="privoxy" scheme="http://www.pisces.ml/tags/privoxy/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统奇怪的磁盘占用解决记录(转载)</title>
    <link href="http://www.pisces.ml/2017/08/02/Linux%E7%B3%BB%E7%BB%9F%E5%A5%87%E6%80%AA%E7%9A%84%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95-%E8%BD%AC%E8%BD%BD/"/>
    <id>http://www.pisces.ml/2017/08/02/Linux系统奇怪的磁盘占用解决记录-转载/</id>
    <published>2017-08-02T02:54:19.000Z</published>
    <updated>2018-05-11T07:14:39.605Z</updated>
    
    <content type="html"><![CDATA[<p>原文转自：<a href="http://davidaq.com/technique/2015/07/18/linux-weird-disk-usage.html" target="_blank" rel="external">http://davidaq.com/technique/2015/07/18/linux-weird-disk-usage.html</a></p>
<p>近日我所维护的一台服务器运行出现了异常，翻开程序运行日志，初步发现问题是某个过程无法创建新临时文件。 再仔细阅读日志，看到了Java报出的<code>Java.io.IOException; there is not enough space on the disk</code>。</p>
<p>那么问题就很明显了，磁盘占满了。但是这事本身就让我很费解，因为这个服务器上所跑的程序不会长期存储文件， 只是一个数据加工服务器，把传入的文件进行一定的处理然后再回传，期间会产生一些临时文件，但都会在处理 过程结束后自动删除掉。我第一想到的就是，会不会是这个自动删除的功能没做好，导致临时文件堆积如山， 但是经过检查，包括系统其他程序在内所产生的临时文件不到1G，根本不足以占满系统。</p>
<p>我运行<code>df</code>命令查看磁盘的占用情况，看到了4个磁盘挂载点，发现是挂载在<code>/</code>上的磁盘总共50GB被占满了。 于是我在根目录运行<code>du -h -x --max-depth=1</code>想看看是哪个目录占用的这么多空间，我好判断到底出什么问题了， 这个命令中的<code>-x</code>参数会让<code>du</code>命令不统计不在同一个磁盘分区上目录，或换句话说，忽略其他的磁盘挂载点。 结果令人崩溃，根本不用看哪个目录有问题，整个根目录总共统计，磁盘只占用了5.5GB。 那么50GB的磁盘被占满了，但是实际统计磁盘上的文件，总共却只有5.5GB大小，那么剩余的44.5GB被什么鬼用掉了？</p>
<p>我只好进行我的Google功课，然后认识到了几点非常重要的Linux特性。这个特性我以前也知道，却没有重视。 就是在Linux的文件系统中删除一个文件，系统并不会真的立刻把这个文件丢弃掉，而只是把它从文件的目录系统中移除， 只有确保所有使用这个文件的程序全部都退出后，才会真的把文件彻底删除掉。所以这些幽灵文件还会占用磁盘空间， 不过这些幽灵文件并不会出现在<code>df</code>命令的统计中去，因为它们已经不存在于任何目录当中了。</p>
<p>文件系统作为Linux最核心的部件，工具也是最齐全的。<code>lsof</code>此时就可以针对此问题进行检查了，这个命令是用来 列出整个系统中所有被打开的文件（顺便还可以查看所有已经启动的硬件设备以及打开的网络连接等）。 已经从目录系统中移除，但任然被程序占用的的文件可以用<code>lsof | grep &#39;(deleted)&#39;</code>来查看。 经此我立刻就发现了我的问题在哪里了：有一个已经被“删除”掉的日志文件，因为并没有关闭或重启程序， 该文件还在一直被使用着，还在忠实地记录着程序的运行状态。该程序已经持续运行半年了，而且日志文件一直都是 以同一个文件打开描述进行操作（日志文件只在程序开始时打开过一次，后面一直用这个打开的文件）， 这个日志文件已经涨到40多GB了。</p>
<p>找到问题后，解决就简单了，我重启了那个程序，立刻40多G的占用空间就归还给了系统，所有程序都运行正常了。 当然这只是权宜之计，解决眼前问题采取的快速措施。要根除此问题就要用更科学的方式记录日志，使用已经成熟的 日志系统是个比较正确的选择。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文转自：&lt;a href=&quot;http://davidaq.com/technique/2015/07/18/linux-weird-disk-usage.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://davidaq.com/tech
    
    </summary>
    
      <category term="Linux" scheme="http://www.pisces.ml/categories/Linux/"/>
    
    
      <category term="disk" scheme="http://www.pisces.ml/tags/disk/"/>
    
  </entry>
  
  <entry>
    <title>如何避免ssh未知节点主机认证？</title>
    <link href="http://www.pisces.ml/2017/07/27/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8Dssh%E6%9C%AA%E7%9F%A5%E8%8A%82%E7%82%B9%E4%B8%BB%E6%9C%BA%E8%AE%A4%E8%AF%81%EF%BC%9F/"/>
    <id>http://www.pisces.ml/2017/07/27/如何避免ssh未知节点主机认证？/</id>
    <published>2017-07-27T01:56:21.000Z</published>
    <updated>2018-05-11T07:14:39.602Z</updated>
    
    <content type="html"><![CDATA[<p>通常情况下，ssh连接到新的节点会显示如下确认信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The authenticity of host &apos;111.222.333.444 (111.222.333.444)&apos; can&apos;t be established.</div><div class="line">RSA key fingerprint is f3:cf:58:ae:71:0b:c8:04:6f:34:a3:b2:e4:1e:0c:8b.</div><div class="line">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure>
<p>对于单一节点确认下即可，但是如果同时处理多个节点的话就比较蛋疼了。所以我们进行ssh连接时需要跳过验证，ssh命令也考虑到了这个问题，只需带上相应的可选参数即可，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -o &quot;StrictHostKeyChecking no&quot; user@host</div></pre></td></tr></table></figure>
<p>对于scp多主机拷贝文件也只需加这个参数即可，示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp -o &quot;StrictHostKeyChecking no&quot; user@host:/home/text.txt .</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常情况下，ssh连接到新的节点会显示如下确认信息：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;li
    
    </summary>
    
      <category term="Linux" scheme="http://www.pisces.ml/categories/Linux/"/>
    
    
      <category term="ssh" scheme="http://www.pisces.ml/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>浅谈redis</title>
    <link href="http://www.pisces.ml/2017/07/25/%E6%B5%85%E8%B0%88redis/"/>
    <id>http://www.pisces.ml/2017/07/25/浅谈redis/</id>
    <published>2017-07-25T06:29:52.000Z</published>
    <updated>2018-05-11T07:14:39.598Z</updated>
    
    <content type="html"><![CDATA[<p>​    最近工作用到了redis做数据缓存，于是乎花了点时间研究了下redis。各种语言对redis都有相应的支持，我们可以在官网上看到：<a href="https://redis.io/clients，足以见的redis的广泛适用性。" target="_blank" rel="external">https://redis.io/clients，足以见的redis的广泛适用性。</a></p>
<p>​    针对python的client，看了下redis-py用的人比较多，果断用redis-py做应用开发（这可不是从众心理哦）。简单的看了下，client已经将redis接口封装了一次，仅仅提供了简单易用的接口，对于使用者无需关心底层调用，只需关心接口使用即可。</p>
<h1 id="redis-py基本使用"><a href="#redis-py基本使用" class="headerlink" title="redis-py基本使用"></a>redis-py基本使用</h1><p>接下来我们先介绍下redis-py简单的应用，主要参考<a href="https://github.com/andymccurdy/redis-py" target="_blank" rel="external">官方文档</a>资料。有兴趣可以看看源码，更有助于理解。</p>
<p>redis-py使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> redis</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = redis.StrictRedis(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.set(<span class="string">'foo'</span>, <span class="string">'bar'</span>)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.get(<span class="string">'foo'</span>)</div><div class="line"><span class="string">'bar'</span></div></pre></td></tr></table></figure>
<h2 id="redis连接池"><a href="#redis连接池" class="headerlink" title="redis连接池"></a>redis连接池</h2><p>通常情况下, 当我们需要做redis操作时, 会创建一个连接, 并基于这个连接进行redis操作，操作完成后, 释放连接，一般情况下, 这是没问题的, 但当并发量比较高的时候, 频繁的连接创建和释放对性能会有较高的影响。于是, 连接池就发挥作用了。连接池的原理是, 通过预先创建多个连接, 当进行redis操作时, 直接获取已经创建的连接进行操作, 而且操作完成后, 不会释放, 用于后续的其他redis操作这样就达到了避免频繁的redis连接创建和释放的目的, 从而提高性能。</p>
<p>redis-py建立连接池：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>pool = redis.ConnectionPool(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = redis.Redis(connection_pool=pool)</div></pre></td></tr></table></figure>
<h2 id="redis事务处理"><a href="#redis事务处理" class="headerlink" title="redis事务处理"></a>redis事务处理</h2><p>redis-py通过Pipelines实现类似数据库的事务处理功能，如下所示表示简单的redis事务操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = redis.Redis(...)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.set(<span class="string">'bing'</span>, <span class="string">'baz'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Use the pipeline() method to create a pipeline instance</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pipe = r.pipeline()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># The following SET commands are buffered</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pipe.set(<span class="string">'foo'</span>, <span class="string">'bar'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pipe.get(<span class="string">'bing'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># the EXECUTE call sends all buffered commands to the server, returning</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># a list of responses, one for each command.</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pipe.execute()</div><div class="line">[<span class="keyword">True</span>, <span class="string">'baz'</span>]</div></pre></td></tr></table></figure>
<p>事务处理特点：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>
</ul>
<p>对于redis使用，并不会很复杂，详细看看官方文档即可。</p>
<h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>目前市面上的应用程序为了提高性能一般都是多线程运行，那么redis中对于并发请求是否可能出现异常？</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://www.u3v3.com/ar/1346" target="_blank" rel="external">https://www.u3v3.com/ar/1346</a></p>
<p><a href="http://www.redis.cn/topics/transactions.html" target="_blank" rel="external">http://www.redis.cn/topics/transactions.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    最近工作用到了redis做数据缓存，于是乎花了点时间研究了下redis。各种语言对redis都有相应的支持，我们可以在官网上看到：&lt;a href=&quot;https://redis.io/clients，足以见的redis的广泛适用性。&quot; target=&quot;_blank&quot;
    
    </summary>
    
      <category term="Cache" scheme="http://www.pisces.ml/categories/Cache/"/>
    
    
      <category term="redis" scheme="http://www.pisces.ml/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>如何制作rpm安装包</title>
    <link href="http://www.pisces.ml/2017/06/17/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9Crpm%E5%AE%89%E8%A3%85%E5%8C%85/"/>
    <id>http://www.pisces.ml/2017/06/17/如何制作rpm安装包/</id>
    <published>2017-06-17T06:59:45.000Z</published>
    <updated>2018-05-11T07:14:39.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>安装部署软件包，大部分我们都是通过rpm来完成。通常情况我们根据源码包，来制作rpm安装包，再将安装包放到yum仓库里。这样安装一个软件我们就可以直接通过yum命令来安装了。</p>
<h1 id="RPM基础知识"><a href="#RPM基础知识" class="headerlink" title="RPM基础知识"></a>RPM基础知识</h1><p>若要构建一个标准的 RPM 包，您需要创建 <strong>.spec</strong> 文件，其中包含软件打包的全部信息。然后，对此文件执行 <strong>rpmbuild</strong> 命令，经过这一步，系统会按照步骤生成最终的 RPM 包。</p>
<p>一般情况，您应该把源代码包，比如由开发者发布的以 <strong>.tar.gz</strong> 结尾的文件，放入 <strong>~/rpmbuild/SOURCES</strong> 目录。将<strong>.spec</strong> 文件放入 <strong>~/rpmbuild/SPECS</strong> 目录，并命名为 “<em>软件包名</em>.spec” 。当然， <em>软件包名</em> 就是最终 RPM 包的名字。为了创建二进制（Binary RPM）和源码软件包（SRPM），您需要将目录切换至 <strong>~/rpmbuild/SPECS</strong> 并执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rpmbuild -ba NAME.spec</div></pre></td></tr></table></figure>
<p>当执行此命令时，<strong>rpmbuild</strong> 会自动读取 <strong>.spec</strong> 文件并按照下表列出的步骤完成构建。下表中，以 <strong>%</strong> 开头的语句为预定义宏，每个宏的作用如下：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>读取的目录</th>
<th>写入的目录</th>
<th>具体动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>%prep</td>
<td>%_sourcedir</td>
<td>%_builddir</td>
<td>读取位于 %_sourcedir 目录的源代码和 patch 。之后，解压源代码至 %_builddir的子目录并应用所有 patch。</td>
</tr>
<tr>
<td>%build</td>
<td>%_builddir</td>
<td>%_builddir</td>
<td>编译位于 %_builddir构建目录下的文件。通过执行类似 “./configure &amp;&amp; make” 的命令实现。</td>
</tr>
<tr>
<td>%install</td>
<td>%_builddir</td>
<td>%_buildrootdir</td>
<td>读取位于 %_builddir构建目录下的文件并将其安装至 %_buildrootdir` 目录。这些文件就是用户安装 RPM 后，最终得到的文件。注意一个奇怪的地方: <em>最终安装目录</em> <strong>不是</strong> <em>构建目录</em>。通过执行类似 “make install” 的命令实现。</td>
</tr>
<tr>
<td>%check</td>
<td>%_builddir</td>
<td>%_builddir</td>
<td>检查软件是否正常运行。通过执行类似 “<code>make test</code>“ 的命令实现。很多软件包都不需要此步。</td>
</tr>
<tr>
<td>bin</td>
<td>%_buildrootdir</td>
<td>%_rpmdir</td>
<td>读取位于 %_buildrootdir 最终安装目录下的文件，以便最终在 %_rpmdir目录下创建 RPM 包。在该目录下，不同架构的 RPM 包会分别保存至不同子目录， “noarch`” 目录保存适用于所有架构的 RPM 包。这些 RPM 文件就是用户最终安装的 RPM 包。</td>
</tr>
<tr>
<td>src</td>
<td>%_sourcedir</td>
<td>%_srcrpmdir</td>
<td>创建源码 RPM 包（简称 SRPM，以.src.rpm 作为后缀名），并保存至 %_srcrpmdir 目录。SRPM 包通常用于审核和升级软件包。</td>
</tr>
</tbody>
</table>
<p>在 <strong>rpmbuild</strong> 中，对上表中的每个宏代码都有对应的目录：</p>
<table>
<thead>
<tr>
<th>宏代码</th>
<th>名称</th>
<th>默认位置</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>%_specdir</td>
<td>Spec 文件目录</td>
<td>~/rpmbuild/SPECS</td>
<td>保存 RPM 包配置（.spec）文件</td>
</tr>
<tr>
<td>%_sourcedir</td>
<td>源代码目录</td>
<td>~/rpmbuild/SOURCES</td>
<td>保存源码包（如 .tar 包）和所有 patch 补丁</td>
</tr>
<tr>
<td>%_builddir</td>
<td>构建目录</td>
<td>~/rpmbuild/BUILD</td>
<td>源码包被解压至此，并在该目录的子目录完成编译</td>
</tr>
<tr>
<td>%_buildrootdir</td>
<td>最终安装目录</td>
<td>~/rpmbuild/BUILDROOT</td>
<td>保存 %install 阶段安装的文件</td>
</tr>
<tr>
<td>%_rpmdir</td>
<td>标准 RPM 包目录</td>
<td>~/rpmbuild/RPMS</td>
<td>生成/保存二进制 RPM 包</td>
</tr>
<tr>
<td>%_srcrpmdir</td>
<td>源代码 RPM 包目录</td>
<td>~/rpmbuild/SRPMS</td>
<td>生成/保存源码 RPM 包(SRPM)</td>
</tr>
</tbody>
</table>
<p>如果某一阶段失败，请查看输出信息以了解失败<em>原因</em>，并根据需要修改 .<strong>spec</strong> 文件。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>制作环境：Centos 7.1</p>
<p>制作工具:  rpmdevtools</p>
<p>首先安装依赖包:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install rpmdevtools</div></pre></td></tr></table></figure>
<h2 id="创建目录结构"><a href="#创建目录结构" class="headerlink" title="创建目录结构"></a>创建目录结构</h2><p>执行 <code>rpmdev-setuptree</code> 将在当前用户主目录下创建一个RPM构建根目录结构，结构如下所示：</p>
<p>（注：如需改变默认位置，可以修改配置文件:<strong>~/.rpmmacros</strong>中变量<strong>_topdir</strong>对应的值。)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">rpmbuild/</div><div class="line">├── BUILD (源码包被解压至此，并在该目录的子目录完成编译)</div><div class="line">├── RPMS (生成/保存二进制 RPM 包)</div><div class="line">├── SOURCES (保存源码包（如 .tar 包）和所有 patch 补丁)</div><div class="line">├── SPECS (保存 RPM 包配置（.spec）文件)</div><div class="line">└── SRPMS (生成/保存源码 RPM 包(SRPM))</div></pre></td></tr></table></figure>
<h2 id="撰写spec文档"><a href="#撰写spec文档" class="headerlink" title="撰写spec文档"></a>撰写spec文档</h2><p>现在，需要在 <strong>~/rpmbuild/SPECS</strong> 目录下，新建一个 SPEC 文件。文件应命名为 “<strong>软件包名.spec</strong>“。名称根据软件包名或通用名填写即可。但是，必须要遵守 <a href="https://fedoraproject.org/wiki/Packaging/NamingGuidelines" target="_blank" rel="external">软件包命名规定</a>。示例，我们在SPECS目录下新建文件<strong>xxxxx.spec</strong>，我们能看到会自动生成如下内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">#软件包的名字</div><div class="line">Name:</div><div class="line">#软件包的主版本号 </div><div class="line">Version:</div><div class="line">#软件包的次版本号，一般我们对该软件包做了一些小的补丁的时候就应该把释出号加1。</div><div class="line">Release:	1%&#123;?dist&#125;</div><div class="line">#软件包简要介绍</div><div class="line">Summary:</div><div class="line"></div><div class="line">#软件分类</div><div class="line">Group:</div><div class="line">#授权协议</div><div class="line">License:</div><div class="line">#源码软件源地址</div><div class="line">URL:</div><div class="line">#源代码包，默认将在上面提到的SOURCES目录中寻找</div><div class="line">Source0:</div><div class="line"></div><div class="line">#构建项目需要的依赖包</div><div class="line">BuildRequires:</div><div class="line">#软件运行依赖包</div><div class="line">Requires:</div><div class="line"></div><div class="line">#软件包的内容介绍 </div><div class="line">%description</div><div class="line"></div><div class="line"></div><div class="line">#这个段是预处理段，通常用来执行一些解开源程序包的命令，为下一步的编译安装作准备。%prep和下面的%build，%install段一样，除了可以执行RPM所定义的宏命令（以%开头）以外，还可以执行SHELL命令，命令可以有很多行，如我们常写的tar解包命令。</div><div class="line">%prep</div><div class="line">#构建BUILD环境，将解压源码压缩包到BUILD目录</div><div class="line">%setup -q</div><div class="line"></div><div class="line"></div><div class="line">#BUILD字段，将通过直接调用源码目录中自动构建工具完成源码编译操作</div><div class="line">%build</div><div class="line">#调用源码目录中的configure命令  </div><div class="line">%configure</div><div class="line">make %&#123;?_smp_mflags&#125;</div><div class="line"></div><div class="line"></div><div class="line">#本段是安装段，其中的命令在安装软件包时将执行，如make install命令。</div><div class="line">%install</div><div class="line">#调用源码中安装执行脚本 </div><div class="line">make install DESTDIR=%&#123;buildroot&#125;</div><div class="line"></div><div class="line"></div><div class="line">#文件说明字段，声明多余或者缺少都将可能出错</div><div class="line">%files</div><div class="line">%doc</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">%changelog</div></pre></td></tr></table></figure>
<h3 id="如何查看spec文件中宏路径（很重要哦）"><a href="#如何查看spec文件中宏路径（很重要哦）" class="headerlink" title="如何查看spec文件中宏路径（很重要哦）"></a>如何查看spec文件中宏路径（很重要哦）</h3><p>我们可以通过命令<code>rpm --showrc</code>查看实现代码。另外直接通过<code>rpm --eval &quot;%{macro}&quot;</code>来查看具体对应路径。比如我们要查看%{_bindir}的路径，就可以使用命令<code>rpm --eval &quot;%{ _bindir}&quot;</code>来查看。另外，所有的宏都可以在/usr/lib/rpm/macros里找到。示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rpm --eval <span class="string">"%&#123;_bindir&#125;"</span></div><div class="line">/usr/bin</div></pre></td></tr></table></figure>
<h2 id="源码打包"><a href="#源码打包" class="headerlink" title="源码打包"></a>源码打包</h2><p>如果是python项目，我们可以通过命令<code>python setup.py sdist</code>进行打包，执行命令完成后会在源码包的dist目录下生成一个<strong>tar.gz</strong>的源码包，我们需要将源码包拷贝到<strong>~/rpmbuild/SOURCES</strong>。不是python项目的话根据相应的打包规则进行打包即可。（注，确保此归档文件解压后的目录为<strong>xxxx-0.0.1</strong>，否则会有问题）</p>
<h2 id="构建RPM包"><a href="#构建RPM包" class="headerlink" title="构建RPM包"></a>构建RPM包</h2><p>构建RPM包很容易，只需要在工作目录（rpmbuild）下执行如下命令构建即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpmbuild -ba SPECS/xxx.spec</div></pre></td></tr></table></figure>
<p>其中<strong>-ba</strong>表示<strong>build all</strong>，即生成包括二进制包和源代码包的所有RPM包，下来如果正常的话，rpmbuild将正常退出，同时在RPMS目录和SRPMS目录中将生成对应的RPM包。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>打包过程其实不麻烦，构建好环境后执行打包命令即可。最重要的是spec文件的编写，spec文件定义了包的安装配置也就是所说的宏的定义。我们需要对打包机制很熟悉才能根据实际需求写出符合要求的spec文件。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://fedoraproject.org/wiki/How_to_create_an_RPM_package/zh-cn#.E5.87.86.E5.A4.87.E7.B3.BB.E7.BB.9F" target="_blank" rel="external">https://fedoraproject.org/wiki/How_to_create_an_RPM_package/zh-cn#.E5.87.86.E5.A4.87.E7.B3.BB.E7.BB.9F</a></p>
<p><a href="https://segmentfault.com/a/1190000002539129" target="_blank" rel="external">https://segmentfault.com/a/1190000002539129</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;安装部署软件包，大部分我们都是通过rpm来完成。通常情况我们根据源码包，来制作rpm安装包，再将安装包放到yum仓库里。这样安装一个软件我们
    
    </summary>
    
      <category term="Linux" scheme="http://www.pisces.ml/categories/Linux/"/>
    
    
      <category term="rpmbuild" scheme="http://www.pisces.ml/tags/rpmbuild/"/>
    
  </entry>
  
  <entry>
    <title>python 时间戳处理</title>
    <link href="http://www.pisces.ml/2017/06/13/python-%E6%97%B6%E9%97%B4%E6%88%B3%E5%A4%84%E7%90%86/"/>
    <id>http://www.pisces.ml/2017/06/13/python-时间戳处理/</id>
    <published>2017-06-13T03:38:34.000Z</published>
    <updated>2018-05-11T07:14:39.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-时间戳处理"><a href="#python-时间戳处理" class="headerlink" title="python 时间戳处理"></a>python 时间戳处理</h1><p><a href="http://funhacks.net/2015/04/29/Unix-timestamp/" target="_blank" rel="external">Unix 时间戳</a>根据精度的不同，有 10 位（秒级），13 位（毫秒级），16 位（微妙级）和 19 位（纳秒级）。在 python 中，我们可以将一个整数的时间戳转换为字符串格式，如 <code>&#39;2016-02-25 20:21:04&#39;</code>，也可以将其转换为 python 中的 <a href="https://docs.python.org/2/library/datetime.html" target="_blank" rel="external">datetime</a> 格式。反之，也可以将整数的时间戳转换为字符串格式和 datetime 格式。用图展示如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">             +------------+</div><div class="line">             | timestamp  |</div><div class="line">       +----&gt;|            |&lt;-----+</div><div class="line">       |     +------------+      |</div><div class="line">       |                         |</div><div class="line">       |                         |</div><div class="line">       |                         |</div><div class="line">       v                         v</div><div class="line">+------------+            +------------+</div><div class="line">|  datetime  |            |   string   |</div><div class="line">|            |&lt;----------&gt;|            |</div><div class="line">+------------+            +------------+</div></pre></td></tr></table></figure>
<p>要注意的是，由于每个时区都有自己的本地时间（北京在东八区），因此也产生了世界标准时间（UTC, Universal Time Coordinated）。所以，在将一个时间戳转换为普通时间（比如 2016-01-01 12:00:00）时，要注意是要本地时区的时间还是世界时间等。</p>
<h1 id="local-time-北京时间"><a href="#local-time-北京时间" class="headerlink" title="local time (北京时间)"></a>local time (北京时间)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">timestamp_to_strtime</span><span class="params">(timestamp)</span>:</span></div><div class="line">    <span class="string">"""将 13 位整数的毫秒时间戳转化成本地普通时间 (字符串格式)</span></div><div class="line">    :param timestamp: 13 位整数的毫秒时间戳 (1456402864242)</div><div class="line">    :return: 返回字符串格式 &#123;str&#125;'2016-02-25 20:21:04.242000'</div><div class="line">    """</div><div class="line">    local_str_time = datetime.fromtimestamp(timestamp / <span class="number">1000.0</span>).strftime(<span class="string">'%Y-%m-%d %H:%M:%S.%f'</span>)</div><div class="line">    <span class="keyword">return</span> local_str_time</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">timestamp_to_datetime</span><span class="params">(timestamp)</span>:</span></div><div class="line">    <span class="string">"""将 13 位整数的毫秒时间戳转化成本地普通时间 (datetime 格式)</span></div><div class="line">    :param timestamp: 13 位整数的毫秒时间戳 (1456402864242)</div><div class="line">    :return: 返回 datetime 格式 &#123;datetime&#125;2016-02-25 20:21:04.242000</div><div class="line">    """</div><div class="line">    local_dt_time = datetime.fromtimestamp(timestamp / <span class="number">1000.0</span>)</div><div class="line">    <span class="keyword">return</span> local_dt_time</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">datetime_to_strtime</span><span class="params">(datetime_obj)</span>:</span></div><div class="line">    <span class="string">"""将 datetime 格式的时间 (含毫秒) 转为字符串格式</span></div><div class="line">    :param datetime_obj: &#123;datetime&#125;2016-02-25 20:21:04.242000</div><div class="line">    :return: &#123;str&#125;'2016-02-25 20:21:04.242'</div><div class="line">    """</div><div class="line">    local_str_time = datetime_obj.strftime(<span class="string">"%Y-%m-%d %H:%M:%S.%f"</span>)</div><div class="line">    <span class="keyword">return</span> local_str_time</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">datetime_to_timestamp</span><span class="params">(datetime_obj)</span>:</span></div><div class="line">    <span class="string">"""将本地(local) datetime 格式的时间 (含毫秒) 转为毫秒时间戳</span></div><div class="line">    :param datetime_obj: &#123;datetime&#125;2016-02-25 20:21:04.242000</div><div class="line">    :return: 13 位的毫秒时间戳  1456402864242</div><div class="line">    """</div><div class="line">    local_timestamp = long(time.mktime(datetime_obj.timetuple()) * <span class="number">1000.0</span> + datetime_obj.microsecond / <span class="number">1000.0</span>)</div><div class="line">    <span class="keyword">return</span> local_timestamp</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">strtime_to_datetime</span><span class="params">(timestr)</span>:</span></div><div class="line">    <span class="string">"""将字符串格式的时间 (含毫秒) 转为 datetiem 格式</span></div><div class="line">    :param timestr: &#123;str&#125;'2016-02-25 20:21:04.242'</div><div class="line">    :return: &#123;datetime&#125;2016-02-25 20:21:04.242000</div><div class="line">    """</div><div class="line">    local_datetime = datetime.strptime(timestr, <span class="string">"%Y-%m-%d %H:%M:%S.%f"</span>)</div><div class="line">    <span class="keyword">return</span> local_datetime</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">strtime_to_timestamp</span><span class="params">(local_timestr)</span>:</span></div><div class="line">    <span class="string">"""将本地时间 (字符串格式，含毫秒) 转为 13 位整数的毫秒时间戳</span></div><div class="line">    :param local_timestr: &#123;str&#125;'2016-02-25 20:21:04.242'</div><div class="line">    :return: 1456402864242</div><div class="line">    """</div><div class="line">    local_datetime = strtime_to_datetime(local_timestr)</div><div class="line">    timestamp = datetime_to_timestamp(local_datetime)</div><div class="line">    <span class="keyword">return</span> timestamp</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">current_datetime</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">"""返回本地当前时间, 包含datetime 格式, 字符串格式, 时间戳格式</span></div><div class="line">    :return: (datetime 格式, 字符串格式, 时间戳格式)</div><div class="line">    """</div><div class="line">    <span class="comment"># 当前时间：datetime 格式</span></div><div class="line">    local_datetime_now = datetime.now()</div><div class="line">    <span class="comment"># 当前时间：字符串格式</span></div><div class="line">    local_strtime_now = datetime_to_strtime(local_datetime_now)</div><div class="line">    <span class="comment"># 当前时间：时间戳格式 13位整数</span></div><div class="line">    local_timestamp_now = datetime_to_timestamp(local_datetime_now)</div><div class="line">    <span class="keyword">return</span> local_datetime_now, local_strtime_now, local_timestamp_now</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    time_str = <span class="string">'2016-02-25 20:21:04.242'</span></div><div class="line">    timestamp1 = strtime_to_timestamp(time_str)</div><div class="line">    datetime1 = strtime_to_datetime(time_str)</div><div class="line">    time_str2 = datetime_to_strtime(datetime1)</div><div class="line">    timestamp2 = datetime_to_timestamp(datetime1)</div><div class="line">    datetime3 = timestamp_to_datetime(timestamp2)</div><div class="line">    time_str3 = timestamp_to_strtime(timestamp2)</div><div class="line">    current_time = current_datetime()</div><div class="line">    <span class="keyword">print</span> <span class="string">'timestamp1: '</span>, timestamp1</div><div class="line">    <span class="keyword">print</span> <span class="string">'datetime1: '</span>, datetime1</div><div class="line">    <span class="keyword">print</span> <span class="string">'time_str2: '</span>, time_str2</div><div class="line">    <span class="keyword">print</span> <span class="string">'timestamp2: '</span>, timestamp2</div><div class="line">    <span class="keyword">print</span> <span class="string">'datetime3: '</span>, datetime3</div><div class="line">    <span class="keyword">print</span> <span class="string">'time_str3: '</span>, time_str3</div><div class="line">    <span class="keyword">print</span> <span class="string">'current_time: '</span>, current_time</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 输出</span></div><div class="line">timestamp1:  <span class="number">1456402864242</span></div><div class="line">datetime1:  <span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">04.242000</span></div><div class="line">time_str2:  <span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">04.242000</span></div><div class="line">timestamp2:  <span class="number">1456402864242</span></div><div class="line">datetime3:  <span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">04.242000</span></div><div class="line">time_str3:  <span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">04.242000</span></div><div class="line">current_time:  (datetime.datetime(<span class="number">2016</span>, <span class="number">3</span>, <span class="number">19</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">901903</span>), <span class="string">'2016-03-19 14:11:04.901903'</span>, <span class="number">1458367864901L</span>)</div></pre></td></tr></table></figure>
<h1 id="utc-time"><a href="#utc-time" class="headerlink" title="utc time"></a>utc time</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> calendar</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">timestamp_to_utc_strtime</span><span class="params">(timestamp)</span>:</span></div><div class="line">    <span class="string">"""将 13 位整数的毫秒时间戳转化成 utc 时间 (字符串格式，含毫秒)</span></div><div class="line">    :param timestamp: 13 位整数的毫秒时间戳 (1456402864242)</div><div class="line">    :return: 返回字符串格式 &#123;str&#125;'2016-02-25 12:21:04.242000'</div><div class="line">    """</div><div class="line">    utc_str_time = datetime.utcfromtimestamp(timestamp / <span class="number">1000.0</span>).strftime(<span class="string">'%Y-%m-%d %H:%M:%S.%f'</span>)</div><div class="line">    <span class="keyword">return</span> utc_str_time</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">timestamp_to_utc_datetime</span><span class="params">(timestamp)</span>:</span></div><div class="line">    <span class="string">"""将 13 位整数的毫秒时间戳转化成 utc 时间 (datetime 格式)</span></div><div class="line">    :param timestamp: 13 位整数的时间戳 (1456402864242)</div><div class="line">    :return: 返回 datetime 格式 &#123;datetime&#125;2016-02-25 12:21:04.242000</div><div class="line">    """</div><div class="line">    utc_dt_time = datetime.utcfromtimestamp(timestamp / <span class="number">1000.0</span>)</div><div class="line">    <span class="keyword">return</span> utc_dt_time</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">utc_datetime_to_timestamp</span><span class="params">(utc_datetime)</span>:</span></div><div class="line">    <span class="string">"""将 utc 时间 (datetime 格式) 转为 utc 时间戳</span></div><div class="line">    :param utc_datetime: &#123;datetime&#125;2016-02-25 20:21:04.242000</div><div class="line">    :return: 13位 的毫秒时间戳 1456431664242</div><div class="line">    """</div><div class="line">    utc_timestamp = long(calendar.timegm(utc_datetime.timetuple()) * <span class="number">1000.0</span> + utc_datetime.microsecond / <span class="number">1000.0</span>)</div><div class="line">    <span class="keyword">return</span> utc_timestamp</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">datetime_to_strtime</span><span class="params">(datetime_obj)</span>:</span></div><div class="line">    <span class="string">"""将 datetime 格式的时间 (含毫秒) 转为字符串格式</span></div><div class="line">    :param datetime_obj: &#123;datetime&#125;2016-02-25 20:21:04.242000</div><div class="line">    :return: &#123;str&#125;'2016-02-25 20:21:04.242'</div><div class="line">    """</div><div class="line">    local_str_time = datetime_obj.strftime(<span class="string">"%Y-%m-%d %H:%M:%S.%f"</span>)</div><div class="line">    <span class="keyword">return</span> local_str_time</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">strtime_to_datetime</span><span class="params">(timestr)</span>:</span></div><div class="line">    <span class="string">"""将字符串格式的时间 (含毫秒) 转为 datetiem 格式</span></div><div class="line">    :param timestr: &#123;str&#125;'2016-02-25 20:21:04.242'</div><div class="line">    :return: &#123;datetime&#125;2016-02-25 20:21:04.242000</div><div class="line">    """</div><div class="line">    local_datetime = datetime.strptime(timestr, <span class="string">"%Y-%m-%d %H:%M:%S.%f"</span>)</div><div class="line">    <span class="keyword">return</span> local_datetime</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">utc_strtime_to_timestamp</span><span class="params">(utc_timestr)</span>:</span></div><div class="line">    <span class="string">"""将 utc 时间 (字符串格式) 转为 13 位的时间戳</span></div><div class="line">    :param utc_timestr: &#123;str&#125;'2016-02-25 20:21:04.242'</div><div class="line">    :return: 1456431664242</div><div class="line">    """</div><div class="line">    <span class="comment"># 先将字符串的格式转为 datetime 格式</span></div><div class="line">    utc_datetime = strtime_to_datetime(utc_timestr)</div><div class="line">    <span class="comment"># 再将 datetime 格式的时间转为时间戳</span></div><div class="line">    timestamp = utc_datetime_to_timestamp(utc_datetime)</div><div class="line">    <span class="keyword">return</span> timestamp</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">utc_current_datetime</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">"""返回 utc 当前时间, datetime 格式, 字符串格式, 时间戳格式</span></div><div class="line">    :return: (datetime 格式, 字符串格式, 时间戳格式)</div><div class="line">    """</div><div class="line">    <span class="comment"># utc 当前时间: datetime 格式</span></div><div class="line">    utc_datetime_now = datetime.utcnow()</div><div class="line">    <span class="comment"># utc 当前时间: 字符串格式</span></div><div class="line">    utc_strtime_now = datetime_to_strtime(utc_datetime_now)</div><div class="line">    <span class="comment"># utc 当前时间: 时间戳格式 13位整数</span></div><div class="line">    utc_timestamp_now = utc_datetime_to_timestamp(utc_datetime_now)</div><div class="line">    <span class="keyword">return</span> utc_datetime_now, utc_strtime_now, utc_timestamp_now</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    time_str = <span class="string">'2016-02-25 20:21:04.242'</span></div><div class="line">    <span class="comment"># 1456431664242</span></div><div class="line">    timestamp1 = utc_strtime_to_timestamp(time_str)</div><div class="line">    datetime1 = strtime_to_datetime(time_str)</div><div class="line">    time_str2 = datetime_to_strtime(datetime1)</div><div class="line">    timestamp2 = utc_datetime_to_timestamp(datetime1)</div><div class="line">    datetime3 = timestamp_to_utc_datetime(timestamp2)</div><div class="line">    time_str3 = timestamp_to_utc_strtime(timestamp2)</div><div class="line">    utc_current_time = utc_current_datetime()</div><div class="line">    <span class="keyword">print</span> <span class="string">'timestamp1: '</span>, timestamp1</div><div class="line">    <span class="keyword">print</span> <span class="string">'datetime1: '</span>, datetime1</div><div class="line">    <span class="keyword">print</span> <span class="string">'time_str2: '</span>, time_str2</div><div class="line">    <span class="keyword">print</span> <span class="string">'timestamp2: '</span>, timestamp2</div><div class="line">    <span class="keyword">print</span> <span class="string">'datetime3: '</span>, datetime3</div><div class="line">    <span class="keyword">print</span> <span class="string">'time_str3: '</span>, time_str3</div><div class="line">    <span class="keyword">print</span> <span class="string">'utc_current_time: '</span>, utc_current_time</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 输出</span></div><div class="line">timestamp1:  <span class="number">1456431664242</span></div><div class="line">datetime1:  <span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">04.242000</span></div><div class="line">time_str2:  <span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">04.242000</span></div><div class="line">timestamp2:  <span class="number">1456431664242</span></div><div class="line">datetime3:  <span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">04.242000</span></div><div class="line">time_str3:  <span class="number">2016</span><span class="number">-02</span><span class="number">-25</span> <span class="number">20</span>:<span class="number">21</span>:<span class="number">04.242000</span></div><div class="line">utc_current_time:  (datetime.datetime(<span class="number">2016</span>, <span class="number">3</span>, <span class="number">19</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">217055</span>), <span class="string">'2016-03-19 07:07:02.217055'</span>, <span class="number">1458371222217L</span>)</div></pre></td></tr></table></figure>
<p>本文来自<a href="http://funhacks.net/2016/03/19/python%20%E6%97%B6%E9%97%B4%E6%88%B3%E5%A4%84%E7%90%86/" target="_blank" rel="external">网络</a>，仅供学习使用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-时间戳处理&quot;&gt;&lt;a href=&quot;#python-时间戳处理&quot; class=&quot;headerlink&quot; title=&quot;python 时间戳处理&quot;&gt;&lt;/a&gt;python 时间戳处理&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://funhacks.net/2
    
    </summary>
    
      <category term="Python" scheme="http://www.pisces.ml/categories/Python/"/>
    
    
      <category term="timestamp" scheme="http://www.pisces.ml/tags/timestamp/"/>
    
  </entry>
  
  <entry>
    <title>VMware Fusion 设置端口转发</title>
    <link href="http://www.pisces.ml/2017/04/13/VMware-Fusion-%E8%AE%BE%E7%BD%AE%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    <id>http://www.pisces.ml/2017/04/13/VMware-Fusion-设置端口转发/</id>
    <published>2017-04-13T08:06:00.000Z</published>
    <updated>2018-05-11T07:14:39.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>VMware Fusion没有提供图形化的虚拟网络编辑器，当我们选用nat网络类型，我们需要端口转发的功能，那么我们需要如何设置呢？下面我们就介绍下如何在mac系统中设置虚拟机端口转发。</p>
<h1 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h1><p>虽然VMware Fusion没有提供图形化界面来支持端口转发的功能，但是我们可以通过修改网络配置文件来达到该目的。原理很简单我们只需要修改相应的网络配置文件，然后重启网络服务即可。下面我们将介绍具体的操作步骤：</p>
<ol>
<li><p><strong>修改配置文件</strong></p>
<p>VMware Fusion 的 NAT 配置文件位于 <em>/Library/Preferences/VMware Fusion/vmnet8/nat.conf</em> ，打开配置文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vi /Library/Preferences/VMware\ Fusion/vmnet8/nat.conf</div></pre></td></tr></table></figure>
<p>修改<em>[incomingtcp]</em> 部分，添加相应的端口转发即可。如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[incomingtcp]</div><div class="line"></div><div class="line"># Use these with care - anyone can enter into your VM through these...</div><div class="line"># The format and example are as follows:</div><div class="line">#&lt;external port number&gt; = &lt;VM's IP address&gt;:&lt;VM's port number&gt;</div><div class="line">#8080 = 172.16.3.128:80</div><div class="line">8080 = 192.168.125.130:22 (根据需求添加即可)</div><div class="line">8081 = 192.168.125.129:22</div></pre></td></tr></table></figure>
</li>
<li><p><strong>重启虚拟网络服务</strong></p>
<p>两种方式重启虚拟网络：</p>
<ul>
<li><p>重启VMware Fusion</p>
</li>
<li><p>执行以下命令直接重启网络模块</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo /Applications/VMware\ Fusion.app/Contents/Library/vmnet-cli --stop</div><div class="line">sudo /Applications/VMware\ Fusion.app/Contents/Library/vmnet-cli --start</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;VMware Fusion没有提供图形化的虚拟网络编辑器，当我们选用nat网络类型，我们需要端口转发的功能，那么我们需要如何设置呢？下面我们
    
    </summary>
    
      <category term="Mac" scheme="http://www.pisces.ml/categories/Mac/"/>
    
    
      <category term="VMware Fusion" scheme="http://www.pisces.ml/tags/VMware-Fusion/"/>
    
      <category term="NAT" scheme="http://www.pisces.ml/tags/NAT/"/>
    
  </entry>
  
  <entry>
    <title>Centos7网卡命名规则及修改</title>
    <link href="http://www.pisces.ml/2017/03/26/Centos-7%E9%87%8D%E5%91%BD%E5%90%8D%E7%BD%91%E5%8D%A1/"/>
    <id>http://www.pisces.ml/2017/03/26/Centos-7重命名网卡/</id>
    <published>2017-03-26T09:10:58.000Z</published>
    <updated>2018-05-11T07:14:39.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网卡命名规则"><a href="#网卡命名规则" class="headerlink" title="网卡命名规则"></a>网卡命名规则</h1><p>传统的网络设备命名是eth[0123…]<br>Centos7提供了不同的命名规则，默认是基于固件、拓扑、位置信息来分配。这样做的优点是命名是全自动的、可预知的，缺点是比eth0、wlan0更难读。比如enoxxxxxx </p>
<h2 id="命名规则策略"><a href="#命名规则策略" class="headerlink" title="命名规则策略"></a>命名规则策略</h2><p>默认的，systemd将根据下面的策略来命名接口，应用到支持的命名规则。</p>
<p>规则1：对于板载设备命名合并固件或BIOS提供的索引号，如果来自固件或BIOS的信息可读就命名，比如 eno1，这种命名是比较常见的，否则使用规则2。<br>规则2：命名合并固件或BIOS提供的PCI-E热插拔口索引号，比如ens1，如果信息可读就使用，否则使用规则3。<br>规则3：命名合并硬件接口的物理位置，比如 enp2s0，可用就命名，失败直接到方案5。<br>规则4：命名合并接口的MAC地址，比如 enx78e7d1ea46da， 默认不使用，除非用户选择使用此方案。<br>规则5：使用传统的方案，如果所有的方案都失败，eth0。</p>
<h1 id="修改网卡名称"><a href="#修改网卡名称" class="headerlink" title="修改网卡名称"></a>修改网卡名称</h1><p>centos7中默认使用了网卡的命名规则，对于我们的使用习惯，我们还是习惯将其改为ethx的命名方式。<br>我们可以看到系统网卡信息如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# ip a</div><div class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</div><div class="line"></div><div class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</div><div class="line">    inet 127.0.0.1/8 scope host lo</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">    inet6 ::1/128 scope host</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">2: eno16777736: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</div><div class="line">    link/ether 00:0c:29:73:e5:56 brd ff:ff:ff:ff:ff:ff</div><div class="line">    inet 192.168.43.209/24 brd 192.168.43.255 scope global dynamic eno16777736</div><div class="line">       valid_lft 3388sec preferred_lft 3388sec</div><div class="line">    inet6 fe80::20c:29ff:fe73:e556/64 scope link</div><div class="line">       valid_lft forever preferred_lft forever</div></pre></td></tr></table></figure>
<p>现在我们需要将名为eno16777736的网卡改成eth0，具体步骤如下所示：</p>
<ol>
<li><p>修改网卡配置文件/etc/sysconfig/network-scripts/ifcfg-eno16777736，将网卡配置文件NAME改为eth0,并将该文件重命名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">BOOTPROTO=&quot;dhcp&quot;</div><div class="line">DEFROUTE=&quot;yes&quot;</div><div class="line">PEERDNS=&quot;yes&quot;</div><div class="line">PEERROUTES=&quot;yes&quot;</div><div class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</div><div class="line">IPV6INIT=&quot;yes&quot;</div><div class="line">IPV6_AUTOCONF=&quot;yes&quot;</div><div class="line">IPV6_DEFROUTE=&quot;yes&quot;</div><div class="line">IPV6_PEERDNS=&quot;yes&quot;</div><div class="line">IPV6_PEERROUTES=&quot;yes&quot;</div><div class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</div><div class="line">NAME=&quot;eno16777736&quot; ----&gt; NAME=&quot;eth0&quot;</div><div class="line">UUID=&quot;5a87f740-b827-465b-abf8-7b864d7258c5&quot;</div><div class="line">DEVICE=&quot;eno16777736&quot; -----&gt; DEVICE=&quot;eth0&quot;</div><div class="line">ONBOOT=&quot;yes&quot;</div></pre></td></tr></table></figure>
<p>重命名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost network-scripts]# mv ifcfg-eno16777736 ifcfg-eth0</div></pre></td></tr></table></figure>
</li>
<li><p>禁用该可预测命名规则，过编辑/etc/default/grub并加入“net.ifnames=0 biosdevname=0 ”到GRUBCMDLINELINUX变量来实现，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GRUB_TIMEOUT=5</div><div class="line">GRUB_DISTRIBUTOR=&quot;$(sed &apos;s, release .*$,,g&apos; /etc/system-release)&quot;</div><div class="line">GRUB_DEFAULT=saved</div><div class="line">GRUB_DISABLE_SUBMENU=true</div><div class="line">GRUB_TERMINAL_OUTPUT=&quot;console&quot;</div><div class="line">GRUB_CMDLINE_LINUX=&quot;crashkernel=auto rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet net.ifnames=0 biosdevname=0&quot;</div><div class="line">GRUB_DISABLE_RECOVERY=&quot;true&quot;</div></pre></td></tr></table></figure>
<p>如果需要修改多块网卡则需添加多个例如：“net.ifnames=0 biosdevname=0 net.ifnames=1 biosdevname=1 net.ifnames=2 biosdevname=2”</p>
</li>
<li><p>运行命令grub2-mkconfig -o /boot/grub2/grub.cfg 来重新生成GRUB配置并更新内核参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@localhost network-scripts]# grub2-mkconfig -o /boot/grub2/grub.cfg</div><div class="line">Generating grub configuration file ...</div><div class="line">Found linux image: /boot/vmlinuz-3.10.0-514.10.2.el7.x86_64</div><div class="line">Found initrd image: /boot/initramfs-3.10.0-514.10.2.el7.x86_64.img</div><div class="line">Found linux image: /boot/vmlinuz-3.10.0-327.el7.x86_64</div><div class="line">Found initrd image: /boot/initramfs-3.10.0-327.el7.x86_64.img</div><div class="line">Found linux image: /boot/vmlinuz-0-rescue-cb085392bd6345d69ab5a0e0fe3aa74f</div><div class="line">Found initrd image: /boot/initramfs-0-rescue-cb085392bd6345d69ab5a0e0fe3aa74f.img</div><div class="line">done</div></pre></td></tr></table></figure>
</li>
<li><p>如果以上步骤重启后没有效果，再修改系统net命名规则/etc/udev/rules.d/90-eno-fix.rules，修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;00:0c:29:73:e5:56&quot;, NAME=&quot;eth0&quot; ——&gt;将name修改为eth0</div></pre></td></tr></table></figure>
</li>
</ol>
<p>最后别忘记重启系统，到此修改结束😄。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;网卡命名规则&quot;&gt;&lt;a href=&quot;#网卡命名规则&quot; class=&quot;headerlink&quot; title=&quot;网卡命名规则&quot;&gt;&lt;/a&gt;网卡命名规则&lt;/h1&gt;&lt;p&gt;传统的网络设备命名是eth[0123…]&lt;br&gt;Centos7提供了不同的命名规则，默认是基于固件、拓扑、位
    
    </summary>
    
      <category term="Network" scheme="http://www.pisces.ml/categories/Network/"/>
    
    
      <category term="运维" scheme="http://www.pisces.ml/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>关闭SELinux</title>
    <link href="http://www.pisces.ml/2017/03/24/SELinux/"/>
    <id>http://www.pisces.ml/2017/03/24/SELinux/</id>
    <published>2017-03-24T03:53:03.000Z</published>
    <updated>2018-05-11T07:14:39.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>  selinux（Security-Enhanced Linux）是一个在内核中实践的强制访问控制（MAC）安全性机制，目的在于明确的指明某个进程可以访问哪些类型的资源。开启selinux后，内核在执行系统调用前会询问 SELinux 是否获得了执行操作的授权</p>
<h2 id="永久方法-–-需要重启服务器"><a href="#永久方法-–-需要重启服务器" class="headerlink" title="永久方法 – 需要重启服务器"></a>永久方法 – 需要重启服务器</h2><p>修改/etc/selinux/config文件中设置SELINUX=disabled ，然后重启服务器。</p>
<h2 id="临时方法-–-设置系统参数"><a href="#临时方法-–-设置系统参数" class="headerlink" title="临时方法 – 设置系统参数"></a>临时方法 – 设置系统参数</h2><p>使用命令setenforce 0</p>
<p><strong>附：</strong><br>setenforce 1 设置SELinux 成为enforcing模式<br>setenforce 0 设置SELinux 成为permissive模式</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;  selinux（Security-Enhanced Linux）是一个在内核中实践的强制访问控制（MAC）安全性机制，目的在于明确的指明
    
    </summary>
    
      <category term="Linux" scheme="http://www.pisces.ml/categories/Linux/"/>
    
    
      <category term="selinux" scheme="http://www.pisces.ml/tags/selinux/"/>
    
  </entry>
  
  <entry>
    <title>linux network namespace学习笔记</title>
    <link href="http://www.pisces.ml/2017/03/15/linux-network-namespace%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.pisces.ml/2017/03/15/linux-network-namespace学习笔记/</id>
    <published>2017-03-15T15:21:24.000Z</published>
    <updated>2018-05-11T07:14:39.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在专业的网络世界中，经常使用到Virtual Routing and Forwarding（VRF），比如Cisco，Alcatel-Lucent, Juniper 等。对于L2 switch，自从上世纪90年代就开始使用VLAN，一个物理交换机上可以使用多个广播域，如今大多数交换机都支持4K vlan。</p>
<p>这个概念被引入到L3，如今很多网络设备支持VRF。这意味着，单个物理设备上可运行多个虚拟路由（L3 转发实例）。</p>
<p>在linux中，VRF被叫做“network namespace”，当然了linux中还包括其他namespace，不过本文不讨论。</p>
<p>每个network namespace拥有其对应的路由表（routing table）&amp; 其对应的iptables，并且运行程序运行其中。 为什么有人使用它？比如一个运行在linux上的 Firewall，将firewall的所有服务端口分配给一个network namespace，这样，默认的network namespace 和 Firewall network namespace就运行着不同的路由表。像SSH这样的application运行在默认的network namespace，但是不在Firewall network namespace。</p>
<p>下面展示了其基本用法。</p>
<h2 id="Basic-network-namespace-commands"><a href="#Basic-network-namespace-commands" class="headerlink" title="Basic network namespace commands"></a>Basic network namespace commands</h2><p>基本命令为“ip”，有些用户使用它来代替废弃的 ifconfig，route，netstat… 必须为root用户来使用它，这样才能更改network stack的配置。下面是ip命令和其他命令的映射：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ifconfig                                            --&gt; ip addr or just ip a</div><div class="line">ifconfig &lt;interface&gt; up/down                        --&gt; ip link set dev &lt;interface&gt; up/down</div><div class="line">ifconfig &lt;interface&gt; &lt;ip&gt; netmask &lt;netmask&gt;         --&gt; ip addr add &lt;ip&gt;/&lt;masklen&gt; dev &lt;interface&gt;</div><div class="line">netstat -rn                                         --&gt; ip route or just ip r</div><div class="line">route add -net &lt;net&gt; netmask &lt;netmask&gt; gw &lt;gateway&gt; --&gt; ip r add &lt;net&gt;/&lt;netmasklen&gt; via &lt;gateway&gt;</div></pre></td></tr></table></figure>
<h2 id="Check-your-Linux-for-namespace-support"><a href="#Check-your-Linux-for-namespace-support" class="headerlink" title="Check your Linux for namespace support"></a>Check your Linux for namespace support</h2><p>使用前，先检查系统是否支持。</p>
<h3 id="Creating-a-network-namespace"><a href="#Creating-a-network-namespace" class="headerlink" title="Creating a network namespace"></a>Creating a network namespace</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># add a new namespace</div><div class="line">ip netnas add &lt;network namespace name&gt;</div><div class="line">#Example:</div><div class="line">ip netns add nstest</div></pre></td></tr></table></figure>
<h3 id="Listing-all-existing-network-namespaces-in-the-system"><a href="#Listing-all-existing-network-namespaces-in-the-system" class="headerlink" title="Listing all existing network namespaces in the system"></a>Listing all existing network namespaces in the system</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># list all namespaces</div><div class="line">ip netns list</div><div class="line">#will show the namespace from above</div><div class="line"></div><div class="line">nstest</div></pre></td></tr></table></figure>
<h3 id="Deleting-a-network-namespace"><a href="#Deleting-a-network-namespace" class="headerlink" title="Deleting a network namespace"></a>Deleting a network namespace</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip netns delete &lt;network namespace name&gt;</div></pre></td></tr></table></figure>
<h3 id="Executing-a-command-in-a-network-namespace"><a href="#Executing-a-command-in-a-network-namespace" class="headerlink" title="Executing a command in a network namespace"></a>Executing a command in a network namespace</h3><p>下面展示了使程序运行在network namespace中的“黑魔法”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># execute a command in a namespace</div><div class="line">ip netns exec &lt;network namespace name&gt; &lt;command&gt;</div><div class="line">#Example using the namespace from above:</div><div class="line">ip netns exec nstest ip addr</div></pre></td></tr></table></figure>
<p>展示了在此network namespace中的所有的ip interface</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT</div><div class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</div></pre></td></tr></table></figure>
<p>一个脏技巧是在network namespace中运行shell：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip netns exec &lt;network namespace name&gt; bash</div></pre></td></tr></table></figure>
<p>现在，你已经“trapped”入namespace中了，exit退出。</p>
<h3 id="Exploring-the-network-namespace"><a href="#Exploring-the-network-namespace" class="headerlink" title="Exploring the network namespace"></a>Exploring the network namespace</h3><p>当我们已经创建了network namespace，第一个task是bring up其中的lo interface。应该注意到的是，在创建了network namespace后，lo interface的状态是down。如果忽略了这个，可能会发生一些奇怪的事。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># set the link of lo in the namespace to up</div><div class="line">ip netns exec nstest ip link set dev lo up</div><div class="line"># list all interfaces and the state in the namespace</div><div class="line">ip netns exec nstest ip link</div></pre></td></tr></table></figure>
<p>现在lo interface状态为up，现在，是时候将network namespace链接到外部空间。</p>
<h3 id="Adding-interfaces-to-a-network-namespace"><a href="#Adding-interfaces-to-a-network-namespace" class="headerlink" title="Adding interfaces to a network namespace"></a>Adding interfaces to a network namespace</h3><p>将一个物理interface分配给network namespace是不可能的，而是使用 virtual interface来实现。所以，我们先创建一个virtual interface，同样使用 ip command：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip link add veth-a type veth peer name veth-b</div></pre></td></tr></table></figure>
<p>上述命令创建了两个virtual interface，分别为veth-a &amp; veth-b,他们之间通过一个virtual cable链接。ip link命令显示了在默认namespace下这两个interface的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ip link</div><div class="line">veth-b: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</div><div class="line"> link/ether 72:01:ad:c5:67:84 brd ff:ff:ff:ff:ff:ff</div><div class="line">veth-a: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</div><div class="line"> link/ether 8e:8b:bd:b1:88:e5 brd ff:ff:ff:ff:ff:ff</div></pre></td></tr></table></figure>
<p>下面我们将其中的一个interface添加入之前我们创建的namespace nstest：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip link set veth-b netns nstest</div></pre></td></tr></table></figure>
<p>现在veth-b不在默认的namespace下了，而出现在了nstest 中，使用如下命令验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># list all interfaces in the namespace nstest</div><div class="line">ip netns exec nstest ip link</div><div class="line"></div><div class="line">lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT</div><div class="line"> link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</div><div class="line">veth-b: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</div><div class="line"> link/ether 72:01:ad:c5:67:84 brd ff:ff:ff:ff:ff:ff</div></pre></td></tr></table></figure>
<p>现在，在network namespace nstest中，就拥有了两个interface。</p>
<h3 id="Assign-ip-addresses-to-the-veth-interfaces"><a href="#Assign-ip-addresses-to-the-veth-interfaces" class="headerlink" title="Assign ip addresses to the veth interfaces"></a>Assign ip addresses to the veth interfaces</h3><p>现在是时候为这个veth interface分配ip并且使他的状态为up。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># default namespace</div><div class="line">ip addr add 10.0.0.1/24 dev veth-a</div><div class="line">ip link set dev veth-a up</div><div class="line">#</div><div class="line"># namespace nstest</div><div class="line">ip netns exec nstest ip addr add 10.0.0.2/24 dev veth-b</div><div class="line">ip netns exec nstest ip link set dev veth-b up</div></pre></td></tr></table></figure>
<p>可通过“ip link”查看interface状态是否为up，使用“ip addr”查看interface的ip 地址，使用“ip route”查看其路由。</p>
<p>现在可以在default namespace中，通过veth-a来ping通 位于 nstest中的veth-b。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ping 10.0.0.2</div><div class="line">PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.</div><div class="line">64 bytes from 10.0.0.2: icmp_req=1 ttl=64 time=0.054 ms</div><div class="line">64 bytes from 10.0.0.2: icmp_req=2 ttl=64 time=0.034 ms</div><div class="line">64 bytes from 10.0.0.2: icmp_req=3 ttl=64 time=0.039 ms</div><div class="line">64 bytes from 10.0.0.2: icmp_req=4 ttl=64 time=0.036 ms</div></pre></td></tr></table></figure>
<p>以及在nstest network namespace中，通过veth-b来ping通 veth-a：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ip netns exec nstest ping 10.0.0.1</div><div class="line">PING 10.0.0.1 (10.0.0.1) 56(84) bytes of data.</div><div class="line">64 bytes from 10.0.0.1: icmp_req=1 ttl=64 time=0.064 ms</div><div class="line">64 bytes from 10.0.0.1: icmp_req=2 ttl=64 time=0.036 ms</div><div class="line">64 bytes from 10.0.0.1: icmp_req=3 ttl=64 time=0.039 ms</div></pre></td></tr></table></figure>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>下面一起来实现一个demo，最终实现如下的case：<br><img src="https://sfault-image.b0.upaiyun.com/236/693/2366931023-565947f5ddd8d_articlex" alt="img"></p>
<p>首先，先建立对应的namespace：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ sudo ip netns add server</div><div class="line">$ sudo ip netns add gateway</div><div class="line">$ sudo ip netns add client</div><div class="line">$ ip netns list</div><div class="line">client</div><div class="line">gateway</div><div class="line">server</div></pre></td></tr></table></figure>
<p>然后，启用gateway namespace中的ip forward功能，注意，操作全是在root权限下执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ip netns exec gateway sysctl net.ipv4.ip_forward=1</div><div class="line">net.ipv4.ip_forward = 1</div></pre></td></tr></table></figure>
<p>下面我们来创建两对veth，用来连接不同的namespace：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ ip link add svr-veth type veth peer name svrgw-veth</div><div class="line">$ ip link add cli-veth type veth peer name cligw-veth</div><div class="line">$ ip link show | grep veth</div><div class="line">3: svrgw-veth:  mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</div><div class="line">4: svr-veth:  mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</div><div class="line">5: cligw-veth:  mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</div><div class="line">6: cli-veth:  mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</div></pre></td></tr></table></figure>
<p>将veth对的两端加入对应的namespace中，这样在默认的default namespace中就看不到他们了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ ip link set svr-veth netns server</div><div class="line">$ ip link set svrgw-veth netns gateway</div><div class="line">$ ip link set cligw-veth netns gateway</div><div class="line">$ ip link set cli-veth netns client</div><div class="line">$ ip link show | grep veth</div></pre></td></tr></table></figure>
<p>在指定的namespace上可以看到对应的interface：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ip netns exec server ip link show | grep veth</div><div class="line">4: svr-veth:  mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</div></pre></td></tr></table></figure>
<p>为各个veth分配ip：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ip netns exec server ifconfig svr-veth 192.168.100.1</div><div class="line">$ ip netns exec gateway ifconfig svrgw-veth 192.168.100.254</div><div class="line">$ ip netns exec gateway ifconfig cligw-veth 10.0.100.254</div><div class="line">$ ip netns exec client ifconfig cli-veth 10.0.100.1</div></pre></td></tr></table></figure>
<p>在各个veth对中，通过ping来检查连通性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$ ip netns exec gateway ping 192.168.100.1 -I 192.168.100.254</div><div class="line">PING 192.168.100.1 (192.168.100.1) from 192.168.100.254 : 56(84) bytes of data.</div><div class="line">64 bytes from 192.168.100.1: icmp_req=1 ttl=64 time=0.044 ms</div><div class="line">64 bytes from 192.168.100.1: icmp_req=2 ttl=64 time=0.036 ms</div><div class="line">64 bytes from 192.168.100.1: icmp_req=3 ttl=64 time=0.040 ms</div><div class="line">^C</div><div class="line">--- 192.168.100.1 ping statistics ---</div><div class="line">3 packets transmitted, 3 received, 0% packet loss, time 1999ms</div><div class="line">rtt min/avg/max/mdev = 0.036/0.040/0.044/0.003 ms</div><div class="line"></div><div class="line">$ ip netns exec gateway ping 10.0.100.1 -I 10.0.100.254</div><div class="line">PING 10.0.100.1 (10.0.100.1) from 10.0.100.254 : 56(84) bytes of data.</div><div class="line">64 bytes from 10.0.100.1: icmp_req=1 ttl=64 time=0.107 ms</div><div class="line">64 bytes from 10.0.100.1: icmp_req=2 ttl=64 time=0.037 ms</div><div class="line">64 bytes from 10.0.100.1: icmp_req=3 ttl=64 time=0.037 ms</div><div class="line">^C</div><div class="line">--- 10.0.100.1 ping statistics ---</div><div class="line">3 packets transmitted, 3 received, 0% packet loss, time 1998ms</div><div class="line">rtt min/avg/max/mdev = 0.037/0.060/0.107/0.033 ms</div></pre></td></tr></table></figure>
<p>接下来设定路由，将各namespace中的默认路由指向对应的veth ip：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ sudo ip netns exec client route add default gw 10.0.100.254</div><div class="line">$ sudo ip netns exec client netstat -rn</div><div class="line">Kernel IP routing table</div><div class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</div><div class="line">0.0.0.0         10.0.100.254    0.0.0.0         UG        0 0          0 cli-veth</div><div class="line">10.0.0.0        0.0.0.0         255.0.0.0       U         0 0          0 cli-veth</div><div class="line">$ ip netns exec server route add default gw 192.168.100.254</div><div class="line">$ ip netns exec server netstat -rn</div><div class="line">Kernel IP routing table</div><div class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</div><div class="line">0.0.0.0         192.168.100.254 0.0.0.0         UG        0 0          0 svr-veth</div><div class="line">192.168.100.0   0.0.0.0         255.255.255.0   U         0 0          0 svr-veth</div></pre></td></tr></table></figure>
<p>最后我们尝试从client namespace 到 server namespace的网络连通性，通过ping命令来测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ ip netns exec client ping 192.168.100.1 -I 10.0.100.1</div><div class="line">PING 192.168.100.1 (192.168.100.1) from 10.0.100.1 : 56(84) bytes of data.</div><div class="line">64 bytes from 192.168.100.1: icmp_req=1 ttl=63 time=0.106 ms</div><div class="line">64 bytes from 192.168.100.1: icmp_req=2 ttl=63 time=0.076 ms</div><div class="line">64 bytes from 192.168.100.1: icmp_req=3 ttl=63 time=0.050 ms</div><div class="line">^C</div><div class="line">--- 192.168.100.1 ping statistics ---</div><div class="line">3 packets transmitted, 3 received, 0% packet loss, time 1999ms</div><div class="line">rtt min/avg/max/mdev = 0.050/0.077/0.106/0.024 ms</div></pre></td></tr></table></figure>
<p>原文转发自：<a href="https://segmentfault.com/a/1190000004059167" target="_blank" rel="external">https://segmentfault.com/a/1190000004059167</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;在专业的网络世界中，经常使用到Virtual Routing and Forwarding（VRF），比如Cisco，Alcatel-Luc
    
    </summary>
    
      <category term="Network" scheme="http://www.pisces.ml/categories/Network/"/>
    
    
      <category term="namespace" scheme="http://www.pisces.ml/tags/namespace/"/>
    
      <category term="VRF" scheme="http://www.pisces.ml/tags/VRF/"/>
    
  </entry>
  
  <entry>
    <title>Cleaning ‘Failed actions’ message in Pacemaker/Corosync cluster setup</title>
    <link href="http://www.pisces.ml/2017/02/27/Cleaning-%E2%80%98Failed-actions%E2%80%99-message-in-Pacemaker-Corosync-cluster-setup/"/>
    <id>http://www.pisces.ml/2017/02/27/Cleaning-‘Failed-actions’-message-in-Pacemaker-Corosync-cluster-setup/</id>
    <published>2017-02-27T10:10:18.000Z</published>
    <updated>2018-05-11T07:14:39.570Z</updated>
    
    <content type="html"><![CDATA[<p>Sometimes when using <a href="http://www.clusterlabs.org/" target="_blank" rel="external">Pacemaker</a>/<a href="http://www.corosync.org/doku.php?id=welcome" target="_blank" rel="external">Corosync</a>-based cluster you can see warning message in <strong>crm_mon</strong> output:</p>
<blockquote>
<p>Failed actions:<br>drbd_mysql:0_promote_0 (node=node2.cluster.org, call=11, rc=-2, status=Timed Out): unknown exec error</p>
</blockquote>
<p>﻿</p>
<p>To clean it up you can use command <strong>crm_resource</strong> which checks health of resources:</p>
<blockquote>
<p>[root@node1 ~]# crm_resource -P<br>Waiting for 1 replies from the CRMd. OK<br>[root@node1 ~]#</p>
</blockquote>
<p>To check cluster’s status run <strong>crm_mon </strong>again, warning message should be gone.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sometimes when using &lt;a href=&quot;http://www.clusterlabs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pacemaker&lt;/a&gt;/&lt;a href=&quot;http://www.corosync.org/
    
    </summary>
    
      <category term="Soft" scheme="http://www.pisces.ml/categories/Soft/"/>
    
    
      <category term="Pacemaker" scheme="http://www.pisces.ml/tags/Pacemaker/"/>
    
  </entry>
  
  <entry>
    <title>linux磁盘分区以及格式化</title>
    <link href="http://www.pisces.ml/2017/02/24/linux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E4%BB%A5%E5%8F%8A%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <id>http://www.pisces.ml/2017/02/24/linux磁盘分区以及格式化/</id>
    <published>2017-02-24T02:01:16.000Z</published>
    <updated>2019-03-21T10:00:11.030Z</updated>
    
    <content type="html"><![CDATA[<p>此文将介绍裸盘的分区以及格式化，我们知道一块裸盘需要挂载到云主机中是需要进行分区以及格式化之后，才能mount到虚拟机中。本来将介绍如何操作。</p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>（注意：以下操作都是在云平台中进行）</p>
<ol>
<li><p>首先准备一台虚拟机</p>
</li>
<li><p>申请一块10G云硬盘</p>
</li>
<li><p>将云硬盘挂载到虚拟机中</p>
</li>
</ol>
<p>以上步骤准备完成后我们需要进入虚拟机，我们可以看到虚拟机中已经挂载了这么一块盘进来,如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@test-fedora ~]# lsblk</div><div class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1  422K  0 rom</div><div class="line">vda    252:0    0   20G  0 disk</div><div class="line">└─vda1 252:1    0   20G  0 part /</div><div class="line">vdb    252:16   0   10G  0 disk</div></pre></td></tr></table></figure>
<p>由上图所示，我们可以看到有一块盘（vdb）已经挂在到虚拟机中。但是还没有进行分区和格式化，我们需要进行分区后再格式化才能正常使用。</p>
<h1 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h1><p>linux中我们使用fdisk命令来进行磁盘分区，下面我们就使用该命令进行磁盘分区。</p>
<p>首先我们可以使用帮助命令或者man来查看fdisk命令的帮助文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">[root@test-fedora ~]# fdisk -h</div><div class="line"></div><div class="line">用法：</div><div class="line"> fdisk [options] &lt;disk&gt;      change partition table</div><div class="line"> fdisk [options] -l [&lt;disk&gt;] list partition table(s)</div><div class="line"></div><div class="line">选项：</div><div class="line"> -b &lt;size&gt;         扇区大小(512, 1024, 2048 或 4096)</div><div class="line"> -c[=&lt;模式&gt;]       兼容模式：“dos”或“nondos”(默认)</div><div class="line"> -h                显示此帮助并退出</div><div class="line"> -c[=&lt;模式&gt;]       兼容模式：“dos”或“nondos”(默认)</div><div class="line"> -L[=&lt;何时&gt;]       彩色显示输出(auto自动，always总是或never从不)</div><div class="line"> -t &lt;类型&gt;         强制 disk 只重新识别特定的分区表类型</div><div class="line"> -u[=&lt;单位&gt;]       显示单位：“cylinders”柱面 或“sectors”扇区(默认)</div><div class="line"> -v                打印程序版本</div><div class="line"> -C &lt;数字&gt;         指定柱面数</div><div class="line"> -H &lt;数字&gt;         指定磁头数</div><div class="line"> -S &lt;数字&gt;         指定每条磁道的扇区数</div><div class="line"></div><div class="line">更多信息请参阅 fdisk(8)。</div></pre></td></tr></table></figure>
<p>下面我们对盘vdb进行分区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">[root@test-fedora ~]# fdisk /dev/vdb</div><div class="line"></div><div class="line">欢迎使用 fdisk (util-linux 2.24.2)。</div><div class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</div><div class="line">使用写入命令前请三思。</div><div class="line"></div><div class="line">设备不包含可识别的分区表。</div><div class="line"></div><div class="line">Created a new DOS disklabel with disk identifier 0xf8fe1a5e.</div><div class="line"></div><div class="line">命令(输入 m 获取帮助)：n        输入n,创建分区</div><div class="line"></div><div class="line">分区类型：</div><div class="line">   p   主分区(0 个主分区，0 个扩展分区，4 空闲)</div><div class="line">   e   扩展分区</div><div class="line">请选择(默认为 p)：: p          输入p或者e选择分区类型：主分区／扩展分区</div><div class="line">分区号 (1-4, default 1): 1    输入分区号</div><div class="line">第一个扇区 (2048-20971519, default 2048):     输入柱头启始号</div><div class="line">上个扇区，+sectors 或 +size&#123;K,M,G,T,P&#125; (2048-20971519, default 20971519):   输入柱头结束号</div><div class="line"></div><div class="line">创建了一个新分区 1，类型为“Linux”，大小为 10 GiB。</div><div class="line"></div><div class="line">命令(输入 m 获取帮助)：w      输入w保存配置</div><div class="line">分区表已调整。</div><div class="line">将调用 ioctl() 来重新读分区表。</div><div class="line">正在同步磁盘。</div></pre></td></tr></table></figure>
<p>通常分区可以根据个人需要将此盘分为多个分区，我们这里只分了一个示例分区，上面操作完成后，我们已经建立了分区表，我们可以通过lsblk命令查看分区，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@test-fedora ~]# lsblk</div><div class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1  422K  0 rom</div><div class="line">vda    252:0    0   20G  0 disk</div><div class="line">└─vda1 252:1    0   20G  0 part /</div><div class="line">vdb    252:16   0   10G  0 disk</div><div class="line">└─vdb1 252:17   0   10G  0 part    新建的分区</div></pre></td></tr></table></figure>
<p>我们可以看到vdb这块盘已经有了一个分区vdb1，但是我们还没有挂载到云主机中，下面我们就要用mkfs命令来对磁盘进行格式化</p>
<h1 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h1><p>同样我们首先查看帮助文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[root@test-fedora ~]# mkfs -h</div><div class="line">用法：</div><div class="line"> mkfs [选项] [-t &lt;类型&gt;] [文件系统选项] &lt;设备&gt; [&lt;大小&gt;]</div><div class="line"></div><div class="line">选项：</div><div class="line"> -t, --type=&lt;类型&gt;  文件系统类型；若不指定，将使用 ext2</div><div class="line">     fs-options     实际文件系统构建程序的参数</div><div class="line">     &lt;设备&gt;         要使用设备的路径</div><div class="line">     &lt;大小&gt;         要使用设备上的块数</div><div class="line"> -V, --verbose      解释正在进行的操作；</div><div class="line">                      多次指定 -V 将导致空运行(dry-run)</div><div class="line"> -V, --version      显示版本信息并退出</div><div class="line">                      将 -V 作为 --version 选项时必须是惟一选项</div><div class="line"> -h, --help         显示此帮助并退出</div><div class="line"></div><div class="line">更多信息请参阅 mkfs(8)。</div></pre></td></tr></table></figure>
<p>分区创建好之后，还必须要经过格式化才能使用，格式化分区的主要目的是在分区中创建文件系统。Linux专用的文件系统是ext，包含ext2、ext3、ext4等诸多版本，在RHEL6中默认使用的是ext4。另外Linux也支持Windows中的FAT32文件系统，在Linux中表示为vfat。示例，我们将这块磁盘格式化为ext2格式，操作如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[root@test-fedora ~]# mkfs -t ext2 /dev/vdb1</div><div class="line">mke2fs 1.42.12 (29-Aug-2014)</div><div class="line">Found a dos partition table in /dev/vdb1</div><div class="line">无论如何也要继续? (y,n) y</div><div class="line">Creating filesystem with 2621440 4k blocks and 655360 inodes</div><div class="line">Filesystem UUID: 893aedd2-f056-4b4f-9c86-9cef7f612ccf</div><div class="line">Superblock backups stored on blocks:</div><div class="line">	32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632</div><div class="line"></div><div class="line">Allocating group tables: 完成</div><div class="line">正在写入inode表: 完成</div><div class="line">Writing superblocks and filesystem accounting information: 完成</div></pre></td></tr></table></figure>
<h1 id="挂载磁盘"><a href="#挂载磁盘" class="headerlink" title="挂载磁盘"></a>挂载磁盘</h1><p>磁盘格式化完后我们需要将该磁盘挂载到一个目录中，这样我们就能往磁盘中写入数据了，首先我们建立一个文件夹，然后将该磁盘挂载到该目录下，具体操作如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@test-fedora ~]# mkdir /var/test</div><div class="line">[root@test-fedora ~]# mount /dev/vdb1 /var/test/</div><div class="line">mount: /dev/vdb1 写保护，将以只读方式挂载</div><div class="line">mount: 文件系统类型错误、选项错误、/dev/vdb1 上有坏超级块、</div><div class="line">       缺少代码页或助手程序，或其他错误</div><div class="line"></div><div class="line">       有些情况下在 syslog 中可以找到一些有用信息- 请尝试</div><div class="line">       dmesg | tail  这样的命令看看。</div></pre></td></tr></table></figure>
<p>挂载磁盘后通常我们需要手动设置开机自动挂载，否则下次系统启动是就需要手动进行挂载，这样很不方便。所以我们需要执行以下命令设置<strong>硬盘开机自动挂载</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@test-fedora ~]<span class="comment"># tail -1 /etc/mtab &gt;&gt; /etc/fstab</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此文将介绍裸盘的分区以及格式化，我们知道一块裸盘需要挂载到云主机中是需要进行分区以及格式化之后，才能mount到虚拟机中。本来将介绍如何操作。&lt;/p&gt;
&lt;h1 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;
    
    </summary>
    
      <category term="Linux" scheme="http://www.pisces.ml/categories/Linux/"/>
    
    
      <category term="disk" scheme="http://www.pisces.ml/tags/disk/"/>
    
  </entry>
  
  <entry>
    <title>mysql分区表(转)</title>
    <link href="http://www.pisces.ml/2017/01/13/mysql%E5%88%86%E5%8C%BA%E8%A1%A8/"/>
    <id>http://www.pisces.ml/2017/01/13/mysql分区表/</id>
    <published>2017-01-13T07:10:04.000Z</published>
    <updated>2018-05-11T07:14:39.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是表分区？"><a href="#什么是表分区？" class="headerlink" title="什么是表分区？"></a>什么是表分区？</h1><p>表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</p>
<h1 id="表分区与分表的区别"><a href="#表分区与分表的区别" class="headerlink" title="表分区与分表的区别"></a>表分区与分表的区别</h1><p>分表：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。 分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。</p>
<h1 id="表分区有什么好处？"><a href="#表分区有什么好处？" class="headerlink" title="表分区有什么好处？"></a>表分区有什么好处？</h1><ol>
<li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。</li>
<li>和单个磁盘或者文件系统相比，可以存储更多数据</li>
<li>优化查询。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</li>
<li>分区表更容易维护。例如：想批量删除大量数据可以清除整个分区。</li>
<li>可以使用分区表来避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问，ext3问价你系统的inode锁竞争等。</li>
</ol>
<h1 id="分区表的限制因素"><a href="#分区表的限制因素" class="headerlink" title="分区表的限制因素"></a>分区表的限制因素</h1><ol>
<li>一个表最多只能有1024个分区</li>
<li>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式。在MySQL5.5中提供了非整数表达式分区的支持。</li>
<li>如果分区字段中有主键或者唯一索引的列，那么多有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。</li>
<li>分区表中无法使用外键约束</li>
<li>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</li>
</ol>
<h1 id="如何判断当前MySQL是否支持分区？"><a href="#如何判断当前MySQL是否支持分区？" class="headerlink" title="如何判断当前MySQL是否支持分区？"></a>如何判断当前MySQL是否支持分区？</h1><p>命令：show variables like ‘%partition%’ 运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show variables like &apos;%partition%&apos;;</div><div class="line">+-------------------+-------+</div><div class="line">| Variable_name     | Value |</div><div class="line">+-------------------+-------+</div><div class="line">| have_partitioning | YES   |</div><div class="line">+-------------------+-------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>have_partintioning 的值为YES，表示支持分区。</p>
<h1 id="MySQL支持的分区类型有哪些？"><a href="#MySQL支持的分区类型有哪些？" class="headerlink" title="MySQL支持的分区类型有哪些？"></a>MySQL支持的分区类型有哪些？</h1><p>1）RANGE分区：按照数据的区间范围分区<br>2）LIST分区：按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。<br>3）HASH分区: 基于给定的分区个数，将数据分配到不同的分区,HASH分区只能针对整数进行HASH，对于非整形的字段只能通过表达式将其转换成整数。支持常规HASH(HASH)和线性HASH()<br>4）KEY分区：在MySQL5.1版本中，RANGE,LIST,HASH分区要求分区键必须是INT类型，或者通过表达式返回INT类型。但KEY分区的时候，可以使用其他类型的列（BLOB，TEXT类型除外）作为分区键。</p>
<h1 id="Range分区"><a href="#Range分区" class="headerlink" title="Range分区"></a>Range分区</h1><p>利用取值范围进行分区，区间要连续并且不能互相重叠。 语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">partition by range(exp)( //exp可以为列名或者表达式，比如to_date(created_date)</div><div class="line">    partition p0 values less than(num)</div><div class="line">    )</div></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; create table emp(</div><div class="line">    -&gt; id INT NOT null,</div><div class="line">    -&gt; store_id int not null</div><div class="line">    -&gt; )</div><div class="line">    -&gt; partition by range(store_id)(</div><div class="line">    -&gt;   partition p0 values less than(10),</div><div class="line">    -&gt;   partition p1 values less than(20)</div><div class="line">    -&gt; );</div></pre></td></tr></table></figure></p>
<p>上面的语句创建了emp表，并根据store_id字段进行分区，小于10的值存在分区p0中，大于等于10，小于20的值存在分区p1中。 注意 每个分区都是按顺序定义的，从最低到最高。上面的语句，如果将less than(10) 和less than (20)的顺序颠倒过来，那么将报错，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR 1493 (HY000): VALUES LESS THAN value must be strictly increasing for each partition</div></pre></td></tr></table></figure></p>
<h2 id="RANGE分区存在的问题"><a href="#RANGE分区存在的问题" class="headerlink" title="RANGE分区存在的问题"></a>RANGE分区存在的问题</h2><p>1.range范围覆盖问题：当插入的记录中对应的分区键的值不在分区定义的范围中的时候，插入语句会失败。 上面的例子，如果我插入一条store_id = 30的记录会怎么样呢？ 我们上面分区的时候，最大值是20，如果插入一条超过20的记录，会报错:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; insert into emp(id,store_id) values(2,30);</div><div class="line">ERROR 1526 (HY000): Table has no partition for value 30</div></pre></td></tr></table></figure>
<p>提示30这个值没有对应的分区。</p>
<blockquote>
<blockquote>
<p><strong>解决办法</strong>:<br>  A. 预估分区键的值，及时新增分区。<br>  B. 设置分区的时候，使用values less than maxvalue 子句,MAXVALUE表示最大的可能的整数值。<br>  C. 尽量选择能够全部覆盖的字段作为分区键，比如一年的十二个月等。</p>
</blockquote>
</blockquote>
<p>2.Range分区中，分区键的值如果是NULL，将被作为一个最小值来处理。</p>
<h1 id="LIST分区"><a href="#LIST分区" class="headerlink" title="LIST分区"></a>LIST分区</h1><p>List分区是建立离散的值列表告诉数据库特定的值属于哪个分区。 语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">partition by list(exp)( //exp为列名或者表达式</div><div class="line">     partition p0 values in (3,5)  //值为3和5的在p0分区</div><div class="line"> )</div></pre></td></tr></table></figure></p>
<p>与Range不同的是，list分区不必生命任何特定的顺序。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; create table emp1(</div><div class="line">    -&gt; id int not null,</div><div class="line">    -&gt; store_id int not null</div><div class="line">    -&gt; )</div><div class="line">    -&gt; partition by list(store_id)(</div><div class="line">    -&gt;   partition p0 values in (3,5),</div><div class="line">    -&gt;   partition p1 values in (2,6,7,9)</div><div class="line">    -&gt; );</div></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<p><strong>注意</strong> 如果插入的记录对应的分区键的值不在list分区指定的值中，将会插入失败。并且，list不能像range分区那样提供maxvalue。</p>
</blockquote>
</blockquote>
<h1 id="Columns分区"><a href="#Columns分区" class="headerlink" title="Columns分区"></a>Columns分区</h1><p>MySQL5.5中引入的分区类型，解决了5.5版本之前range分区和list分区只支持整数分区的问题。 Columns分区可以细分为 range columns分区和 list columns分区，他们都支持整数，日期时间，字符串三大数据类型。（不支持text和blob类型作为分区键） columns分区还支持多列分区（这里不详细展开）。</p>
<h1 id="Hash分区"><a href="#Hash分区" class="headerlink" title="Hash分区"></a>Hash分区</h1><p>Hash分区主要用来分散热点读，确保数据在预先确定个数的分区中尽可能平均分布。 MySQL支持两种Hash分区:常规Hash分区和线性Hash分区。<br>1.常规Hash分区:使用取模算法 语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">partition by hash(store_id) partitions 4;</div></pre></td></tr></table></figure></p>
<p>上面的语句，根据store_id对4取模，决定记录存储位置。 比如store_id = 234的记录，MOD(234,4)=2,所以会被存储在第二个分区。<br><strong>常规Hash分区的优点和不足</strong></p>
<p>  优点：能够使数据尽可能的均匀分布。<br>  缺点：不适合分区经常变动的需求。假如我要新增加两个分区，现在有6个分区，那么MOD(234,6)的结果与之前MOD(234,4)的结果就会出现不一致，这样大部分数据就需要重新计算分区。为解决此问题，MySQL提供了线性Hash分区。<br>2.线性Hash分区：分区函数是一个线性的2的幂的运算法则。 语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">partition by LINER hash(store_id) partitions 4;</div></pre></td></tr></table></figure></p>
<p>与常规Hash的不同在于，“Liner”关键字。 算法介绍: 假设要保存记录的分区编号为N,num为一个非负整数,表示分割成的分区的数量，那么N可以通过以下步骤得到：<br>Step 1. 找到一个大于等于num的2的幂，这个值为V，V可以通过下面公式得到：<br>    V = Power(2,Ceiling(Log(2,num)))<br>例如：刚才设置了4个分区，num=4，Log(2,4)=2,Ceiling(2)=2,power(2,2)=4,即V=4<br>Step 2. 设置N=F(column_list)&amp;(V-1)<br>例如：刚才V=4，store_id=234对应的N值，N = 234&amp;（4-1） =2<br>Step 3. 当N&gt;=num,设置V=Ceiling(V/2),N=N&amp;(V-1)<br>例如：store_id=234,N=2&lt;4,所以N就取值2，即可。<br>假设上面算出来的N=5，那么V=Ceiling(4/2)=2,N=5&amp;(2-1)=1,即在第一个分区。</p>
<p><strong>线性Hash的优点和不足</strong><br>优点：在分区维护（增加，删除，合并，拆分分区）时，MySQL能够处理得更加迅速。<br>缺点：与常规Hash分区相比，线性Hash各个分区之间的数据分布不太均衡。</p>
<h1 id="Key分区"><a href="#Key分区" class="headerlink" title="Key分区"></a>Key分区</h1><p>类似Hash分区，Hash分区允许使用用户自定义的表达式，但Key分区不允许使用用户自定义的表达式。Hash仅支持整数分区，而Key分区支持除了Blob和text的其他类型的列作为分区键。 语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">partition by key(exp) partitions 4;//exp是零个或多个字段名的列表</div></pre></td></tr></table></figure></p>
<p>key分区的时候，exp可以为空，如果为空，则默认使用主键作为分区键，没有主键的时候，会选择非空惟一键作为分区键。</p>
<h1 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h1><p>分区表中对每个分区再次分割，又成为复合分区。</p>
<h1 id="分区对于NULL值的处理"><a href="#分区对于NULL值的处理" class="headerlink" title="分区对于NULL值的处理"></a>分区对于NULL值的处理</h1><p>MySQ允许分区键值为NULL，分区键可能是一个字段或者一个用户定义的表达式。一般情况下，MySQL在分区的时候会把NULL值当作零值或者一个最小值进行处理。</p>
<p><strong>注意</strong><br>Range分区中：NULL值被当作最小值来处理<br>List分区中：NULL值必须出现在列表中，否则不被接受<br>Hash/Key分区中：NULL值会被当作零值来处理</p>
<h1 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h1><p>分区管理包括对于分区的增加，删除，以及查询。<br>1.增加分区：<br>对于Range分区和LIst分区来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table table_name add partition (partition p0 values ...(exp))</div></pre></td></tr></table></figure></p>
<p>values后面的内容根据分区的类型不同而不同。<br>对于Hash分区和Key分区来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table table_name add partition partitions 8;</div></pre></td></tr></table></figure></p>
<p>上面的语句，指的是新增8个分区 。<br>2.删除分区<br>对于Range分区和List分区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table table_name drop partition p0; //p0为要删除的分区名称</div></pre></td></tr></table></figure></p>
<p>删除了分区，同时也将删除该分区中的所有数据。同时，如果删除了分区导致分区不能覆盖所有值，那么插入数据的时候会报错。<br>对于Hash和Key分区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table table_name coalesce partition 2; //将分区缩减到2个</div></pre></td></tr></table></figure></p>
<p>3.分区查询<br>1) 查询某张表一共有多少个分区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select</div><div class="line"> -&gt;   partition_name,</div><div class="line"> -&gt;   partition_expression,</div><div class="line"> -&gt;   partition_description,</div><div class="line"> -&gt;   table_rows</div><div class="line"> -&gt; from</div><div class="line"> -&gt;   INFORMATION_SCHEMA.partitions</div><div class="line"> -&gt; where</div><div class="line"> -&gt;   table_schema=&apos;test&apos;</div><div class="line"> -&gt;   and table_name = &apos;emp&apos;;</div><div class="line">+----------------+----------------------+-----------------------+------------+</div><div class="line">| partition_name | partition_expression | partition_description | table_rows |</div><div class="line">+----------------+----------------------+-----------------------+------------+</div><div class="line">| p0             | store_id             | 10                    |          0 |</div><div class="line">| p1             | store_id             | 20                    |          1 |</div><div class="line">+----------------+----------------------+-----------------------+------------+</div></pre></td></tr></table></figure></p>
<p>即，可以从information_schema.partitions表中查询。<br>2) 查看执行计划，判断查询数据是否进行了分区过滤<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain partitions select * from emp where store_id=10 \G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">        id: 1</div><div class="line">select_type: SIMPLE</div><div class="line">     table: emp</div><div class="line">partitions: p1</div><div class="line">      type: system</div><div class="line">possible_keys: NULL</div><div class="line">       key: NULL</div><div class="line">   key_len: NULL</div><div class="line">       ref: NULL</div><div class="line">      rows: 1</div><div class="line">     Extra:</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<p>本文转自:<a href="https://my.oschina.net/jasonultimate/blog/548745" target="_blank" rel="external">https://my.oschina.net/jasonultimate/blog/548745</a><br>仅供学习实用</p>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是表分区？&quot;&gt;&lt;a href=&quot;#什么是表分区？&quot; class=&quot;headerlink&quot; title=&quot;什么是表分区？&quot;&gt;&lt;/a&gt;什么是表分区？&lt;/h1&gt;&lt;p&gt;表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表
    
    </summary>
    
      <category term="Database" scheme="http://www.pisces.ml/categories/Database/"/>
    
    
      <category term="mysql" scheme="http://www.pisces.ml/tags/mysql/"/>
    
  </entry>
  
</feed>
